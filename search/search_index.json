{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>https://github.com/getify/You-Dont-Know-JS</p>"},{"location":"#bard","title":"bard","text":"<ul> <li>Chapter 1: What's the Scope?</li> <li>closures bard</li> <li>scope: bard version</li> </ul>"},{"location":"#closures","title":"closures","text":"<ul> <li>Chapter 7: Using Closures</li> <li>closures bard</li> </ul>"},{"location":"#mkdocs","title":"mkdocs","text":"<ul> <li>todo cli integration</li> </ul>"},{"location":"#scope","title":"scope","text":"<ul> <li>Chapter 1: What's the Scope?</li> <li>scope: bard version</li> </ul>"},{"location":"todo/","title":"todo cli integration","text":"<ul> <li>this uses mkdocs snippets to integrate todocli</li> </ul>","tags":["mkdocs"]},{"location":"todo/#todotxt","title":"todo.txt","text":"<pre><code>(A) finish setup comments pages\n</code></pre>","tags":["mkdocs"]},{"location":"todo/#donetxt","title":"done.txt","text":"<ul> <li>todo cli repo</li> </ul>","tags":["mkdocs"]},{"location":"todocli/","title":"todo cli","text":""},{"location":"todocli/#doing","title":"doing","text":"<pre><code>(A) finish setup comments pages\n</code></pre>"},{"location":"todocli/#done","title":"done","text":""},{"location":"bujo/2023/","title":"2023","text":"<ul> <li>dont be a noob</li> <li>finish this book</li> </ul>"},{"location":"es-next-beyond/ch1/","title":"Chapter 1: TODO","text":"NOTE: Work in progress"},{"location":"es-next-beyond/toc/","title":"TOC: ES.Next &amp; Beyond - 2nd Edition","text":"NOTE: Work in progress"},{"location":"es-next-beyond/toc/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: TODO<ul> <li>TODO</li> </ul> </li> </ul>"},{"location":"get-started/apA/","title":"Appendix A: Exploring Further","text":"<p>In this appendix, we're going to explore some topics from the main chapter text in a bit more detail. Think of this content as an optional preview of some of the more nuanced details covered throughout the rest of the book series.</p>"},{"location":"get-started/apA/#values-vs-references","title":"Values vs. References","text":"<p>In Chapter 2, we introduced the two main types of values: primitives and objects. But we didn't discuss yet one key difference between the two: how these values are assigned and passed around.</p> <p>In many languages, the developer can choose between assigning/passing a value as the value itself, or as a reference to the value. In JS, however, this decision is entirely determined by the kind of value. That surprises a lot of developers from other languages when they start using JS.</p> <p>If you assign/pass a value itself, the value is copied. For example:</p> <pre><code>var myName = \"Kyle\";\nvar yourName = myName;\n</code></pre> <p>Here, the <code>yourName</code> variable has a separate copy of the <code>\"Kyle\"</code> string from the value that's stored in <code>myName</code>. That's because the value is a primitive, and primitive values are always assigned/passed as value copies.</p> <p>Here's how you can prove there's two separate values involved:</p> <pre><code>var myName = \"Kyle\";\nvar yourName = myName;\nmyName = \"Frank\";\nconsole.log(myName);\n// Frank\nconsole.log(yourName);\n// Kyle\n</code></pre> <p>See how <code>yourName</code> wasn't affected by the re-assignment of <code>myName</code> to <code>\"Frank\"</code>? That's because each variable holds its own copy of the value.</p> <p>By contrast, references are the idea that two or more variables are pointing at the same value, such that modifying this shared value would be reflected by access via any of those references. In JS, only object values (arrays, objects, functions, etc.) are treated as references.</p> <p>Consider:</p> <pre><code>var myAddress = {\nstreet: \"123 JS Blvd\",\ncity: \"Austin\",\nstate: \"TX\"\n};\nvar yourAddress = myAddress;\n// I've got to move to a new house!\nmyAddress.street = \"456 TS Ave\";\nconsole.log(yourAddress.street);\n// 456 TS Ave\n</code></pre> <p>Because the value assigned to <code>myAddress</code> is an object, it's held/assigned by reference, and thus the assignment to the <code>yourAddress</code> variable is a copy of the reference, not the object value itself. That's why the updated value assigned to the <code>myAddress.street</code> is reflected when we access <code>yourAddress.street</code>. <code>myAddress</code> and <code>yourAddress</code> have copies of the reference to the single shared object, so an update to one is an update to both.</p> <p>Again, JS chooses the value-copy vs. reference-copy behavior based on the value type. Primitives are held by value, objects are held by reference. There's no way to override this in JS, in either direction.</p>"},{"location":"get-started/apA/#so-many-function-forms","title":"So Many Function Forms","text":"<p>Recall this snippet from the \"Functions\" section in Chapter 2:</p> <pre><code>var awesomeFunction = function(coolThings) {\n// ..\nreturn amazingStuff;\n};\n</code></pre> <p>The function expression here is referred to as an anonymous function expression, since it has no name identifier between the <code>function</code> keyword and the <code>(..)</code> parameter list. This point confuses many JS developers because as of ES6, JS performs a \"name inference\" on an anonymous function:</p> <pre><code>awesomeFunction.name;\n// \"awesomeFunction\"\n</code></pre> <p>The <code>name</code> property of a function will reveal either its directly given name (in the case of a declaration) or its inferred name in the case of an anonymous function expression. That value is generally used by developer tools when inspecting a function value or when reporting an error stack trace.</p> <p>So even an anonymous function expression might get a name. However, name inference only happens in limited cases such as when the function expression is assigned (with <code>=</code>). If you pass a function expression as an argument to a function call, for example, no name inference occurs; the <code>name</code> property will be an empty string, and the developer console will usually report \"(anonymous function)\".</p> <p>Even if a name is inferred, it's still an anonymous function. Why? Because the inferred name is a metadata string value, not an available identifier to refer to the function. An anonymous function doesn't have an identifier to use to refer to itself from inside itself\u2014for recursion, event unbinding, etc.</p> <p>Compare the anonymous function expression form to:</p> <pre><code>// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function someName(coolThings) {\n// ..\nreturn amazingStuff;\n};\nawesomeFunction.name;\n// \"someName\"\n</code></pre> <p>This function expression is a named function expression, since the identifier <code>someName</code> is directly associated with the function expression at compile time; the association with the identifier <code>awesomeFunction</code> still doesn't happen until runtime at the time of that statement. Those two identifiers don't have to match; sometimes it makes sense to have them be different, other times it's better to have them be the same.</p> <p>Notice also that the explicit function name, the identifier <code>someName</code>, takes precedence when assigning a name for the <code>name</code> property.</p> <p>Should function expressions be named or anonymous? Opinions vary widely on this. Most developers tend to be unconcerned with using anonymous functions. They're shorter, and unquestionably more common in the broad sphere of JS code out there.</p> <p>In my opinion, if a function exists in your program, it has a purpose; otherwise, take it out! And if it has a purpose, it has a natural name that describes that purpose.</p> <p>If a function has a name, you the code author should include that name in the code, so that the reader does not have to infer that name from reading and mentally executing that function's source code. Even a trivial function body like <code>x * 2</code> has to be read to infer a name like \"double\" or \"multBy2\"; that brief extra mental work is unnecessary when you could just take a second to name the function \"double\" or \"multBy2\" once, saving the reader that repeated mental work every time it's read in the future.</p> <p>There are, regrettably in some respects, many other function definition forms in JS as of early 2020 (maybe more in the future!).</p> <p>Here are some more declaration forms:</p> <pre><code>// generator function declaration\nfunction *two() { .. }\n// async function declaration\nasync function three() { .. }\n// async generator function declaration\nasync function *four() { .. }\n// named function export declaration (ES6 modules)\nexport function five() { .. }\n</code></pre> <p>And here are some more of the (many!) function expression forms:</p> <pre><code>// IIFE\n(function(){ .. })();\n(function namedIIFE(){ .. })();\n// asynchronous IIFE\n(async function(){ .. })();\n(async function namedAIIFE(){ .. })();\n// arrow function expressions\nvar f;\nf = () =&gt; 42;\nf = x =&gt; x * 2;\nf = (x) =&gt; x * 2;\nf = (x,y) =&gt; x * y;\nf = x =&gt; ({ x: x * 2 });\nf = x =&gt; { return x * 2; };\nf = async x =&gt; {\nvar y = await doSomethingAsync(x);\nreturn y * 2;\n};\nsomeOperation( x =&gt; x * 2 );\n// ..\n</code></pre> <p>Keep in mind that arrow function expressions are syntactically anonymous, meaning the syntax doesn't provide a way to provide a direct name identifier for the function. The function expression may get an inferred name, but only if it's one of the assignment forms, not in the (more common!) form of being passed as a function call argument (as in the last line of the snippet).</p> <p>Since I don't think anonymous functions are a good idea to use frequently in your programs, I'm not a fan of using the <code>=&gt;</code> arrow function form. This kind of function actually has a specific purpose (i.e., handling the <code>this</code> keyword lexically), but that doesn't mean we should use it for every function we write. Use the most appropriate tool for each job.</p> <p>Functions can also be specified in class definitions and object literal definitions. They're typically referred to as \"methods\" when in these forms, though in JS this term doesn't have much observable difference over \"function\":</p> <pre><code>class SomethingKindaGreat {\n// class methods\ncoolMethod() { .. }   // no commas!\nboringMethod() { .. }\n}\nvar EntirelyDifferent = {\n// object methods\ncoolMethod() { .. },   // commas!\nboringMethod() { .. },\n// (anonymous) function expression property\noldSchool: function() { .. }\n};\n</code></pre> <p>Phew! That's a lot of different ways to define functions.</p> <p>There's no simple shortcut path here; you just have to build familiarity with all the function forms so you can recognize them in existing code and use them appropriately in the code you write. Study them closely and practice!</p>"},{"location":"get-started/apA/#coercive-conditional-comparison","title":"Coercive Conditional Comparison","text":"<p>Yes, that section name is quite a mouthful. But what are we talking about? We're talking about conditional expressions needing to perform coercion-oriented comparisons to make their decisions.</p> <p><code>if</code> and <code>? :</code>-ternary statements, as well as the test clauses in <code>while</code> and <code>for</code> loops, all perform an implicit value comparison. But what sort? Is it \"strict\" or \"coercive\"? Both, actually.</p> <p>Consider:</p> <pre><code>var x = 1;\nif (x) {\n// will run!\n}\nwhile (x) {\n// will run, once!\nx = false;\n}\n</code></pre> <p>You might think of these <code>(x)</code> conditional expressions like this:</p> <pre><code>var x = 1;\nif (x == true) {\n// will run!\n}\nwhile (x == true) {\n// will run, once!\nx = false;\n}\n</code></pre> <p>In this specific case -- the value of <code>x</code> being <code>1</code> -- that mental model works, but it's not accurate more broadly. Consider:</p> <pre><code>var x = \"hello\";\nif (x) {\n// will run!\n}\nif (x == true) {\n// won't run :(\n}\n</code></pre> <p>Oops. So what is the <code>if</code> statement actually doing? This is the more accurate mental model:</p> <pre><code>var x = \"hello\";\nif (Boolean(x) == true) {\n// will run\n}\n// which is the same as:\nif (Boolean(x) === true) {\n// will run\n}\n</code></pre> <p>Since the <code>Boolean(..)</code> function always returns a value of type boolean, the <code>==</code> vs <code>===</code> in this snippet is irrelevant; they'll both do the same thing. But the important part is to see that before the comparison, a coercion occurs, from whatever type <code>x</code> currently is, to boolean.</p> <p>You just can't get away from coercions in JS comparisons. Buckle down and learn them.</p>"},{"location":"get-started/apA/#prototypal-classes","title":"Prototypal \"Classes\"","text":"<p>In Chapter 3, we introduced prototypes and showed how we can link objects through a prototype chain.</p> <p>Another way of wiring up such prototype linkages served as the (honestly, ugly) predecessor to the elegance of the ES6 <code>class</code> system (see Chapter 2, \"Classes\"), and is referred to as prototypal classes.</p> TIP: While this style of code is quite uncommon in JS these days, it's still perplexingly rather common to be asked about it in job interviews! <p>Let's first recall the <code>Object.create(..)</code> style of coding:</p> <pre><code>var Classroom = {\nwelcome() {\nconsole.log(\"Welcome, students!\");\n}\n};\nvar mathClass = Object.create(Classroom);\nmathClass.welcome();\n// Welcome, students!\n</code></pre> <p>Here, a <code>mathClass</code> object is linked via its prototype to a <code>Classroom</code> object. Through this linkage, the function call <code>mathClass.welcome()</code> is delegated to the method defined on <code>Classroom</code>.</p> <p>The prototypal class pattern would have labeled this delegation behavior \"inheritance,\" and alternatively have defined it (with the same behavior) as:</p> <pre><code>function Classroom() {\n// ..\n}\nClassroom.prototype.welcome = function hello() {\nconsole.log(\"Welcome, students!\");\n};\nvar mathClass = new Classroom();\nmathClass.welcome();\n// Welcome, students!\n</code></pre> <p>All functions by default reference an empty object at a property named <code>prototype</code>. Despite the confusing naming, this is not the function's prototype (where the function is prototype linked to), but rather the prototype object to link to when other objects are created by calling the function with <code>new</code>.</p> <p>We add a <code>welcome</code> property on that empty object (called <code>Classroom.prototype</code>), pointing at the <code>hello()</code> function.</p> <p>Then <code>new Classroom()</code> creates a new object (assigned to <code>mathClass</code>), and prototype links it to the existing <code>Classroom.prototype</code> object.</p> <p>Though <code>mathClass</code> does not have a <code>welcome()</code> property/function, it successfully delegates to the function <code>Classroom.prototype.welcome()</code>.</p> <p>This \"prototypal class\" pattern is now strongly discouraged, in favor of using ES6's <code>class</code> mechanism:</p> <pre><code>class Classroom {\nconstructor() {\n// ..\n}\nwelcome() {\nconsole.log(\"Welcome, students!\");\n}\n}\nvar mathClass = new Classroom();\nmathClass.welcome();\n// Welcome, students!\n</code></pre> <p>Under the covers, the same prototype linkage is wired up, but this <code>class</code> syntax fits the class-oriented design pattern much more cleanly than \"prototypal classes\".</p>"},{"location":"get-started/apB/","title":"Appendix B: Practice, Practice, Practice!","text":"<p>In this appendix, we'll explore some exercises and their suggested solutions. These are just to get you started with practice over the concepts from the book.</p>"},{"location":"get-started/apB/#practicing-comparisons","title":"Practicing Comparisons","text":"<p>Let's practice working with value types and comparisons (Chapter 4, Pillar 3) where coercion will need to be involved.</p> <p><code>scheduleMeeting(..)</code> should take a start time (in 24-hour format as a string \"hh:mm\") and a meeting duration (number of minutes). It should return <code>true</code> if the meeting falls entirely within the work day (according to the times specified in <code>dayStart</code> and <code>dayEnd</code>); return <code>false</code> if the meeting violates the work day bounds.</p> <pre><code>const dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\nfunction scheduleMeeting(startTime,durationMinutes) {\n// ..TODO..\n}\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false\n</code></pre> <p>Try to solve this yourself first. Consider the usage of equality and relational comparison operators, and how coercion impacts this code. Once you have code that works, compare your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.</p>"},{"location":"get-started/apB/#practicing-closure","title":"Practicing Closure","text":"<p>Now let's practice with closure (Chapter 4, Pillar 1).</p> <p>The <code>range(..)</code> function takes a number as its first argument, representing the first number in a desired range of numbers. The second argument is also a number representing the end of the desired range (inclusive). If the second argument is omitted, then another function should be returned that expects that argument.</p> <pre><code>function range(start,end) {\n// ..TODO..\n}\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\nvar start3 = range(3);\nvar start4 = range(4);\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\nstart4(6);     // [4,5,6]\n</code></pre> <p>Try to solve this yourself first.</p> <p>Once you have code that works, compare your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.</p>"},{"location":"get-started/apB/#practicing-prototypes","title":"Practicing Prototypes","text":"<p>Finally, let's work on <code>this</code> and objects linked via prototype (Chapter 4, Pillar 2).</p> <p>Define a slot machine with three reels that can individually <code>spin()</code>, and then <code>display()</code> the current contents of all the reels.</p> <p>The basic behavior of a single reel is defined in the <code>reel</code> object below. But the slot machine needs individual reels\u2014objects that delegate to <code>reel</code>, and which each have a <code>position</code> property.</p> <p>A reel only knows how to <code>display()</code> its current slot symbol, but a slot machine typically shows three symbols per reel: the current slot (<code>position</code>), one slot above (<code>position - 1</code>), and one slot below (<code>position + 1</code>). So displaying the slot machine should end up displaying a 3 x 3 grid of slot symbols.</p> <pre><code>function randMax(max) {\nreturn Math.trunc(1E9 * Math.random()) % max;\n}\nvar reel = {\nsymbols: [\n\"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n],\nspin() {\nif (this.position == null) {\nthis.position = randMax(\nthis.symbols.length - 1\n);\n}\nthis.position = (\nthis.position + 100 + randMax(100)\n) % this.symbols.length;\n},\ndisplay() {\nif (this.position == null) {\nthis.position = randMax(\nthis.symbols.length - 1\n);\n}\nreturn this.symbols[this.position];\n}\n};\nvar slotMachine = {\nreels: [\n// this slot machine needs 3 separate reels\n// hint: Object.create(..)\n],\nspin() {\nthis.reels.forEach(function spinReel(reel){\nreel.spin();\n});\n},\ndisplay() {\n// TODO\n}\n};\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605\n</code></pre> <p>Try to solve this yourself first.</p> <p>Hints:</p> <ul> <li> <p>Use the <code>%</code> modulo operator for wrapping <code>position</code> as you access symbols circularly around a reel.</p> </li> <li> <p>Use <code>Object.create(..)</code> to create an object and prototype-link it to another object. Once linked, delegation allows the objects to share <code>this</code> context during method invocation.</p> </li> <li> <p>Instead of modifying the reel object directly to show each of the three positions, you can use another temporary object (<code>Object.create(..)</code> again) with its own <code>position</code>, to delegate from.</p> </li> </ul> <p>Once you have code that works, compare your solution(s) to the code in \"Suggested Solutions\" at the end of this appendix.</p>"},{"location":"get-started/apB/#suggested-solutions","title":"Suggested Solutions","text":"<p>Keep in mind that these suggested solutions are just that: suggestions. There are many different ways to solve these practice exercises. Compare your approach to what you see here, and consider the pros and cons of each.</p> <p>Suggested solution for \"Comparisons\" (Pillar 3) practice:</p> <pre><code>const dayStart = \"07:30\";\nconst dayEnd = \"17:45\";\nfunction scheduleMeeting(startTime,durationMinutes) {\nvar [ , meetingStartHour, meetingStartMinutes ] =\nstartTime.match(/^(\\d{1,2}):(\\d{2})$/) || [];\ndurationMinutes = Number(durationMinutes);\nif (\ntypeof meetingStartHour == \"string\" &amp;&amp;\ntypeof meetingStartMinutes == \"string\"\n) {\nlet durationHours =\nMath.floor(durationMinutes / 60);\ndurationMinutes =\ndurationMinutes - (durationHours * 60);\nlet meetingEndHour =\nNumber(meetingStartHour) + durationHours;\nlet meetingEndMinutes =\nNumber(meetingStartMinutes) +\ndurationMinutes;\nif (meetingEndMinutes &gt;= 60) {\nmeetingEndHour = meetingEndHour + 1;\nmeetingEndMinutes =\nmeetingEndMinutes - 60;\n}\n// re-compose fully-qualified time strings\n// (to make comparison easier)\nlet meetingStart = `${\nmeetingStartHour.padStart(2,\"0\")\n}:${\nmeetingStartMinutes.padStart(2,\"0\")\n}`;\nlet meetingEnd = `${\nString(meetingEndHour).padStart(2,\"0\")\n}:${\nString(meetingEndMinutes).padStart(2,\"0\")\n}`;\n// NOTE: since expressions are all strings,\n// comparisons here are alphabetic, but it's\n// safe here since they're fully qualified\n// time strings (ie, \"07:15\" &lt; \"07:30\")\nreturn (\nmeetingStart &gt;= dayStart &amp;&amp;\nmeetingEnd &lt;= dayEnd\n);\n}\nreturn false;\n}\nscheduleMeeting(\"7:00\",15);     // false\nscheduleMeeting(\"07:15\",30);    // false\nscheduleMeeting(\"7:30\",30);     // true\nscheduleMeeting(\"11:30\",60);    // true\nscheduleMeeting(\"17:00\",45);    // true\nscheduleMeeting(\"17:30\",30);    // false\nscheduleMeeting(\"18:00\",15);    // false\n</code></pre> <p>Suggested solution for \"Closure\" (Pillar 1) practice:</p> <pre><code>function range(start,end) {\nstart = Number(start) || 0;\nif (end === undefined) {\nreturn function getEnd(end) {\nreturn getRange(start,end);\n};\n}\nelse {\nend = Number(end) || 0;\nreturn getRange(start,end);\n}\n// **********************\nfunction getRange(start,end) {\nvar ret = [];\nfor (let i = start; i &lt;= end; i++) {\nret.push(i);\n}\nreturn ret;\n}\n}\nrange(3,3);    // [3]\nrange(3,8);    // [3,4,5,6,7,8]\nrange(3,0);    // []\nvar start3 = range(3);\nvar start4 = range(4);\nstart3(3);     // [3]\nstart3(8);     // [3,4,5,6,7,8]\nstart3(0);     // []\nstart4(6);     // [4,5,6]\n</code></pre> <p>Suggested solution for \"Prototypes\" (Pillar 2) practice:</p> <pre><code>function randMax(max) {\nreturn Math.trunc(1E9 * Math.random()) % max;\n}\nvar reel = {\nsymbols: [\n\"\u2660\", \"\u2665\", \"\u2666\", \"\u2663\", \"\u263a\", \"\u2605\", \"\u263e\", \"\u2600\"\n],\nspin() {\nif (this.position == null) {\nthis.position = randMax(\nthis.symbols.length - 1\n);\n}\nthis.position = (\nthis.position + 100 + randMax(100)\n) % this.symbols.length;\n},\ndisplay() {\nif (this.position == null) {\nthis.position = randMax(\nthis.symbols.length - 1\n);\n}\nreturn this.symbols[this.position];\n}\n};\nvar slotMachine = {\nreels: [\nObject.create(reel),\nObject.create(reel),\nObject.create(reel)\n],\nspin() {\nthis.reels.forEach(function spinReel(reel){\nreel.spin();\n});\n},\ndisplay() {\nvar lines = [];\n// display all 3 lines on the slot machine\nfor (\nlet linePos = -1; linePos &lt;= 1; linePos++\n) {\nlet line = this.reels.map(\nfunction getSlot(reel){\nvar slot = Object.create(reel);\nslot.position = (\nreel.symbols.length +\nreel.position +\nlinePos\n) % reel.symbols.length;\nreturn slot.display();\n}\n);\nlines.push(line.join(\" | \"));\n}\nreturn lines.join(\"\\n\");\n}\n};\nslotMachine.spin();\nslotMachine.display();\n// \u263e | \u2600 | \u2605\n// \u2600 | \u2660 | \u263e\n// \u2660 | \u2665 | \u2600\nslotMachine.spin();\nslotMachine.display();\n// \u2666 | \u2660 | \u2663\n// \u2663 | \u2665 | \u263a\n// \u263a | \u2666 | \u2605\n</code></pre> <p>That's it for this book. But now it's time to look for real projects to practice these ideas on. Just keep coding, because that's the best way to learn!</p>"},{"location":"get-started/ch1/","title":"Chapter 1: What Is JavaScript?","text":"<p>You don't know JS, yet. Neither do I, not fully anyway. None of us do. But we can all start getting to know JS better.</p> <p>In this first chapter of the first book of the You Don't Know JS Yet (YDKJSY) series, we will take some time to build a foundation to move forward on. We need to start by covering a variety of important background housekeeping details, clearing up some myths and misconceptions about what the language really is (and isn't!).</p> <p>This is valuable insight into the identity and process of how JS is organized and maintained; all JS developers should understand it. If you want to get to know JS, this is how to get started taking the first steps in that journey.</p>"},{"location":"get-started/ch1/#about-this-book","title":"About This Book","text":"<p>I emphasize the word journey because knowing JS is not a destination, it's a direction. No matter how much time you spend with the language, you will always be able to find something else to learn and understand a little better. So don't look at this book as something to rush through for a quick achievement. Instead, patience and persistence are best as you take these first few steps.</p> <p>Following this background chapter, the rest of the book lays out a high-level map of what you will find as you dig into and study JS with the YDKJSY books.</p> <p>In particular, Chapter 4 identifies three main pillars around which the JS language is organized: scope/closures, prototypes/objects, and types/coercion. JS is a broad and sophisticated language, with many features and capabilities. But all of JS is founded on these three foundational pillars.</p> <p>Keep in mind that even though this book is titled \"Get Started,\" it's not intended as a beginner/intro book. This book's main job is to get you ready for studying JS deeply throughout the rest of the series; it's written assuming you already have familiarity with JS over at least several months experience before moving on in YDKJSY. So to get the most out of Get Started, make sure you spend plenty of time writing JS code to build up your experience.</p> <p>Even if you've already written a lot of JS before, this book should not be skimmed over or skipped; take your time to fully process the material here. A good start always depends on a solid first step.</p>"},{"location":"get-started/ch1/#whats-with-that-name","title":"What's With That Name?","text":"<p>The name JavaScript is probably the most mistaken and misunderstood programming language name.</p> <p>Is this language related to Java? Is it only the script form for Java? Is it only for writing scripts and not real programs?</p> <p>The truth is, the name JavaScript is an artifact of marketing shenanigans. When Brendan Eich first conceived of the language, he code-named it Mocha. Internally at Netscape, the brand LiveScript was used. But when it came time to publicly name the language, \"JavaScript\" won the vote.</p> <p>Why? Because this language was originally designed to appeal to an audience of mostly Java programmers, and because the word \"script\" was popular at the time to refer to lightweight programs. These lightweight \"scripts\" would be the first ones to embed inside of pages on this new thing called the web!</p> <p>In other words, JavaScript was a marketing ploy to try to position this language as a palatable alternative to writing the heavier and more well-known Java of the day. It could just as easily have been called \"WebJava,\" for that matter.</p> <p>There are some superficial resemblances between JavaScript's code and Java code. Those similarities don't particularly come from shared development, but from both languages targeting developers with assumed syntax expectations from C (and to an extent, C++).</p> <p>For example, we use the <code>{</code> to begin a block of code and the <code>}</code> to end that block of code, just like C/C++ and Java. We also use the <code>;</code> to punctuate the end of a statement.</p> <p>In some ways, legal relationships run even deeper than the syntax. Oracle (via Sun), the company that still owns and runs Java, also owns the official trademark for the name \"JavaScript\" (via Netscape). This trademark is almost never enforced, and likely couldn't be at this point.</p> <p>For these reasons, some have suggested we use JS instead of JavaScript. That is a very common shorthand, if not a good candidate for an official language branding itself. Indeed, these books use JS almost exclusively to refer to the language.</p> <p>Further distancing the language from the Oracle-owned trademark, the official name of the language specified by TC39 and formalized by the ECMA standards body is ECMAScript. And indeed, since 2016, the official language name has also been suffixed by the revision year; as of this writing, that's ECMAScript 2019, or otherwise abbreviated ES2019.</p> <p>In other words, the JavaScript/JS that runs in your browser or in Node.js, is an implementation of the ES2019 standard.</p> NOTE: Don't use terms like \"JS6\" or \"ES8\" to refer to the language. Some do, but those terms only serve to perpetuate confusion. \"ES20xx\" or just \"JS\" are what you should stick to. <p>Whether you call it JavaScript, JS, ECMAScript, or ES2019, it's most definitely not a variant of the Java language!</p> <p>\"Java is to JavaScript as ham is to hamster.\" --Jeremy Keith, 2009</p>"},{"location":"get-started/ch1/#language-specification","title":"Language Specification","text":"<p>I mentioned TC39, the technical steering committee that manages JS. Their primary task is managing the official specification for the language. They meet regularly to vote on any agreed changes, which they then submit to ECMA, the standards organization.</p> <p>JS's syntax and behavior are defined in the ES specification.</p> <p>ES2019 happens to be the 10th major numbered specification/revision since JS's inception in 1995, so in the specification's official URL as hosted by ECMA, you'll find \"10.0\":</p> <p>https://www.ecma-international.org/ecma-262/10.0/</p> <p>The TC39 committee is comprised of between 50 and about 100 different people from a broad section of web-invested companies, such as browser makers (Mozilla, Google, Apple) and device makers (Samsung, etc). All members of the committee are volunteers, though many of them are employees of these companies and so may receive compensation in part for their duties on the committee.</p> <p>TC39 meets generally about every other month, usually for about three days, to review work done by members since the last meeting, discuss issues, and vote on proposals. Meeting locations rotate among member companies willing to host.</p> <p>All TC39 proposals progress through a five-stage process\u2014of course, since we're programmers, it's 0-based!\u2014Stage 0 through Stage 4. You can read more about the Stage process here: https://tc39.es/process-document/</p> <p>Stage 0 means roughly, someone on TC39 thinks it's a worthy idea and plans to champion and work on it. That means lots of ideas that non-TC39 members \"propose,\" through informal means such as social media or blog posts, are really \"pre-stage 0.\" You have to get a TC39 member to champion a proposal for it to be considered \"Stage 0\" officially.</p> <p>Once a proposal reaches \"Stage 4\" status, it is eligible to be included in the next yearly revision of the language. It can take anywhere from several months to a few years for a proposal to work its way through these stages.</p> <p>All proposals are managed in the open, on TC39's Github repository: https://github.com/tc39/proposals</p> <p>Anyone, whether on TC39 or not, is welcome to participate in these public discussions and the processes for working on the proposals. However, only TC39 members can attend meetings and vote on the proposals and changes. So in effect, the voice of a TC39 member carries a lot of weight in where JS will go.</p> <p>Contrary to some established and frustratingly perpetuated myth, there are not multiple versions of JavaScript in the wild. There's just one JS, the official standard as maintained by TC39 and ECMA.</p> <p>Back in the early 2000s, when Microsoft maintained a forked and reverse-engineered (and not entirely compatible) version of JS called \"JScript,\" there were legitimately \"multiple versions\" of JS. But those days are long gone. It's outdated and inaccurate to make such claims about JS today.</p> <p>All major browsers and device makers have committed to keeping their JS implementations compliant with this one central specification. Of course, engines implement features at different times. But it should never be the case that the v8 engine (Chrome's JS engine) implements a specified feature differently or incompatibly as compared to the SpiderMonkey engine (Mozilla's JS engine).</p> <p>That means you can learn one JS, and rely on that same JS everywhere.</p>"},{"location":"get-started/ch1/#the-web-rules-everything-about-js","title":"The Web Rules Everything About (JS)","text":"<p>While the array of environments that run JS is constantly expanding (from browsers, to servers (Node.js), to robots, to lightbulbs, to...), the one environment that rules JS is the web. In other words, how JS is implemented for web browsers is, in all practicality, the only reality that matters.</p> <p>For the most part, the JS defined in the specification and the JS that runs in browser-based JS engines is the same. But there are some differences that must be considered.</p> <p>Sometimes the JS specification will dictate some new or refined behavior, and yet that won't exactly match with how it works in browser-based JS engines. Such a mismatch is historical: JS engines have had 20+ years of observable behaviors around corner cases of features that have come to be relied on by web content. As such, sometimes the JS engines will refuse to conform to a specification-dictated change because it would break that web content.</p> <p>In these cases, often TC39 will backtrack and simply choose to conform the specification to the reality of the web. For example, TC39 planned to add a <code>contains(..)</code> method for Arrays, but it was found that this name conflicted with old JS frameworks still in use on some sites, so they changed the name to a non-conflicting <code>includes(..)</code>. The same happened with a comedic/tragic JS community crisis dubbed \"smooshgate,\" where the planned <code>flatten(..)</code> method was eventually renamed <code>flat(..)</code>.</p> <p>But occasionally, TC39 will decide the specification should stick firm on some point even though it is unlikely that browser-based JS engines will ever conform.</p> <p>The solution? Appendix B, \"Additional ECMAScript Features for Web Browsers\".1 The JS specification includes this appendix to detail out any known mismatches between the official JS specification and the reality of JS on the web. In other words, these are exceptions that are allowed only for web JS; other JS environments must stick to the letter of the law.</p> <p>Section B.1 and B.2 cover additions to JS (syntax and APIs) that web JS includes, again for historical reasons, but which TC39 does not plan to formally specify in the core of JS. Examples include <code>0</code>-prefixed octal literals, the global <code>escape(..)</code> / <code>unescape(..)</code> utilities, String \"helpers\" like <code>anchor(..)</code> and <code>blink()</code>, and the RegExp <code>compile(..)</code> method.</p> <p>Section B.3 includes some conflicts where code may run in both web and non-web JS engines, but where the behavior could be observably different, resulting in different outcomes. Most of the listed changes involve situations that are labeled as early errors when code is running in strict mode.</p> <p>Appendix B gotchas aren't encountered very often, but it's still a good idea to avoid these constructs to be future safe. Wherever possible, adhere to the JS specification and don't rely on behavior that's only applicable in certain JS engine environments.</p>"},{"location":"get-started/ch1/#not-all-web-js","title":"Not All (Web) JS...","text":"<p>Is this code a JS program?</p> <pre><code>alert(\"Hello, JS!\");\n</code></pre> <p>Depends on how you look at things. The <code>alert(..)</code> function shown here is not included in the JS specification, but it is in all web JS environments. Yet, you won't find it in Appendix B, so what gives?</p> <p>Various JS environments (like browser JS engines, Node.js, etc.) add APIs into the global scope of your JS programs that give you environment-specific capabilities, like being able to pop an alert-style box in the user's browser.</p> <p>In fact, a wide range of JS-looking APIs, like <code>fetch(..)</code>, <code>getCurrentLocation(..)</code>, and <code>getUserMedia(..)</code>, are all web APIs that look like JS. In Node.js, we can access hundreds of API methods from various built-in modules, like <code>fs.write(..)</code>.</p> <p>Another common example is <code>console.log(..)</code> (and all the other <code>console.*</code> methods!). These are not specified in JS, but because of their universal utility are defined by pretty much every JS environment, according to a roughly agreed consensus.</p> <p>So <code>alert(..)</code> and <code>console.log(..)</code> are not defined by JS. But they look like JS. They are functions and object methods and they obey JS syntax rules. The behaviors behind them are controlled by the environment running the JS engine, but on the surface they definitely have to abide by JS to be able to play in the JS playground.</p> <p>Most of the cross-browser differences people complain about with \"JS is so inconsistent!\" claims are actually due to differences in how those environment behaviors work, not in how the JS itself works.</p> <p>So an <code>alert(..)</code> call is JS, but <code>alert</code> itself is really just a guest, not part of the official JS specification.</p>"},{"location":"get-started/ch1/#its-not-always-js","title":"It's Not Always JS","text":"<p>Using the console/REPL (Read-Evaluate-Print-Loop) in your browser's Developer Tools (or Node) feels like a pretty straightforward JS environment at first glance. But it's not, really.</p> <p>Developer Tools are... tools for developers. Their primary purpose is to make life easier for developers. They prioritize DX (Developer Experience). It is not a goal of such tools to accurately and purely reflect all nuances of strict-spec JS behavior. As such, there's many quirks that may act as \"gotchas\" if you're treating the console as a pure JS environment.</p> <p>This convenience is a good thing, by the way! I'm glad Developer Tools make developers' lives easier! I'm glad we have nice UX charms like auto-complete of variables/properties, etc. I'm just pointing out that we can't and shouldn't expect such tools to always adhere strictly to the way JS programs are handled, because that's not the purpose of these tools.</p> <p>Since such tools vary in behavior from browser to browser, and since they change (sometimes rather frequently), I'm not going to \"hardcode\" any of the specific details into this text, thereby ensuring this book text is outdated quickly.</p> <p>But I'll just hint at some examples of quirks that have been true at various points in different JS console environments, to reinforce my point about not assuming native JS behavior while using them:</p> <ul> <li> <p>Whether a <code>var</code> or <code>function</code> declaration in the top-level \"global scope\" of the console actually creates a real global variable (and mirrored <code>window</code> property, and vice versa!).</p> </li> <li> <p>What happens with multiple <code>let</code> and <code>const</code> declarations in the top-level \"global scope.\"</p> </li> <li> <p>Whether <code>\"use strict\";</code> on one line-entry (pressing <code>&lt;enter&gt;</code> after) enables strict mode for the rest of that console session, the way it would on the first line of a .js file, as well as whether you can use <code>\"use strict\";</code> beyond the \"first line\" and still get strict mode turned on for that session.</p> </li> <li> <p>How non-strict mode <code>this</code> default-binding works for function calls, and whether the \"global object\" used will contain expected global variables.</p> </li> <li> <p>How hoisting (see Book 2, Scope &amp; Closures) works across multiple line entries.</p> </li> <li> <p>...several others</p> </li> </ul> <p>The developer console is not trying to pretend to be a JS compiler that handles your entered code exactly the same way the JS engine handles a .js file. It's trying to make it easy for you to quickly enter a few lines of code and see the results immediately. These are entirely different use cases, and as such, it's unreasonable to expect one tool to handle both equally.</p> <p>Don't trust what behavior you see in a developer console as representing exact to-the-letter JS semantics; for that, read the specification. Instead, think of the console as a \"JS-friendly\" environment. That's useful in its own right.</p>"},{"location":"get-started/ch1/#many-faces","title":"Many Faces","text":"<p>The term \"paradigm\" in programming language context refers to a broad (almost universal) mindset and approach to structuring code. Within a paradigm, there are myriad variations of style and form that distinguish programs, including countless different libraries and frameworks that leave their unique signature on any given code.</p> <p>But no matter what a program's individual style may be, the big picture divisions around paradigms are almost always evident at first glance of any program.</p> <p>Typical paradigm-level code categories include procedural, object-oriented (OO/classes), and functional (FP):</p> <ul> <li> <p>Procedural style organizes code in a top-down, linear progression through a pre-determined set of operations, usually collected together in related units called procedures.</p> </li> <li> <p>OO style organizes code by collecting logic and data together into units called classes.</p> </li> <li> <p>FP style organizes code into functions (pure computations as opposed to procedures), and the adaptations of those functions as values.</p> </li> </ul> <p>Paradigms are neither right nor wrong. They're orientations that guide and mold how programmers approach problems and solutions, how they structure and maintain their code.</p> <p>Some languages are heavily slanted toward one paradigm\u2014C is procedural, Java/C++ are almost entirely class oriented, and Haskell is FP through and through.</p> <p>But many languages also support code patterns that can come from, and even mix and match from, different paradigms. So called \"multi-paradigm languages\" offer ultimate flexibility. In some cases, a single program can even have two or more expressions of these paradigms sitting side by side.</p> <p>JavaScript is most definitely a multi-paradigm language. You can write procedural, class-oriented, or FP-style code, and you can make those decisions on a line-by-line basis instead of being forced into an all-or-nothing choice.</p>"},{"location":"get-started/ch1/#backwards-forwards","title":"Backwards &amp; Forwards","text":"<p>One of the most foundational principles that guides JavaScript is preservation of backwards compatibility. Many are confused by the implications of this term, and often confuse it with a related but different term: forwards compatibility.</p> <p>Let's set the record straight.</p> <p>Backwards compatibility means that once something is accepted as valid JS, there will not be a future change to the language that causes that code to become invalid JS. Code written in 1995\u2014however primitive or limited it may have been!\u2014should still work today. As TC39 members often proclaim, \"we don't break the web!\"</p> <p>The idea is that JS developers can write code with confidence that their code won't stop working unpredictably because a browser update is released. This makes the decision to choose JS for a program a more wise and safe investment, for years into the future.</p> <p>That \"guarantee\" is no small thing. Maintaining backwards compatibility, stretched out across almost 25 years of the language's history, creates an enormous burden and a whole slew of unique challenges. You'd be hard pressed to find many other examples in computing of such a commitment to backwards compatibility.</p> <p>The costs of sticking to this principle should not be casually dismissed. It necessarily creates a very high bar to including changing or extending the language; any decision becomes effectively permanent, mistakes and all. Once it's in JS, it can't be taken out because it might break programs, even if we'd really, really like to remove it!</p> <p>There are some small exceptions to this rule. JS has had some backwards-incompatible changes, but TC39 is extremely cautious in doing so. They study existing code on the web (via browser data gathering) to estimate the impact of such breakage, and browsers ultimately decide and vote on whether they're willing to take the heat from users for a very small-scale breakage weighed against the benefits of fixing or improving some aspect of the language for many more sites (and users).</p> <p>These kinds of changes are rare, and are almost always in corner cases of usage that are unlikely to be observably breaking in many sites.</p> <p>Compare backwards compatibility to its counterpart, forwards compatibility. Being forwards-compatible means that including a new addition to the language in a program would not cause that program to break if it were run in an older JS engine. JS is not forwards-compatible, despite many wishing such, and even incorrectly believing the myth that it is.</p> <p>HTML and CSS, by contrast, are forwards-compatible but not backwards-compatible. If you dug up some HTML or CSS written back in 1995, it's entirely possible it would not work (or work the same) today. But, if you use a new feature from 2019 in a browser from 2010, the page isn't \"broken\" -- the unrecognized CSS/HTML is skipped over, while the rest of the CSS/HTML would be processed accordingly.</p> <p>It may seem desirable for forwards-compatibility to be included in programming language design, but it's generally impractical to do so. Markup (HTML) or styling (CSS) are declarative in nature, so it's much easier to \"skip over\" unrecognized declarations with minimal impact to other recognized declarations.</p> <p>But chaos and non-determinism would ensue if a programming language engine selectively skipped statements (or even expressions!) that it didn't understand, as it's impossible to ensure that a subsequent part of the program wasn't expecting the skipped-over part to have been processed.</p> <p>Though JS isn't, and can't be, forwards-compatible, it's critical to recognize JS's backwards compatibility, including the enduring benefits to the web and the constraints and difficulties it places on JS as a result.</p>"},{"location":"get-started/ch1/#jumping-the-gaps","title":"Jumping the Gaps","text":"<p>Since JS is not forwards-compatible, it means that there is always the potential for a gap between code that you can write that's valid JS, and the oldest engine that your site or application needs to support. If you run a program that uses an ES2019 feature in an engine from 2016, you're very likely to see the program break and crash.</p> <p>If the feature is a new syntax, the program will in general completely fail to compile and run, usually throwing a syntax error. If the feature is an API (such as ES6's <code>Object.is(..)</code>), the program may run up to a point but then throw a runtime exception and stop once it encounters the reference to the unknown API.</p> <p>Does this mean JS developers should always lag behind the pace of progress, using only code that is on the trailing edge of the oldest JS engine environments they need to support? No!</p> <p>But it does mean that JS developers need to take special care to address this gap.</p> <p>For new and incompatible syntax, the solution is transpiling. Transpiling is a contrived and community-invented term to describe using a tool to convert the source code of a program from one form to another (but still as textual source code). Typically, forwards-compatibility problems related to syntax are solved by using a transpiler (the most common one being Babel (https://babeljs.io)) to convert from that newer JS syntax version to an equivalent older syntax.</p> <p>For example, a developer may write a snippet of code like:</p> <pre><code>if (something) {\nlet x = 3;\nconsole.log(x);\n}\nelse {\nlet x = 4;\nconsole.log(x);\n}\n</code></pre> <p>This is how the code would look in the source code tree for that application. But when producing the file(s) to deploy to the public website, the Babel transpiler might convert that code to look like this:</p> <pre><code>var x$0, x$1;\nif (something) {\nx$0 = 3;\nconsole.log(x$0);\n}\nelse {\nx$1 = 4;\nconsole.log(x$1);\n}\n</code></pre> <p>The original snippet relied on <code>let</code> to create block-scoped <code>x</code> variables in both the <code>if</code> and <code>else</code> clauses which did not interfere with each other. An equivalent program (with minimal re-working) that Babel can produce just chooses to name two different variables with unique names, producing the same non-interference outcome.</p> NOTE: The <code>let</code> keyword was added in ES6 (in 2015). The preceding example of transpiling would only need to apply if an application needed to run in a pre-ES6 supporting JS environment. The example here is just for simplicity of illustration. When ES6 was new, the need for such a transpilation was quite prevalent, but in 2020 it's much less common to need to support pre-ES6 environments. The \"target\" used for transpiliation is thus a sliding window that shifts upward only as decisions are made for a site/application to stop supporting some old browser/engine. <p>You may wonder: why go to the trouble of using a tool to convert from a newer syntax version to an older one? Couldn't we just write the two variables and skip using the <code>let</code> keyword? The reason is, it's strongly recommended that developers use the latest version of JS so that their code is clean and communicates its ideas most effectively.</p> <p>Developers should focus on writing the clean, new syntax forms, and let the tools take care of producing a forwards-compatible version of that code that is suitable to deploy and run on the oldest-supported JS engine environments.</p>"},{"location":"get-started/ch1/#filling-the-gaps","title":"Filling the Gaps","text":"<p>If the forwards-compatibility issue is not related to new syntax, but rather to a missing API method that was only recently added, the most common solution is to provide a definition for that missing API method that stands in and acts as if the older environment had already had it natively defined. This pattern is called a polyfill (aka \"shim\").</p> <p>Consider this code:</p> <pre><code>// getSomeRecords() returns us a promise for some\n// data it will fetch\nvar pr = getSomeRecords();\n// show the UI spinner while we get the data\nstartSpinner();\npr\n.then(renderRecords)   // render if successful\n.catch(showError)      // show an error if not\n.finally(hideSpinner)  // always hide the spinner\n</code></pre> <p>This code uses an ES2019 feature, the <code>finally(..)</code> method on the promise prototype. If this code were used in a pre-ES2019 environment, the <code>finally(..)</code> method would not exist, and an error would occur.</p> <p>A polyfill for <code>finally(..)</code> in pre-ES2019 environments could look like this:</p> <pre><code>if (!Promise.prototype.finally) {\nPromise.prototype.finally = function f(fn){\nreturn this.then(\nfunction t(v){\nreturn Promise.resolve( fn() )\n.then(function t(){\nreturn v;\n});\n},\nfunction c(e){\nreturn Promise.resolve( fn() )\n.then(function t(){\nthrow e;\n});\n}\n);\n};\n}\n</code></pre> WARNING: This is only a simple illustration of a basic (not entirely spec-compliant) polyfill for <code>finally(..)</code>. Don't use this polyfill in your code; always use a robust, official polyfill wherever possible, such as the collection of polyfills/shims in ES-Shim. <p>The <code>if</code> statement protects the polyfill definition by preventing it from running in any environment where the JS engine has already defined that method. In older environments, the polyfill is defined, but in newer environments the <code>if</code> statement is quietly skipped.</p> <p>Transpilers like Babel typically detect which polyfills your code needs and provide them automatically for you. But occasionally you may need to include/define them explicitly, which works similar to the snippet we just looked at.</p> <p>Always write code using the most appropriate features to communicate its ideas and intent effectively. In general, this means using the most recent stable JS version. Avoid negatively impacting the code's readability by trying to manually adjust for the syntax/API gaps. That's what tools are for!</p> <p>Transpilation and polyfilling are two highly effective techniques for addressing that gap between code that uses the latest stable features in the language and the old environments a site or application needs to still support. Since JS isn't going to stop improving, the gap will never go away. Both techniques should be embraced as a standard part of every JS project's production chain going forward.</p>"},{"location":"get-started/ch1/#whats-in-an-interpretation","title":"What's in an Interpretation?","text":"<p>A long-debated question for code written in JS: is it an interpreted script or a compiled program? The majority opinion seems to be that JS is an interpreted (scripting) language. But the truth is more complicated than that.</p> <p>For much of the history of programming languages, \"interpreted\" languages and \"scripting\" languages have been looked down on as inferior compared to their compiled counterparts. The reasons for this acrimony are numerous, including the perception that there is a lack of performance optimization, as well as dislike of certain language characteristics, such as scripting languages generally using dynamic typing instead of the \"more mature\" statically typed languages.</p> <p>Languages regarded as \"compiled\" usually produce a portable (binary) representation of the program that is distributed for execution later. Since we don't really observe that kind of model with JS (we distribute the source code, not the binary form), many claim that disqualifies JS from the category. In reality, the distribution model for a program's \"executable\" form has become drastically more varied and also less relevant over the last few decades; to the question at hand, it doesn't really matter so much anymore what form of a program gets passed around.</p> <p>These misinformed claims and criticisms should be set aside. The real reason it matters to have a clear picture on whether JS is interpreted or compiled relates to the nature of how errors are handled.</p> <p>Historically, scripted or interpreted languages were executed in generally a top-down and line-by-line fashion; there's typically not an initial pass through the program to process it before execution begins (see Figure 1).</p> Fig. 1: Interpreted/Scripted Execution <p>In scripted or interpreted languages, an error on line 5 of a program won't be discovered until lines 1 through 4 have already executed. Notably, the error on line 5 might be due to a runtime condition, such as some variable or value having an unsuitable value for an operation, or it may be due to a malformed statement/command on that line. Depending on context, deferring error handling to the line the error occurs on may be a desirable or undesirable effect.</p> <p>Compare that to languages which do go through a processing step (typically, called parsing) before any execution occurs, as illustrated in Figure 2:</p> Fig. 2: Parsing + Compilation + Execution <p>In this processing model, an invalid command (such as broken syntax) on line 5 would be caught during the parsing phase, before any execution has begun, and none of the program would run. For catching syntax (or otherwise \"static\") errors, generally it's preferred to know about them ahead of any doomed partial execution.</p> <p>So what do \"parsed\" languages have in common with \"compiled\" languages? First, all compiled languages are parsed. So a parsed language is quite a ways down the road toward being compiled already. In classic compilation theory, the last remaining step after parsing is code generation: producing an executable form.</p> <p>Once any source program has been fully parsed, it's very common that its subsequent execution will, in some form or fashion, include a translation from the parsed form of the program\u2014usually called an Abstract Syntax Tree (AST)\u2014to that executable form.</p> <p>In other words, parsed languages usually also perform code generation before execution, so it's not that much of a stretch to say that, in spirit, they're compiled languages.</p> <p>JS source code is parsed before it is executed. The specification requires as much, because it calls for \"early errors\"\u2014statically determined errors in code, such as a duplicate parameter name\u2014to be reported before the code starts executing. Those errors cannot be recognized without the code having been parsed.</p> <p>So JS is a parsed language, but is it compiled?</p> <p>The answer is closer to yes than no. The parsed JS is converted to an optimized (binary) form, and that \"code\" is subsequently executed (Figure 2); the engine does not commonly switch back into line-by-line execution (like Figure 1) mode after it has finished all the hard work of parsing\u2014most languages/engines wouldn't, because that would be highly inefficient.</p> <p>To be specific, this \"compilation\" produces a binary byte code (of sorts), which is then handed to the \"JS virtual machine\" to execute. Some like to say this VM is \"interpreting\" the byte code. But then that means Java, and a dozen other JVM-driven languages, for that matter, are interpreted rather than compiled. Of course, that contradicts the typical assertion that Java/etc are compiled languages.</p> <p>Interestingly, while Java and JavaScript are very different languages, the question of interpreted/compiled is pretty closely related between them!</p> <p>Another wrinkle is that JS engines can employ multiple passes of JIT (Just-In-Time) processing/optimization on the generated code (post parsing), which again could reasonably be labeled either \"compilation\" or \"interpretation\" depending on perspective. It's actually a fantastically complex situation under the hood of a JS engine.</p> <p>So what do these nitty-gritty details boil down to? Step back and consider the entire flow of a JS source program:</p> <ol> <li> <p>After a program leaves a developer's editor, it gets transpiled by Babel, then packed by Webpack (and perhaps half a dozen other build processes), then it gets delivered in that very different form to a JS engine.</p> </li> <li> <p>The JS engine parses the code to an AST.</p> </li> <li> <p>Then the engine converts that AST to a kind-of byte code, a binary intermediate representation (IR), which is then refined/converted even further by the optimizing JIT compiler.</p> </li> <li> <p>Finally, the JS VM executes the program.</p> </li> </ol> <p>To visualize those steps, again:</p> Fig. 3: Parsing, Compiling, and Executing JS <p>Is JS handled more like an interpreted, line-by-line script, as in Figure 1, or is it handled more like a compiled language that's processed in one-to-several passes first, before execution (as in Figures 2 and 3)?</p> <p>I think it's clear that in spirit, if not in practice, JS is a compiled language.</p> <p>And again, the reason that matters is, since JS is compiled, we are informed of static errors (such as malformed syntax) before our code is executed. That is a substantively different interaction model than we get with traditional \"scripting\" programs, and arguably more helpful!</p>"},{"location":"get-started/ch1/#web-assembly-wasm","title":"Web Assembly (WASM)","text":"<p>One dominating concern that has driven a significant amount of JS's evolution is performance, both how quickly JS can be parsed/compiled and how quickly that compiled code can be executed.</p> <p>In 2013, engineers from Mozilla Firefox demonstrated a port of the Unreal 3 game engine from C to JS. The ability for this code to run in a browser JS engine at full 60fps performance was predicated on a set of optimizations that the JS engine could perform specifically because the JS version of the Unreal engine's code used a style of code that favored a subset of the JS language, named \"ASM.js\".</p> <p>This subset is valid JS written in ways that are somewhat uncommon in normal coding, but which signal certain important typing information to the engine that allow it to make key optimizations. ASM.js was introduced as one way of addressing the pressures on the runtime performance of JS.</p> <p>But it's important to note that ASM.js was never intended to be code that was authored by developers, but rather a representation of a program having been transpiled from another language (such as C), where these typing \"annotations\" were inserted automatically by the tooling.</p> <p>Several years after ASM.js demonstrated the validity of tooling-created versions of programs that can be processed more efficiently by the JS engine, another group of engineers (also, initially, from Mozilla) released Web Assembly (WASM).</p> <p>WASM is similar to ASM.js in that its original intent was to provide a path for non-JS programs (C, etc.) to be converted to a form that could run in the JS engine. Unlike ASM.js, WASM chose to additionally get around some of the inherent delays in JS parsing/compilation before a program can execute, by representing the program in a form that is entirely unlike JS.</p> <p>WASM is a representation format more akin to Assembly (hence, its name) that can be processed by a JS engine by skipping the parsing/compilation that the JS engine normally does. The parsing/compilation of a WASM-targeted program happen ahead of time (AOT); what's distributed is a binary-packed program ready for the JS engine to execute with very minimal processing.</p> <p>An initial motivation for WASM was clearly the potential performance improvements. While that continues to be a focus, WASM is additionally motivated by the desire to bring more parity for non-JS languages to the web platform. For example, if a language like Go supports threaded programming, but JS (the language) does not, WASM offers the potential for such a Go program to be converted to a form the JS engine can understand, without needing a threads feature in the JS language itself.</p> <p>In other words, WASM relieves the pressure to add features to JS that are mostly/exclusively intended to be used by transpiled programs from other languages. That means JS feature development can be judged (by TC39) without being skewed by interests/demands in other language ecosystems, while still letting those languages have a viable path onto the web.</p> <p>Another perspective on WASM that's emerging is, interestingly, not even directly related to the web (W). WASM is evolving to become a cross-platform virtual machine (VM) of sorts, where programs can be compiled once and run in a variety of different system environments.</p> <p>So, WASM isn't only for the web, and WASM also isn't JS. Ironically, even though WASM runs in the JS engine, the JS language is one of the least suitable languages to source WASM programs with, because WASM relies heavily on static typing information. Even TypeScript (TS)\u2014ostensibly, JS + static types\u2014is not quite suitable (as it stands) to transpile to WASM, though language variants like AssemblyScript are attempting to bridge the gap between JS/TS and WASM.</p> <p>This book isn't about WASM, so I won't spend much more time discussing it, except to make one final point. Some folks have suggested WASM points to a future where JS is excised from, or minimized in, the web. These folks often harbor ill feelings about JS, and want some other language\u2014any other language!\u2014to replace it. Since WASM lets other languages run in the JS engine, on its face this isn't an entirely fanciful fairytale.</p> <p>But let me just state simply: WASM will not replace JS. WASM significantly augments what the web (including JS) can accomplish. That's a great thing, entirely orthogonal to whether some people will use it as an escape hatch from having to write JS.</p>"},{"location":"get-started/ch1/#strictly-speaking","title":"Strictly Speaking","text":"<p>Back in 2009 with the release of ES5, JS added strict mode as an opt-in mechanism for encouraging better JS programs.</p> <p>The benefits of strict mode far outweigh the costs, but old habits die hard and the inertia of existing (aka \"legacy\") code bases is really hard to shift. So sadly, more than 10 years later, strict mode's optionality means that it's still not necessarily the default for JS programmers.</p> <p>Why strict mode? Strict mode shouldn't be thought of as a restriction on what you can't do, but rather as a guide to the best way to do things so that the JS engine has the best chance of optimizing and efficiently running the code. Most JS code is worked on by teams of developers, so the strict-ness of strict mode (along with tooling like linters!) often helps collaboration on code by avoiding some of the more problematic mistakes that slip by in non-strict mode.</p> <p>Most strict mode controls are in the form of early errors, meaning errors that aren't strictly syntax errors but are still thrown at compile time (before the code is run). For example, strict mode disallows naming two function parameters the same, and results in an early error. Some other strict mode controls are only observable at runtime, such as how <code>this</code> defaults to <code>undefined</code> instead of the global object.</p> <p>Rather than fighting and arguing with strict mode, like a kid who just wants to defy whatever their parents tell them not to do, the best mindset is that strict mode is like a linter reminding you how JS should be written to have the highest quality and best chance at performance. If you find yourself feeling handcuffed, trying to work around strict mode, that should be a blaring red warning flag that you need to back up and rethink the whole approach.</p> <p>Strict mode is switched on per file with a special pragma (nothing allowed before it except comments/whitespace):</p> <pre><code>// only whitespace and comments are allowed\n// before the use-strict pragma\n\"use strict\";\n// the rest of the file runs in strict mode\n</code></pre> WARNING: Something to be aware of is that even a stray <code>;</code> all by itself appearing before the strict mode pragma will render the pragma useless; no errors are thrown because it's valid JS to have a string literal expression in a statement position, but it also will silently not turn on strict mode! <p>Strict mode can alternatively be turned on per-function scope, with exactly the same rules about its surroundings:</p> <pre><code>function someOperations() {\n// whitespace and comments are fine here\n\"use strict\";\n// all this code will run in strict mode\n}\n</code></pre> <p>Interestingly, if a file has strict mode turned on, the function-level strict mode pragmas are disallowed. So you have to pick one or the other.</p> <p>The only valid reason to use a per-function approach to strict mode is when you are converting an existing non-strict mode program file and need to make the changes little by little over time. Otherwise, it's vastly better to simply turn strict mode on for the entire file/program.</p> <p>Many have wondered if there would ever be a time when JS made strict mode the default? The answer is, almost certainly not. As we discussed earlier around backwards compatibility, if a JS engine update started assuming code was strict mode even if it's not marked as such, it's possible that this code would break as a result of strict mode's controls.</p> <p>However, there are a few factors that reduce the future impact of this non-default \"obscurity\" of strict mode.</p> <p>For one, virtually all transpiled code ends up in strict mode even if the original source code isn't written as such. Most JS code in production has been transpiled, so that means most JS is already adhering to strict mode. It's possible to undo that assumption, but you really have to go out of your way to do so, so it's highly unlikely.</p> <p>Moreover, a wide shift is happening toward more/most new JS code being written using the ES6 module format. ES6 modules assume strict mode, so all code in such files is automatically defaulted to strict mode.</p> <p>Taken together, strict mode is largely the de facto default even though technically it's not actually the default.</p>"},{"location":"get-started/ch1/#defined","title":"Defined","text":"<p>JS is an implementation of the ECMAScript standard (version ES2019 as of this writing), which is guided by the TC39 committee and hosted by ECMA. It runs in browsers and other JS environments such as Node.js.</p> <p>JS is a multi-paradigm language, meaning the syntax and capabilities allow a developer to mix and match (and bend and reshape!) concepts from various major paradigms, such as procedural, object-oriented (OO/classes), and functional (FP).</p> <p>JS is a compiled language, meaning the tools (including the JS engine) process and verify a program (reporting any errors!) before it executes.</p> <p>With our language now defined, let's start getting to know its ins and outs.</p> <ol> <li> <p>ECMAScript 2019 Language Specification, Appendix B: Additional ECMAScript Features for Web Browsers, https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers (latest as of time of this writing in January 2020)\u00a0\u21a9</p> </li> </ol>"},{"location":"get-started/ch2/","title":"Chapter 2: Surveying JS","text":"<p>The best way to learn JS is to start writing JS.</p> <p>To do that, you need to know how the language works, and that's what we'll focus on here. Even if you've programmed in other languages before, take your time getting comfortable with JS, and make sure to practice each piece.</p> <p>This chapter is not an exhaustive reference on every bit of syntax of the JS language. It's also not intended to be a complete \"intro to JS\" primer.</p> <p>Instead, we're just going to survey some of the major topic areas of the language. Our goal is to get a better feel for it, so that we can move forward writing our own programs with more confidence. We'll revisit many of these topics in successively more detail as you go through the rest of this book, and the rest of the series.</p> <p>Please don't expect this chapter to be a quick read. It's long and there's plenty of detail to chew on. Take your time.</p> TIP: If you're still getting familiar with JS, I suggest you reserve plenty of extra time to work through this chapter. Take each section and ponder and explore the topic for awhile. Look through existing JS programs and compare what you see in them to the code and explanations (and opinions!) presented here. You will get a lot more out of the rest of the book and series with a solid foundation of JS's nature."},{"location":"get-started/ch2/#each-file-is-a-program","title":"Each File is a Program","text":"<p>Almost every website (web application) you use is comprised of many different JS files (typically with the .js file extension). It's tempting to think of the whole thing (the application) as one program. But JS sees it differently.</p> <p>In JS, each standalone file is its own separate program.</p> <p>The reason this matters is primarily around error handling. Since JS treats files as programs, one file may fail (during parse/compile or execution) and that will not necessarily prevent the next file from being processed. Obviously, if your application depends on five .js files, and one of them fails, the overall application will probably only partially operate, at best. It's important to ensure that each file works properly, and that to whatever extent possible, they handle failure in other files as gracefully as possible.</p> <p>It may surprise you to consider separate .js files as separate JS programs. From the perspective of your usage of an application, it sure seems like one big program. That's because the execution of the application allows these individual programs to cooperate and act as one program.</p> NOTE: Many projects use build process tools that end up combining separate files from the project into a single file to be delivered to a web page. When this happens, JS treats this single combined file as the entire program. <p>The only way multiple standalone .js files act as a single program is by sharing their state (and access to their public functionality) via the \"global scope.\" They mix together in this global scope namespace, so at runtime they act as a whole.</p> <p>Since ES6, JS has also supported a module format in addition to the typical standalone JS program format. Modules are also file-based. If a file is loaded via module-loading mechanism such as an <code>import</code> statement or a <code>&lt;script type=module&gt;</code> tag, all its code is treated as a single module.</p> <p>Though you wouldn't typically think about a module\u2014a collection of state and publicly exposed methods to operate on that state\u2014as a standalone program, JS does in fact still treat each module separately. Similar to how \"global scope\" allows standalone files to mix together at runtime, importing a module into another allows runtime interoperation between them.</p> <p>Regardless of which code organization pattern (and loading mechanism) is used for a file (standalone or module), you should still think of each file as its own (mini) program, which may then cooperate with other (mini) programs to perform the functions of your overall application.</p>"},{"location":"get-started/ch2/#values","title":"Values","text":"<p>The most fundamental unit of information in a program is a value. Values are data. They're how the program maintains state. Values come in two forms in JS: primitive and object.</p> <p>Values are embedded in programs using literals:</p> <pre><code>greeting(\"My name is Kyle.\");\n</code></pre> <p>In this program, the value <code>\"My name is Kyle.\"</code> is a primitive string literal; strings are ordered collections of characters, usually used to represent words and sentences.</p> <p>I used the double-quote <code>\"</code> character to delimit (surround, separate, define) the string value. But I could have used the single-quote <code>'</code> character as well. The choice of which quote character is entirely stylistic. The important thing, for the sake of code readability and maintainability, is to pick one and to use it consistently throughout the program.</p> <p>Another option to delimit a string literal is to use the back-tick <code>`</code> character. However, this choice is not merely stylistic; there's a behavioral difference as well. Consider:</p> <pre><code>console.log(\"My name is ${ firstName }.\");\n// My name is ${ firstName }.\nconsole.log('My name is ${ firstName }.');\n// My name is ${ firstName }.\nconsole.log(`My name is ${ firstName }.`);\n// My name is Kyle.\n</code></pre> <p>Assuming this program has already defined a variable <code>firstName</code> with the string value <code>\"Kyle\"</code>, the <code>`</code>-delimited string then resolves the variable expression (indicated with <code>${ .. }</code>) to its current value. This is called interpolation.</p> <p>The back-tick <code>`</code>-delimited string can be used without including interpolated expressions, but that defeats the whole purpose of that alternate string literal syntax:</p> <pre><code>console.log(\n`Am I confusing you by omitting interpolation?`\n);\n// Am I confusing you by omitting interpolation?\n</code></pre> <p>The better approach is to use <code>\"</code> or <code>'</code> (again, pick one and stick to it!) for strings unless you need interpolation; reserve <code>`</code> only for strings that will include interpolated expressions.</p> <p>Other than strings, JS programs often contain other primitive literal values such as booleans and numbers:</p> <pre><code>while (false) {\nconsole.log(3.141592);\n}\n</code></pre> <p><code>while</code> represents a loop type, a way to repeat operations while its condition is true.</p> <p>In this case, the loop will never run (and nothing will be printed), because we used the <code>false</code> boolean value as the loop conditional. <code>true</code> would have resulted in a loop that keeps going forever, so be careful!</p> <p>The number <code>3.141592</code> is, as you may know, an approximation of mathematical PI to the first six digits. Rather than embed such a value, however, you would typically use the predefined <code>Math.PI</code> value for that purpose. Another variation on numbers is the <code>bigint</code> (big-integer) primitive type, which is used for storing arbitrarily large numbers.</p> <p>Numbers are most often used in programs for counting steps, such as loop iterations, and accessing information in numeric positions (i.e., an array index). We'll cover arrays/objects in a little bit, but as an example, if there was an array called <code>names</code>, we could access the element in its second position like this:</p> <pre><code>console.log(`My name is ${ names[1] }.`);\n// My name is Kyle.\n</code></pre> <p>We used <code>1</code> for the element in the second position, instead of <code>2</code>, because like in most programming languages, JS array indices are 0-based (<code>0</code> is the first position).</p> <p>In addition to strings, numbers, and booleans, two other primitive values in JS programs are <code>null</code> and <code>undefined</code>. While there are differences between them (some historic and some contemporary), for the most part both values serve the purpose of indicating emptiness (or absence) of a value.</p> <p>Many developers prefer to treat them both consistently in this fashion, which is to say that the values are assumed to be indistinguishable. If care is taken, this is often possible. However, it's safest and best to use only <code>undefined</code> as the single empty value, even though <code>null</code> seems attractive in that it's shorter to type!</p> <pre><code>while (value != undefined) {\nconsole.log(\"Still got something!\");\n}\n</code></pre> <p>The final primitive value to be aware of is a symbol, which is a special-purpose value that behaves as a hidden unguessable value. Symbols are almost exclusively used as special keys on objects:</p> <pre><code>hitchhikersGuide[ Symbol(\"meaning of life\") ];\n// 42\n</code></pre> <p>You won't encounter direct usage of symbols very often in typical JS programs. They're mostly used in low-level code such as in libraries and frameworks.</p>"},{"location":"get-started/ch2/#arrays-and-objects","title":"Arrays And Objects","text":"<p>Besides primitives, the other value type in JS is an object value.</p> <p>As mentioned earlier, arrays are a special type of object that's comprised of an ordered and numerically indexed list of data:</p> <pre><code>var names = [ \"Frank\", \"Kyle\", \"Peter\", \"Susan\" ];\nnames.length;\n// 4\nnames[0];\n// Frank\nnames[1];\n// Kyle\n</code></pre> <p>JS arrays can hold any value type, either primitive or object (including other arrays). As we'll see toward the end of Chapter 3, even functions are values that can be held in arrays or objects.</p> NOTE: Functions, like arrays, are a special kind (aka, sub-type) of object. We'll cover functions in more detail in a bit. <p>Objects are more general: an unordered, keyed collection of any various values. In other words, you access the element by a string location name (aka \"key\" or \"property\") rather than by its numeric position (as with arrays). For example:</p> <pre><code>var me = {\nfirst: \"Kyle\",\nlast: \"Simpson\",\nage: 39,\nspecialties: [ \"JS\", \"Table Tennis\" ]\n};\nconsole.log(`My name is ${ me.first }.`);\n</code></pre> <p>Here, <code>me</code> represents an object, and <code>first</code> represents the name of a location of information in that object (value collection). Another syntax option that accesses information in an object by its property/key uses the square-brackets <code>[ ]</code>, such as  <code>me[\"first\"]</code>.</p>"},{"location":"get-started/ch2/#value-type-determination","title":"Value Type Determination","text":"<p>For distinguishing values, the <code>typeof</code> operator tells you its built-in type, if primitive, or <code>\"object\"</code> otherwise:</p> <pre><code>typeof 42;                  // \"number\"\ntypeof \"abc\";               // \"string\"\ntypeof true;                // \"boolean\"\ntypeof undefined;           // \"undefined\"\ntypeof null;                // \"object\" -- oops, bug!\ntypeof { \"a\": 1 };          // \"object\"\ntypeof [1,2,3];             // \"object\"\ntypeof function hello(){};  // \"function\"\n</code></pre> WARNING: <code>typeof null</code> unfortunately returns <code>\"object\"</code> instead of the expected <code>\"null\"</code>. Also, <code>typeof</code> returns the specific <code>\"function\"</code> for functions, but not the expected <code>\"array\"</code> for arrays. <p>Converting from one value type to another, such as from string to number, is referred to in JS as \"coercion.\" We'll cover this in more detail later in this chapter.</p> <p>Primitive values and object values behave differently when they're assigned or passed around. We'll cover these details in Appendix A, \"Values vs References.\"</p>"},{"location":"get-started/ch2/#declaring-and-using-variables","title":"Declaring and Using Variables","text":"<p>To be explicit about something that may not have been obvious in the previous section: in JS programs, values can either appear as literal values (as many of the preceding examples illustrate), or they can be held in variables; think of variables as just containers for values.</p> <p>Variables have to be declared (created) to be used. There are various syntax forms that declare variables (aka, \"identifiers\"), and each form has different implied behaviors.</p> <p>For example, consider the <code>var</code> statement:</p> <pre><code>var myName = \"Kyle\";\nvar age;\n</code></pre> <p>The <code>var</code> keyword declares a variable to be used in that part of the program, and optionally allows an initial assignment of a value.</p> <p>Another similar keyword is <code>let</code>:</p> <pre><code>let myName = \"Kyle\";\nlet age;\n</code></pre> <p>The <code>let</code> keyword has some differences to <code>var</code>, with the most obvious being that <code>let</code> allows a more limited access to the variable than <code>var</code>. This is called \"block scoping\" as opposed to regular or function scoping.</p> <p>Consider:</p> <pre><code>var adult = true;\nif (adult) {\nvar myName = \"Kyle\";\nlet age = 39;\nconsole.log(\"Shhh, this is a secret!\");\n}\nconsole.log(myName);\n// Kyle\nconsole.log(age);\n// Error!\n</code></pre> <p>The attempt to access <code>age</code> outside of the <code>if</code> statement results in an error, because <code>age</code> was block-scoped to the <code>if</code>, whereas <code>myName</code> was not.</p> <p>Block-scoping is very useful for limiting how widespread variable declarations are in our programs, which helps prevent accidental overlap of their names.</p> <p>But <code>var</code> is still useful in that it communicates \"this variable will be seen by a wider scope (of the whole function)\". Both declaration forms can be appropriate in any given part of a program, depending on the circumstances.</p> NOTE: It's very common to suggest that <code>var</code> should be avoided in favor of <code>let</code> (or <code>const</code>!), generally because of perceived confusion over how the scoping behavior of <code>var</code> has worked since the beginning of JS. I believe this to be overly restrictive advice and ultimately unhelpful. It's assuming you are unable to learn and use a feature properly in combination with other features. I believe you can and should learn any features available, and use them where appropriate! <p>A third declaration form is <code>const</code>. It's like <code>let</code> but has an additional limitation that it must be given a value at the moment it's declared, and cannot be re-assigned a different value later.</p> <p>Consider:</p> <pre><code>const myBirthday = true;\nlet age = 39;\nif (myBirthday) {\nage = age + 1;    // OK!\nmyBirthday = false;  // Error!\n}\n</code></pre> <p>The <code>myBirthday</code> constant is not allowed to be re-assigned.</p> <p><code>const</code> declared variables are not \"unchangeable\", they just cannot be re-assigned. It's ill-advised to use <code>const</code> with object values, because those values can still be changed even though the variable can't be re-assigned. This leads to potential confusion down the line, so I think it's wise to avoid situations like:</p> <pre><code>const actors = [\n\"Morgan Freeman\", \"Jennifer Aniston\"\n];\nactors[2] = \"Tom Cruise\";   // OK :(\nactors = [];                // Error!\n</code></pre> <p>The best semantic use of a <code>const</code> is when you have a simple primitive value that you want to give a useful name to, such as using <code>myBirthday</code> instead of <code>true</code>. This makes programs easier to read.</p> TIP: If you stick to using <code>const</code> only with primitive values, you avoid any confusion of re-assignment (not allowed) vs. mutation (allowed)! That's the safest and best way to use <code>const</code>. <p>Besides <code>var</code> / <code>let</code> / <code>const</code>, there are other syntactic forms that declare identifiers (variables) in various scopes. For example:</p> <pre><code>function hello(myName) {\nconsole.log(`Hello, ${ myName }.`);\n}\nhello(\"Kyle\");\n// Hello, Kyle.\n</code></pre> <p>The identifier <code>hello</code> is created in the outer scope, and it's also automatically associated so that it references the function. But the named parameter <code>myName</code> is created only inside the function, and thus is only accessible inside that function's scope. <code>hello</code> and <code>myName</code> generally behave as <code>var</code>-declared.</p> <p>Another syntax that declares a variable is a <code>catch</code> clause:</p> <pre><code>try {\nsomeError();\n}\ncatch (err) {\nconsole.log(err);\n}\n</code></pre> <p>The <code>err</code> is a block-scoped variable that exists only inside the <code>catch</code> clause, as if it had been declared with <code>let</code>.</p>"},{"location":"get-started/ch2/#functions","title":"Functions","text":"<p>The word \"function\" has a variety of meanings in programming. For example, in the world of Functional Programming, \"function\" has a precise mathematical definition and implies a strict set of rules to abide by.</p> <p>In JS, we should consider \"function\" to take the broader meaning of another related term: \"procedure.\" A procedure is a collection of statements that can be invoked one or more times, may be provided some inputs, and may give back one or more outputs.</p> <p>From the early days of JS, function definition looked like:</p> <pre><code>function awesomeFunction(coolThings) {\n// ..\nreturn amazingStuff;\n}\n</code></pre> <p>This is called a function declaration because it appears as a statement by itself, not as an expression in another statement. The association between the identifier <code>awesomeFunction</code> and the function value happens during the compile phase of the code, before that code is executed.</p> <p>In contrast to a function declaration statement, a function expression can be defined and assigned like this:</p> <pre><code>// let awesomeFunction = ..\n// const awesomeFunction = ..\nvar awesomeFunction = function(coolThings) {\n// ..\nreturn amazingStuff;\n};\n</code></pre> <p>This function is an expression that is assigned to the variable <code>awesomeFunction</code>. Different from the function declaration form, a function expression is not associated with its identifier until that statement during runtime.</p> <p>It's extremely important to note that in JS, functions are values that can be assigned (as shown in this snippet) and passed around. In fact, JS functions are a special type of the object value type. Not all languages treat functions as values, but it's essential for a language to support the functional programming pattern, as JS does.</p> <p>JS functions can receive parameter input:</p> <pre><code>function greeting(myName) {\nconsole.log(`Hello, ${ myName }!`);\n}\ngreeting(\"Kyle\");   // Hello, Kyle!\n</code></pre> <p>In this snippet, <code>myName</code> is called a parameter, which acts as a local variable inside the function. Functions can be defined to receive any number of parameters, from none upward, as you see fit. Each parameter is assigned the argument value that you pass in that position (<code>\"Kyle\"</code>, here) of the call.</p> <p>Functions also can return values using the <code>return</code> keyword:</p> <pre><code>function greeting(myName) {\nreturn `Hello, ${ myName }!`;\n}\nvar msg = greeting(\"Kyle\");\nconsole.log(msg);   // Hello, Kyle!\n</code></pre> <p>You can only <code>return</code> a single value, but if you have more values to return, you can wrap them up into a single object/array.</p> <p>Since functions are values, they can be assigned as properties on objects:</p> <pre><code>var whatToSay = {\ngreeting() {\nconsole.log(\"Hello!\");\n},\nquestion() {\nconsole.log(\"What's your name?\");\n},\nanswer() {\nconsole.log(\"My name is Kyle.\");\n}\n};\nwhatToSay.greeting();\n// Hello!\n</code></pre> <p>In this snippet, references to three functions (<code>greeting()</code>, <code>question()</code>, and <code>answer()</code>) are included in the object held by <code>whatToSay</code>. Each function can be called by accessing the property to retrieve the function reference value. Compare this straightforward style of defining functions on an object to the more sophisticated <code>class</code> syntax discussed later in this chapter.</p> <p>There are many varied forms that <code>function</code>s take in JS. We dig into these variations in Appendix A, \"So Many Function Forms.\"</p>"},{"location":"get-started/ch2/#comparisons","title":"Comparisons","text":"<p>Making decisions in programs requires comparing values to determine their identity and relationship to each other. JS has several mechanisms to enable value comparison, so let's take a closer look at them.</p>"},{"location":"get-started/ch2/#equalish","title":"Equal...ish","text":"<p>The most common comparison in JS programs asks the question, \"Is this X value the same as that Y value?\" What exactly does \"the same as\" really mean to JS, though?</p> <p>For ergonomic and historical reasons, the meaning is more complicated than the obvious exact identity sort of matching. Sometimes an equality comparison intends exact matching, but other times the desired comparison is a bit broader, allowing closely similar or interchangeable matching. In other words, we must be aware of the nuanced differences between an equality comparison and an equivalence comparison.</p> <p>If you've spent any time working with and reading about JS, you've certainly seen the so-called \"triple-equals\" <code>===</code> operator, also described as the \"strict equality\" operator. That seems rather straightforward, right? Surely, \"strict\" means strict, as in narrow and exact.</p> <p>Not exactly.</p> <p>Yes, most values participating in an <code>===</code> equality comparison will fit with that exact same intuition. Consider some examples:</p> <pre><code>3 === 3.0;              // true\n\"yes\" === \"yes\";        // true\nnull === null;          // true\nfalse === false;        // true\n42 === \"42\";            // false\n\"hello\" === \"Hello\";    // false\ntrue === 1;             // false\n0 === null;             // false\n\"\" === null;            // false\nnull === undefined;     // false\n</code></pre> NOTE: Another way <code>===</code>'s equality comparison is often described is, \"checking both the value and the type\". In several of the examples we've looked at so far, like <code>42 === \"42\"</code>, the type of both values (number, string, etc.) does seem to be the distinguishing factor. There's more to it than that, though. All value comparisons in JS consider the type of the values being compared, not just the <code>===</code> operator. Specifically, <code>===</code> disallows any sort of type conversion (aka, \"coercion\") in its comparison, where other JS comparisons do allow coercion. <p>But the <code>===</code> operator does have some nuance to it, a fact many JS developers gloss over, to their detriment. The <code>===</code> operator is designed to lie in two cases of special values: <code>NaN</code> and <code>-0</code>. Consider:</p> <pre><code>NaN === NaN;            // false\n0 === -0;               // true\n</code></pre> <p>In the case of <code>NaN</code>, the <code>===</code> operator lies and says that an occurrence of <code>NaN</code> is not equal to another <code>NaN</code>. In the case of <code>-0</code> (yes, this is a real, distinct value you can use intentionally in your programs!), the <code>===</code> operator lies and says it's equal to the regular <code>0</code> value.</p> <p>Since the lying about such comparisons can be bothersome, it's best to avoid using <code>===</code> for them. For <code>NaN</code> comparisons, use the <code>Number.isNaN(..)</code> utility, which does not lie. For <code>-0</code> comparison, use the <code>Object.is(..)</code> utility, which also does not lie. <code>Object.is(..)</code> can also be used for non-lying <code>NaN</code> checks, if you prefer. Humorously, you could think of <code>Object.is(..)</code> as the \"quadruple-equals\" <code>====</code>, the really-really-strict comparison!</p> <p>There are deeper historical and technical reasons for these lies, but that doesn't change the fact that <code>===</code> is not actually strictly exactly equal comparison, in the strictest sense.</p> <p>The story gets even more complicated when we consider comparisons of object values (non-primitives). Consider:</p> <pre><code>[ 1, 2, 3 ] === [ 1, 2, 3 ];    // false\n{ a: 42 } === { a: 42 }         // false\n(x =&gt; x * 2) === (x =&gt; x * 2)   // false\n</code></pre> <p>What's going on here?</p> <p>It may seem reasonable to assume that an equality check considers the nature or contents of the value; after all, <code>42 === 42</code> considers the actual <code>42</code> value and compares it. But when it comes to objects, a content-aware comparison is generally referred to as \"structural equality.\"</p> <p>JS does not define <code>===</code> as structural equality for object values. Instead, <code>===</code> uses identity equality for object values.</p> <p>In JS, all object values are held by reference (see \"Values vs References\" in Appendix A), are assigned and passed by reference-copy, and to our current discussion, are compared by reference (identity) equality. Consider:</p> <pre><code>var x = [ 1, 2, 3 ];\n// assignment is by reference-copy, so\n// y references the *same* array as x,\n// not another copy of it.\nvar y = x;\ny === x;              // true\ny === [ 1, 2, 3 ];    // false\nx === [ 1, 2, 3 ];    // false\n</code></pre> <p>In this snippet, <code>y === x</code> is true because both variables hold a reference to the same initial array. But the <code>=== [1,2,3]</code> comparisons both fail because <code>y</code> and <code>x</code>, respectively, are being compared to new different arrays <code>[1,2,3]</code>. The array structure and contents don't matter in this comparison, only the reference identity.</p> <p>JS does not provide a mechanism for structural equality comparison of object values, only reference identity comparison. To do structural equality comparison, you'll need to implement the checks yourself.</p> <p>But beware, it's more complicated than you'll assume. For example, how might you determine if two function references are \"structurally equivalent\"? Even stringifying to compare their source code text wouldn't take into account things like closure. JS doesn't provide structural equality comparison because it's almost intractable to handle all the corner cases!</p>"},{"location":"get-started/ch2/#coercive-comparisons","title":"Coercive Comparisons","text":"<p>Coercion means a value of one type being converted to its respective representation in another type (to whatever extent possible). As we'll discuss in Chapter 4, coercion is a core pillar of the JS language, not some optional feature that can reasonably be avoided.</p> <p>But where coercion meets comparison operators (like equality), confusion and frustration unfortunately crop up more often than not.</p> <p>Few JS features draw more ire in the broader JS community than the <code>==</code> operator, generally referred to as the \"loose equality\" operator. The majority of all writing and public discourse on JS condemns this operator as poorly designed and dangerous/bug-ridden when used in JS programs. Even the creator of the language himself, Brendan Eich, has lamented how it was designed as a big mistake.</p> <p>From what I can tell, most of this frustration comes from a pretty short list of confusing corner cases, but a deeper problem is the extremely widespread misconception that it performs its comparisons without considering the types of its compared values.</p> <p>The <code>==</code> operator performs an equality comparison similarly to how the <code>===</code> performs it. In fact, both operators consider the type of the values being compared. And if the comparison is between the same value type, both <code>==</code> and <code>===</code> do exactly the same thing, no difference whatsoever.</p> <p>If the value types being compared are different, the <code>==</code> differs from <code>===</code> in that it allows coercion before the comparison. In other words, they both want to compare values of like types, but <code>==</code> allows type conversions first, and once the types have been converted to be the same on both sides, then <code>==</code> does the same thing as <code>===</code>. Instead of \"loose equality,\" the <code>==</code> operator should be described as \"coercive equality.\"</p> <p>Consider:</p> <pre><code>42 == \"42\";             // true\n1 == true;              // true\n</code></pre> <p>In both comparisons, the value types are different, so the <code>==</code> causes the non-number values (<code>\"42\"</code> and <code>true</code>) to be converted to numbers (<code>42</code> and <code>1</code>, respectively) before the comparisons are made.</p> <p>Just being aware of this nature of <code>==</code>\u2014that it prefers primitive numeric comparisons\u2014helps you avoid most of the troublesome corner cases, such as staying away from a gotchas like <code>\"\" == 0</code> or <code>0 == false</code>.</p> <p>You may be thinking, \"Oh, well, I will just always avoid any coercive equality comparison (using <code>===</code> instead) to avoid those corner cases\"! Eh, sorry, that's not quite as likely as you would hope.</p> <p>There's a pretty good chance that you'll use relational comparison operators like <code>&lt;</code>, <code>&gt;</code> (and even <code>&lt;=</code> and <code>&gt;=</code>).</p> <p>Just like <code>==</code>, these operators will perform as if they're \"strict\" if the types being relationally compared already match, but they'll allow coercion first (generally, to numbers) if the types differ.</p> <p>Consider:</p> <pre><code>var arr = [ \"1\", \"10\", \"100\", \"1000\" ];\nfor (let i = 0; i &lt; arr.length &amp;&amp; arr[i] &lt; 500; i++) {\n// will run 3 times\n}\n</code></pre> <p>The <code>i &lt; arr.length</code> comparison is \"safe\" from coercion because <code>i</code> and <code>arr.length</code> are always numbers. The <code>arr[i] &lt; 500</code> invokes coercion, though, because the <code>arr[i]</code> values are all strings. Those comparisons thus become <code>1 &lt; 500</code>, <code>10 &lt; 500</code>, <code>100 &lt; 500</code>, and <code>1000 &lt; 500</code>. Since that fourth one is false, the loop stops after its third iteration.</p> <p>These relational operators typically use numeric comparisons, except in the case where both values being compared are already strings; in this case, they use alphabetical (dictionary-like) comparison of the strings:</p> <pre><code>var x = \"10\";\nvar y = \"9\";\nx &lt; y;      // true, watch out!\n</code></pre> <p>There's no way to get these relational operators to avoid coercion, other than to just never use mismatched types in the comparisons. That's perhaps admirable as a goal, but it's still pretty likely you're going to run into a case where the types may differ.</p> <p>The wiser approach is not to avoid coercive comparisons, but to embrace and learn their ins and outs.</p> <p>Coercive comparisons crop up in other places in JS, such as conditionals (<code>if</code>, etc.), which we'll revisit in Appendix A, \"Coercive Conditional Comparison.\"</p>"},{"location":"get-started/ch2/#how-we-organize-in-js","title":"How We Organize in JS","text":"<p>Two major patterns for organizing code (data and behavior) are used broadly across the JS ecosystem: classes and modules. These patterns are not mutually exclusive; many programs can and do use both. Other programs will stick with just one pattern, or even neither!</p> <p>In some respects, these patterns are very different. But interestingly, in other ways, they're just different sides of the same coin. Being proficient in JS requires understanding both patterns and where they are appropriate (and not!).</p>"},{"location":"get-started/ch2/#classes","title":"Classes","text":"<p>The terms \"object-oriented,\" \"class-oriented,\" and \"classes\" are all very loaded full of detail and nuance; they're not universal in definition.</p> <p>We will use a common and somewhat traditional definition here, the one most likely familiar to those with backgrounds in \"object-oriented\" languages like C++ and Java.</p> <p>A class in a program is a definition of a \"type\" of custom data structure that includes both data and behaviors that operate on that data. Classes define how such a data structure works, but classes are not themselves concrete values. To get a concrete value that you can use in the program, a class must be instantiated (with the <code>new</code> keyword) one or more times.</p> <p>Consider:</p> <pre><code>class Page {\nconstructor(text) {\nthis.text = text;\n}\nprint() {\nconsole.log(this.text);\n}\n}\nclass Notebook {\nconstructor() {\nthis.pages = [];\n}\naddPage(text) {\nvar page = new Page(text);\nthis.pages.push(page);\n}\nprint() {\nfor (let page of this.pages) {\npage.print();\n}\n}\n}\nvar mathNotes = new Notebook();\nmathNotes.addPage(\"Arithmetic: + - * / ...\");\nmathNotes.addPage(\"Trigonometry: sin cos tan ...\");\nmathNotes.print();\n// ..\n</code></pre> <p>In the <code>Page</code> class, the data is a string of text stored in a <code>this.text</code> member property. The behavior is <code>print()</code>, a method that dumps the text to the console.</p> <p>For the <code>Notebook</code> class, the data is an array of <code>Page</code> instances. The behavior is <code>addPage(..)</code>, a method that instantiates new <code>Page</code> pages and adds them to the list, as well as <code>print()</code> (which prints out all the pages in the notebook).</p> <p>The statement <code>mathNotes = new Notebook()</code> creates an instance of the <code>Notebook</code> class, and <code>page = new Page(text)</code> is where instances of the <code>Page</code> class are created.</p> <p>Behavior (methods) can only be called on instances (not the classes themselves), such as <code>mathNotes.addPage(..)</code> and <code>page.print()</code>.</p> <p>The <code>class</code> mechanism allows packaging data (<code>text</code> and <code>pages</code>) to be organized together with their behaviors (e.g., <code>addPage(..)</code> and <code>print()</code>). The same program could have been built without any <code>class</code> definitions, but it would likely have been much less organized, harder to read and reason about, and more susceptible to bugs and subpar maintenance.</p>"},{"location":"get-started/ch2/#class-inheritance","title":"Class Inheritance","text":"<p>Another aspect inherent to traditional \"class-oriented\" design, though a bit less commonly used in JS, is \"inheritance\" (and \"polymorphism\"). Consider:</p> <pre><code>class Publication {\nconstructor(title,author,pubDate) {\nthis.title = title;\nthis.author = author;\nthis.pubDate = pubDate;\n}\nprint() {\nconsole.log(`\n            Title: ${ this.title }\n            By: ${ this.author }\n${ this.pubDate }\n        `);\n}\n}\n</code></pre> <p>This <code>Publication</code> class defines a set of common behavior that any publication might need.</p> <p>Now let's consider more specific types of publication, like <code>Book</code> and <code>BlogPost</code>:</p> <pre><code>class Book extends Publication {\nconstructor(bookDetails) {\nsuper(\nbookDetails.title,\nbookDetails.author,\nbookDetails.publishedOn\n);\nthis.publisher = bookDetails.publisher;\nthis.ISBN = bookDetails.ISBN;\n}\nprint() {\nsuper.print();\nconsole.log(`\n            Publisher: ${ this.publisher }\n            ISBN: ${ this.ISBN }\n        `);\n}\n}\nclass BlogPost extends Publication {\nconstructor(title,author,pubDate,URL) {\nsuper(title,author,pubDate);\nthis.URL = URL;\n}\nprint() {\nsuper.print();\nconsole.log(this.URL);\n}\n}\n</code></pre> <p>Both <code>Book</code> and <code>BlogPost</code> use the <code>extends</code> clause to extend the general definition of <code>Publication</code> to include additional behavior. The <code>super(..)</code> call in each constructor delegates to the parent <code>Publication</code> class's constructor for its initialization work, and then they do more specific things according to their respective publication type (aka, \"sub-class\" or \"child class\").</p> <p>Now consider using these child classes:</p> <pre><code>var YDKJS = new Book({\ntitle: \"You Don't Know JS\",\nauthor: \"Kyle Simpson\",\npublishedOn: \"June 2014\",\npublisher: \"O'Reilly\",\nISBN: \"123456-789\"\n});\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\nvar forAgainstLet = new BlogPost(\n\"For and against let\",\n\"Kyle Simpson\",\n\"October 27, 2014\",\n\"https://davidwalsh.name/for-and-against-let\"\n);\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let\n</code></pre> <p>Notice that both child class instances have a <code>print()</code> method, which was an override of the inherited <code>print()</code> method from the parent <code>Publication</code> class. Each of those overridden child class <code>print()</code> methods call <code>super.print()</code> to invoke the inherited version of the <code>print()</code> method.</p> <p>The fact that both the inherited and overridden methods can have the same name and co-exist is called polymorphism.</p> <p>Inheritance is a powerful tool for organizing data/behavior in separate logical units (classes), but allowing the child class to cooperate with the parent by accessing/using its behavior and data.</p>"},{"location":"get-started/ch2/#modules","title":"Modules","text":"<p>The module pattern has essentially the same goal as the class pattern, which is to group data and behavior together into logical units. Also like classes, modules can \"include\" or \"access\" the data and behaviors of other modules, for cooperation's sake.</p> <p>But modules have some important differences from classes. Most notably, the syntax is entirely different.</p>"},{"location":"get-started/ch2/#classic-modules","title":"Classic Modules","text":"<p>ES6 added a module syntax form to native JS syntax, which we'll look at in a moment. But from the early days of JS, modules was an important and common pattern that was leveraged in countless JS programs, even without a dedicated syntax.</p> <p>The key hallmarks of a classic module are an outer function (that runs at least once), which returns an \"instance\" of the module with one or more functions exposed that can operate on the module instance's internal (hidden) data.</p> <p>Because a module of this form is just a function, and calling it produces an \"instance\" of the module, another description for these functions is \"module factories\".</p> <p>Consider the classic module form of the earlier <code>Publication</code>, <code>Book</code>, and <code>BlogPost</code> classes:</p> <pre><code>function Publication(title,author,pubDate) {\nvar publicAPI = {\nprint() {\nconsole.log(`\n                Title: ${ title }\n                By: ${ author }\n${ pubDate }\n            `);\n}\n};\nreturn publicAPI;\n}\nfunction Book(bookDetails) {\nvar pub = Publication(\nbookDetails.title,\nbookDetails.author,\nbookDetails.publishedOn\n);\nvar publicAPI = {\nprint() {\npub.print();\nconsole.log(`\n                Publisher: ${ bookDetails.publisher }\n                ISBN: ${ bookDetails.ISBN }\n            `);\n}\n};\nreturn publicAPI;\n}\nfunction BlogPost(title,author,pubDate,URL) {\nvar pub = Publication(title,author,pubDate);\nvar publicAPI = {\nprint() {\npub.print();\nconsole.log(URL);\n}\n};\nreturn publicAPI;\n}\n</code></pre> <p>Comparing these forms to the <code>class</code> forms, there are more similarities than differences.</p> <p>The <code>class</code> form stores methods and data on an object instance, which must be accessed with the <code>this.</code> prefix. With modules, the methods and data are accessed as identifier variables in scope, without any <code>this.</code> prefix.</p> <p>With <code>class</code>, the \"API\" of an instance is implicit in the class definition\u2014also, all data and methods are public. With the module factory function, you explicitly create and return an object with any publicly exposed methods, and any data or other unreferenced methods remain private inside the factory function.</p> <p>There are other variations to this factory function form that are quite common across JS, even in 2020; you may run across these forms in different JS programs: AMD (Asynchronous Module Definition), UMD (Universal Module Definition), and CommonJS (classic Node.js-style modules). The variations are minor (not quite compatible). However, all of these forms rely on the same basic principles.</p> <p>Consider also the usage (aka, \"instantiation\") of these module factory functions:</p> <pre><code>var YDKJS = Book({\ntitle: \"You Don't Know JS\",\nauthor: \"Kyle Simpson\",\npublishedOn: \"June 2014\",\npublisher: \"O'Reilly\",\nISBN: \"123456-789\"\n});\nYDKJS.print();\n// Title: You Don't Know JS\n// By: Kyle Simpson\n// June 2014\n// Publisher: O'Reilly\n// ISBN: 123456-789\nvar forAgainstLet = BlogPost(\n\"For and against let\",\n\"Kyle Simpson\",\n\"October 27, 2014\",\n\"https://davidwalsh.name/for-and-against-let\"\n);\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let\n</code></pre> <p>The only observable difference here is the lack of using <code>new</code>, calling the module factories as normal functions.</p>"},{"location":"get-started/ch2/#es-modules","title":"ES Modules","text":"<p>ES modules (ESM), introduced to the JS language in ES6, are meant to serve much the same spirit and purpose as the existing classic modules just described, especially taking into account important variations and use cases from AMD, UMD, and CommonJS.</p> <p>The implementation approach does, however, differ significantly.</p> <p>First, there's no wrapping function to define a module. The wrapping context is a file. ESMs are always file-based; one file, one module.</p> <p>Second, you don't interact with a module's \"API\" explicitly, but rather use the <code>export</code> keyword to add a variable or method to its public API definition. If something is defined in a module but not <code>export</code>ed, then it stays hidden (just as with classic modules).</p> <p>Third, and maybe most noticeably different from previously discussed patterns, you don't \"instantiate\" an ES module, you just <code>import</code> it to use its single instance. ESMs are, in effect, \"singletons,\" in that there's only one instance ever created, at first <code>import</code> in your program, and all other <code>import</code>s just receive a reference to that same single instance. If your module needs to support multiple instantiations, you have to provide a classic module-style factory function on your ESM definition for that purpose.</p> <p>In our running example, we do assume multiple-instantiation, so these following snippets will mix both ESM and classic modules.</p> <p>Consider the file <code>publication.js</code>:</p> <pre><code>function printDetails(title,author,pubDate) {\nconsole.log(`\n        Title: ${ title }\n        By: ${ author }\n${ pubDate }\n    `);\n}\nexport function create(title,author,pubDate) {\nvar publicAPI = {\nprint() {\nprintDetails(title,author,pubDate);\n}\n};\nreturn publicAPI;\n}\n</code></pre> <p>To import and use this module, from another ES module like <code>blogpost.js</code>:</p> <pre><code>import { create as createPub } from \"publication.js\";\nfunction printDetails(pub,URL) {\npub.print();\nconsole.log(URL);\n}\nexport function create(title,author,pubDate,URL) {\nvar pub = createPub(title,author,pubDate);\nvar publicAPI = {\nprint() {\nprintDetails(pub,URL);\n}\n};\nreturn publicAPI;\n}\n</code></pre> <p>And finally, to use this module, we import into another ES module like <code>main.js</code>:</p> <pre><code>import { create as newBlogPost } from \"blogpost.js\";\nvar forAgainstLet = newBlogPost(\n\"For and against let\",\n\"Kyle Simpson\",\n\"October 27, 2014\",\n\"https://davidwalsh.name/for-and-against-let\"\n);\nforAgainstLet.print();\n// Title: For and against let\n// By: Kyle Simpson\n// October 27, 2014\n// https://davidwalsh.name/for-and-against-let\n</code></pre> NOTE: The <code>as newBlogPost</code> clause in the <code>import</code> statement is optional; if omitted, a top-level function just named <code>create(..)</code> would be imported. In this case, I'm renaming it for readability's sake; its more generic factory name of <code>create(..)</code> becomes more semantically descriptive of its purpose as <code>newBlogPost(..)</code>. <p>As shown, ES modules can use classic modules internally if they need to support multiple-instantiation. Alternatively, we could have exposed a <code>class</code> from our module instead of a <code>create(..)</code> factory function, with generally the same outcome. However, since you're already using ESM at that point, I'd recommend sticking with classic modules instead of <code>class</code>.</p> <p>If your module only needs a single instance, you can skip the extra layers of complexity: <code>export</code> its public methods directly.</p>"},{"location":"get-started/ch2/#the-rabbit-hole-deepens","title":"The Rabbit Hole Deepens","text":"<p>As promised at the top of this chapter, we just glanced over a wide surface area of the main parts of the JS language. Your head may still be spinning, but that's entirely natural after such a firehose of information!</p> <p>Even with just this \"brief\" survey of JS, we covered or hinted at a ton of details you should carefully consider and ensure you are comfortable with. I'm serious when I suggest: re-read this chapter, maybe several times.</p> <p>In the next chapter, we're going to dig much deeper into some important aspects of how JS works at its core. But before you follow that rabbit hole deeper, make sure you've taken adequate time to fully digest what we've just covered here.</p>"},{"location":"get-started/ch3/","title":"Chapter 3: Digging to the Roots of JS","text":"<p>If you've read Chapters 1 and 2, and taken the time to digest and percolate, you're hopefully starting to get JS a little more. If you skipped/skimmed them (especially Chapter 2), I recommend going back to spend some more time with that material.</p> <p>In Chapter 2, we surveyed syntax, patterns, and behaviors at a high level. In this chapter, our attention shifts to some of the lower-level root characteristics of JS that underpin virtually every line of code we write.</p> <p>Be aware: this chapter digs much deeper than you're likely used to thinking about a programming language. My goal is to help you appreciate the core of how JS works, what makes it tick. This chapter should begin to answer some of the \"Why?\" questions that may be cropping up as you explore JS. However, this material is still not an exhaustive exposition of the language; that's what the rest of the book series is for! Our goal here is still just to get started, and become more comfortable with, the feel of JS, how it ebbs and flows.</p> <p>Don't run so quickly through this material that you get lost in the weeds. As I've said a dozen times already, take your time. Even still, you'll probably finish this chapter with remaining questions. That's OK, because there's a whole book series ahead of you to keep exploring!</p>"},{"location":"get-started/ch3/#iteration","title":"Iteration","text":"<p>Since programs are essentially built to process data (and make decisions on that data), the patterns used to step through the data have a big impact on the program's readability.</p> <p>The iterator pattern has been around for decades, and suggests a \"standardized\" approach to consuming data from a source one chunk at a time. The idea is that it's more common and helpful to iterate the data source\u2014to progressively handle the collection of data by processing the first part, then the next, and so on, rather than handling the entire set all at once.</p> <p>Imagine a data structure that represents a relational database <code>SELECT</code> query, which typically organizes the results as rows. If this query had only one or a couple of rows, you could handle the entire result set at once, and assign each row to a local variable, and perform whatever operations on that data that were appropriate.</p> <p>But if the query has 100 or 1,000 (or more!) rows, you'll need iterative processing to deal with this data (typically, a loop).</p> <p>The iterator pattern defines a data structure called an \"iterator\" that has a reference to an underlying data source (like the query result rows), which exposes a method like <code>next()</code>. Calling <code>next()</code> returns the next piece of data (i.e., a \"record\" or \"row\" from a database query).</p> <p>You don't always know how many pieces of data that you will need to iterate through, so the pattern typically indicates completion by some special value or exception once you iterate through the entire set and go past the end.</p> <p>The importance of the iterator pattern is in adhering to a standard way of processing data iteratively, which creates cleaner and easier to understand code, as opposed to having every data structure/source define its own custom way of handling its data.</p> <p>After many years of various JS community efforts around mutually agreed-upon iteration techniques, ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a <code>next()</code> method whose return is an object called an iterator result; the object has <code>value</code> and <code>done</code> properties, where <code>done</code> is a boolean that is <code>false</code> until the iteration over the underlying data source is complete.</p>"},{"location":"get-started/ch3/#consuming-iterators","title":"Consuming Iterators","text":"<p>With the ES6 iteration protocol in place, it's workable to consume a data source one value at a time, checking after each <code>next()</code> call for <code>done</code> to be <code>true</code> to stop the iteration. But this approach is rather manual, so ES6 also included several mechanisms (syntax and APIs) for standardized consumption of these iterators.</p> <p>One such mechanism is the <code>for..of</code> loop:</p> <pre><code>// given an iterator of some data source:\nvar it = /* .. */;\n// loop over its results one at a time\nfor (let val of it) {\nconsole.log(`Iterator value: ${ val }`);\n}\n// Iterator value: ..\n// Iterator value: ..\n// ..\n</code></pre> NOTE: We'll omit the manual loop equivalent here, but it's definitely less readable than the <code>for..of</code> loop! <p>Another mechanism that's often used for consuming iterators is the <code>...</code> operator. This operator actually has two symmetrical forms: spread and rest (or gather, as I prefer). The spread form is an iterator-consumer.</p> <p>To spread an iterator, you have to have something to spread it into. There are two possibilities in JS: an array or an argument list for a function call.</p> <p>An array spread:</p> <pre><code>// spread an iterator into an array,\n// with each iterated value occupying\n// an array element position.\nvar vals = [ ...it ];\n</code></pre> <p>A function call spread:</p> <pre><code>// spread an iterator into a function,\n// call with each iterated value\n// occupying an argument position.\ndoSomethingUseful( ...it );\n</code></pre> <p>In both cases, the iterator-spread form of <code>...</code> follows the iterator-consumption protocol (the same as the <code>for..of</code> loop) to retrieve all available values from an iterator and place (aka, spread) them into the receiving context (array, argument list).</p>"},{"location":"get-started/ch3/#iterables","title":"Iterables","text":"<p>The iterator-consumption protocol is technically defined for consuming iterables; an iterable is a value that can be iterated over.</p> <p>The protocol automatically creates an iterator instance from an iterable, and consumes just that iterator instance to its completion. This means a single iterable could be consumed more than once; each time, a new iterator instance would be created and used.</p> <p>So where do we find iterables?</p> <p>ES6 defined the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.</p> <p>Consider:</p> <pre><code>// an array is an iterable\nvar arr = [ 10, 20, 30 ];\nfor (let val of arr) {\nconsole.log(`Array value: ${ val }`);\n}\n// Array value: 10\n// Array value: 20\n// Array value: 30\n</code></pre> <p>Since arrays are iterables, we can shallow-copy an array using iterator consumption via the <code>...</code> spread operator:</p> <pre><code>var arrCopy = [ ...arr ];\n</code></pre> <p>We can also iterate the characters in a string one at a time:</p> <pre><code>var greeting = \"Hello world!\";\nvar chars = [ ...greeting ];\nchars;\n// [ \"H\", \"e\", \"l\", \"l\", \"o\", \" \",\n//   \"w\", \"o\", \"r\", \"l\", \"d\", \"!\" ]\n</code></pre> <p>A <code>Map</code> data structure uses objects as keys, associating a value (of any type) with that object. Maps have a different default iteration than seen here, in that the iteration is not just over the map's values but instead its entries. An entry is a tuple (2-element array) including both a key and a value.</p> <p>Consider:</p> <pre><code>// given two DOM elements, `btn1` and `btn2`\nvar buttonNames = new Map();\nbuttonNames.set(btn1,\"Button 1\");\nbuttonNames.set(btn2,\"Button 2\");\nfor (let [btn,btnName] of buttonNames) {\nbtn.addEventListener(\"click\",function onClick(){\nconsole.log(`Clicked ${ btnName }`);\n});\n}\n</code></pre> <p>In the <code>for..of</code> loop over the default map iteration, we use the <code>[btn,btnName]</code> syntax (called \"array destructuring\") to break down each consumed tuple into the respective key/value pairs (<code>btn1</code> / <code>\"Button 1\"</code> and <code>btn2</code> / <code>\"Button 2\"</code>).</p> <p>Each of the built-in iterables in JS expose a default iteration, one which likely matches your intuition. But you can also choose a more specific iteration if necessary. For example, if we want to consume only the values of the above <code>buttonNames</code> map, we can call <code>values()</code> to get a values-only iterator:</p> <pre><code>for (let btnName of buttonNames.values()) {\nconsole.log(btnName);\n}\n// Button 1\n// Button 2\n</code></pre> <p>Or if we want the index and value in an array iteration, we can make an entries iterator with the <code>entries()</code> method:</p> <pre><code>var arr = [ 10, 20, 30 ];\nfor (let [idx,val] of arr.entries()) {\nconsole.log(`[${ idx }]: ${ val }`);\n}\n// [0]: 10\n// [1]: 20\n// [2]: 30\n</code></pre> <p>For the most part, all built-in iterables in JS have three iterator forms available: keys-only (<code>keys()</code>), values-only (<code>values()</code>), and entries (<code>entries()</code>).</p> <p>Beyond just using built-in iterables, you can also ensure your own data structures adhere to the iteration protocol; doing so means you opt into the ability to consume your data with <code>for..of</code> loops and the <code>...</code> operator. \"Standardizing\" on this protocol means code that is overall more readily recognizable and readable.</p> NOTE: You may have noticed a nuanced shift that occurred in this discussion. We started by talking about consuming iterators, but then switched to talking about iterating over iterables. The iteration-consumption protocol expects an iterable, but the reason we can provide a direct iterator is that an iterator is just an iterable of itself! When creating an iterator instance from an existing iterator, the iterator itself is returned."},{"location":"get-started/ch3/#closure","title":"Closure","text":"<p>Perhaps without realizing it, almost every JS developer has made use of closure. In fact, closure is one of the most pervasive programming functionalities across a majority of languages. It might even be as important to understand as variables or loops; that's how fundamental it is.</p> <p>Yet it feels kind of hidden, almost magical. And it's often talked about in either very abstract or very informal terms, which does little to help us nail down exactly what it is.</p> <p>We need to be able to recognize where closure is used in programs, as the presence or lack of closure is sometimes the cause of bugs (or even the cause of performance issues).</p> <p>So let's define closure in a pragmatic and concrete way:</p> <p>Closure is when a function remembers and continues to access variables from outside its scope, even when the function is executed in a different scope.</p> <p>We see two definitional characteristics here. First, closure is part of the nature of a function. Objects don't get closures, functions do. Second, to observe a closure, you must execute a function in a different scope than where that function was originally defined.</p> <p>Consider:</p> <pre><code>function greeting(msg) {\nreturn function who(name) {\nconsole.log(`${ msg }, ${ name }!`);\n};\n}\nvar hello = greeting(\"Hello\");\nvar howdy = greeting(\"Howdy\");\nhello(\"Kyle\");\n// Hello, Kyle!\nhello(\"Sarah\");\n// Hello, Sarah!\nhowdy(\"Grant\");\n// Howdy, Grant!\n</code></pre> <p>First, the <code>greeting(..)</code> outer function is executed, creating an instance of the inner function <code>who(..)</code>; that function closes over the variable <code>msg</code>, which is the parameter from the outer scope of <code>greeting(..)</code>. When that inner function is returned, its reference is assigned to the <code>hello</code> variable in the outer scope. Then we call <code>greeting(..)</code> a second time, creating a new inner function instance, with a new closure over a new <code>msg</code>, and return that reference to be assigned to <code>howdy</code>.</p> <p>When the <code>greeting(..)</code> function finishes running, normally we would expect all of its variables to be garbage collected (removed from memory). We'd expect each <code>msg</code> to go away, but they don't. The reason is closure. Since the inner function instances are still alive (assigned to <code>hello</code> and <code>howdy</code>, respectively), their closures are still preserving the <code>msg</code> variables.</p> <p>These closures are not a snapshot of the <code>msg</code> variable's value; they are a direct link and preservation of the variable itself. That means closure can actually observe (or make!) updates to these variables over time.</p> <pre><code>function counter(step = 1) {\nvar count = 0;\nreturn function increaseCount(){\ncount = count + step;\nreturn count;\n};\n}\nvar incBy1 = counter(1);\nvar incBy3 = counter(3);\nincBy1();       // 1\nincBy1();       // 2\nincBy3();       // 3\nincBy3();       // 6\nincBy3();       // 9\n</code></pre> <p>Each instance of the inner <code>increaseCount()</code> function is closed over both the <code>count</code> and <code>step</code> variables from its outer <code>counter(..)</code> function's scope. <code>step</code> remains the same over time, but <code>count</code> is updated on each invocation of that inner function. Since closure is over the variables and not just snapshots of the values, these updates are preserved.</p> <p>Closure is most common when working with asynchronous code, such as with callbacks. Consider:</p> <pre><code>function getSomeData(url) {\najax(url,function onResponse(resp){\nconsole.log(\n`Response (from ${ url }): ${ resp }`\n);\n});\n}\ngetSomeData(\"https://some.url/wherever\");\n// Response (from https://some.url/wherever): ...\n</code></pre> <p>The inner function <code>onResponse(..)</code> is closed over <code>url</code>, and thus preserves and remembers it until the Ajax call returns and executes <code>onResponse(..)</code>. Even though <code>getSomeData(..)</code> finishes right away, the <code>url</code> parameter variable is kept alive in the closure for as long as needed.</p> <p>It's not necessary that the outer scope be a function\u2014it usually is, but not always\u2014just that there be at least one variable in an outer scope accessed from an inner function:</p> <pre><code>for (let [idx,btn] of buttons.entries()) {\nbtn.addEventListener(\"click\",function onClick(){\nconsole.log(`Clicked on button (${ idx })!`);\n});\n}\n</code></pre> <p>Because this loop is using <code>let</code> declarations, each iteration gets new block-scoped (aka, local) <code>idx</code> and <code>btn</code> variables;  the loop also creates a new inner <code>onClick(..)</code> function each time. That inner function closes over <code>idx</code>, preserving it for as long as the click handler is set on the <code>btn</code>. So when each button is clicked, its handler can print its associated index value, because the handler remembers its respective <code>idx</code> variable.</p> <p>Remember: this closure is not over the value (like <code>1</code> or <code>3</code>), but over the variable <code>idx</code> itself.</p> <p>Closure is one of the most prevalent and important programming patterns in any language. But that's especially true of JS; it's hard to imagine doing anything useful without leveraging closure in one way or another.</p> <p>If you're still feeling unclear or shaky about closure, the majority of Book 2, Scope &amp; Closures is focused on the topic.</p>"},{"location":"get-started/ch3/#this-keyword","title":"<code>this</code> Keyword","text":"<p>One of JS's most powerful mechanisms is also one of its most misunderstood: the <code>this</code> keyword. One common misconception is that a function's <code>this</code> refers to the function itself. Because of how <code>this</code> works in other languages, another misconception is that <code>this</code> points the instance that a method belongs to. Both are incorrect.</p> <p>As discussed previously, when a function is defined, it is attached to its enclosing scope via closure. Scope is the set of rules that controls how references to variables are resolved.</p> <p>But functions also have another characteristic besides their scope that influences what they can access. This characteristic is best described as an execution context, and it's exposed to the function via its <code>this</code> keyword.</p> <p>Scope is static and contains a fixed set of variables available at the moment and location you define a function, but a function's execution context is dynamic, entirely dependent on how it is called (regardless of where it is defined or even called from).</p> <p><code>this</code> is not a fixed characteristic of a function based on the function's definition, but rather a dynamic characteristic that's determined each time the function is called.</p> <p>One way to think about the execution context is that it's a tangible object whose properties are made available to a function while it executes. Compare that to scope, which can also be thought of as an object; except, the scope object is hidden inside the JS engine, it's always the same for that function, and its properties take the form of identifier variables available inside the function.</p> <pre><code>function classroom(teacher) {\nreturn function study() {\nconsole.log(\n`${ teacher } says to study ${ this.topic }`\n);\n};\n}\nvar assignment = classroom(\"Kyle\");\n</code></pre> <p>The outer <code>classroom(..)</code> function makes no reference to a <code>this</code> keyword, so it's just like any other function we've seen so far. But the inner <code>study()</code> function does reference <code>this</code>, which makes it a <code>this</code>-aware function. In other words, it's a function that is dependent on its execution context.</p> NOTE: <code>study()</code> is also closed over the <code>teacher</code> variable from its outer scope. <p>The inner <code>study()</code> function returned by <code>classroom(\"Kyle\")</code> is assigned to a variable called <code>assignment</code>. So how can <code>assignment()</code> (aka <code>study()</code>) be called?</p> <pre><code>assignment();\n// Kyle says to study undefined  -- Oops :(\n</code></pre> <p>In this snippet, we call <code>assignment()</code> as a plain, normal function, without providing it any execution context.</p> <p>Since this program is not in strict mode (see Chapter 1, \"Strictly Speaking\"), context-aware functions that are called without any context specified default the context to the global object (<code>window</code> in the browser). As there is no global variable named <code>topic</code> (and thus no such property on the global object), <code>this.topic</code> resolves to <code>undefined</code>.</p> <p>Now consider:</p> <pre><code>var homework = {\ntopic: \"JS\",\nassignment: assignment\n};\nhomework.assignment();\n// Kyle says to study JS\n</code></pre> <p>A copy of the <code>assignment</code> function reference is set as a property on the <code>homework</code> object, and then it's called as <code>homework.assignment()</code>. That means the <code>this</code> for that function call will be the <code>homework</code> object. Hence, <code>this.topic</code> resolves to <code>\"JS\"</code>.</p> <p>Lastly:</p> <pre><code>var otherHomework = {\ntopic: \"Math\"\n};\nassignment.call(otherHomework);\n// Kyle says to study Math\n</code></pre> <p>A third way to invoke a function is with the <code>call(..)</code> method, which takes an object (<code>otherHomework</code> here) to use for setting the <code>this</code> reference for the function call. The property reference <code>this.topic</code> resolves to <code>\"Math\"</code>.</p> <p>The same context-aware function invoked three different ways, gives different answers each time for what object <code>this</code> will reference.</p> <p>The benefit of <code>this</code>-aware functions\u2014and their dynamic context\u2014is the ability to more flexibly re-use a single function with data from different objects. A function that closes over a scope can never reference a different scope or set of variables. But a function that has dynamic <code>this</code> context awareness can be quite helpful for certain tasks.</p>"},{"location":"get-started/ch3/#prototypes","title":"Prototypes","text":"<p>Where <code>this</code> is a characteristic of function execution, a prototype is a characteristic of an object, and specifically resolution of a property access.</p> <p>Think about a prototype as a linkage between two objects; the linkage is hidden behind the scenes, though there are ways to expose and observe it. This prototype linkage occurs when an object is created; it's linked to another object that already exists.</p> <p>A series of objects linked together via prototypes is called the \"prototype chain.\"</p> <p>The purpose of this prototype linkage (i.e., from an object B to another object A) is so that accesses against B for properties/methods that B does not have, are delegated to A to handle. Delegation of property/method access allows two (or more!) objects to cooperate with each other to perform a task.</p> <p>Consider defining an object as a normal literal:</p> <pre><code>var homework = {\ntopic: \"JS\"\n};\n</code></pre> <p>The <code>homework</code> object only has a single property on it: <code>topic</code>. However, its default prototype linkage connects to the <code>Object.prototype</code> object, which has common built-in methods on it like <code>toString()</code> and <code>valueOf()</code>, among others.</p> <p>We can observe this prototype linkage delegation from <code>homework</code> to <code>Object.prototype</code>:</p> <pre><code>homework.toString();    // [object Object]\n</code></pre> <p><code>homework.toString()</code> works even though <code>homework</code> doesn't have a <code>toString()</code> method defined; the delegation invokes <code>Object.prototype.toString()</code> instead.</p>"},{"location":"get-started/ch3/#object-linkage","title":"Object Linkage","text":"<p>To define an object prototype linkage, you can create the object using the <code>Object.create(..)</code> utility:</p> <pre><code>var homework = {\ntopic: \"JS\"\n};\nvar otherHomework = Object.create(homework);\notherHomework.topic;   // \"JS\"\n</code></pre> <p>The first argument to <code>Object.create(..)</code> specifies an object to link the newly created object to, and then returns the newly created (and linked!) object.</p> <p>Figure 4 shows how the three objects (<code>otherHomework</code>, <code>homework</code>, and <code>Object.prototype</code>) are linked in a prototype chain:</p> Fig. 4: Objects in a prototype chain <p>Delegation through the prototype chain only applies for accesses to lookup the value in a property. If you assign to a property of an object, that will apply directly to the object regardless of where that object is prototype linked to.</p> TIP: <code>Object.create(null)</code> creates an object that is not prototype linked anywhere, so it's purely just a standalone object; in some circumstances, that may be preferable. <p>Consider:</p> <pre><code>homework.topic;\n// \"JS\"\notherHomework.topic;\n// \"JS\"\notherHomework.topic = \"Math\";\notherHomework.topic;\n// \"Math\"\nhomework.topic;\n// \"JS\" -- not \"Math\"\n</code></pre> <p>The assignment to <code>topic</code> creates a property of that name directly on <code>otherHomework</code>; there's no effect on the <code>topic</code> property on <code>homework</code>. The next statement then accesses <code>otherHomework.topic</code>, and we see the non-delegated answer from that new property: <code>\"Math\"</code>.</p> <p>Figure 5 shows the objects/properties after the assignment that creates the <code>otherHomework.topic</code> property:</p> Fig. 5: Shadowed property 'topic' <p>The <code>topic</code> on <code>otherHomework</code> is \"shadowing\" the property of the same name on the <code>homework</code> object in the chain.</p> NOTE: Another frankly more convoluted but perhaps still more common way of creating an object with a prototype linkage is using the \"prototypal class\" pattern, from before <code>class</code> (see Chapter 2, \"Classes\") was added in ES6. We'll cover this topic in more detail in Appendix A, \"Prototypal 'Classes'\"."},{"location":"get-started/ch3/#this-revisited","title":"<code>this</code> Revisited","text":"<p>We covered the <code>this</code> keyword earlier, but its true importance shines when considering how it powers prototype-delegated function calls. Indeed, one of the main reasons <code>this</code> supports dynamic context based on how the function is called is so that method calls on objects which delegate through the prototype chain still maintain the expected <code>this</code>.</p> <p>Consider:</p> <pre><code>var homework = {\nstudy() {\nconsole.log(`Please study ${ this.topic }`);\n}\n};\nvar jsHomework = Object.create(homework);\njsHomework.topic = \"JS\";\njsHomework.study();\n// Please study JS\nvar mathHomework = Object.create(homework);\nmathHomework.topic = \"Math\";\nmathHomework.study();\n// Please study Math\n</code></pre> <p>The two objects <code>jsHomework</code> and <code>mathHomework</code> each prototype link to the single <code>homework</code> object, which has the <code>study()</code> function. <code>jsHomework</code> and <code>mathHomework</code> are each given their own <code>topic</code> property (see Figure 6).</p> Fig. 6: Two objects linked to a common parent <p><code>jsHomework.study()</code> delegates to <code>homework.study()</code>, but its <code>this</code> (<code>this.topic</code>) for that execution resolves to <code>jsHomework</code> because of how the function is called, so <code>this.topic</code> is <code>\"JS\"</code>. Similarly for <code>mathHomework.study()</code> delegating to <code>homework.study()</code> but still resolving <code>this</code> to <code>mathHomework</code>, and thus <code>this.topic</code> as <code>\"Math\"</code>.</p> <p>The preceding code snippet would be far less useful if <code>this</code> was resolved to <code>homework</code>. Yet, in many other languages, it would seem <code>this</code> would be <code>homework</code> because the <code>study()</code> method is indeed defined on <code>homework</code>.</p> <p>Unlike many other languages, JS's <code>this</code> being dynamic is a critical component of allowing prototype delegation, and indeed <code>class</code>, to work as expected!</p>"},{"location":"get-started/ch3/#asking-why","title":"Asking \"Why?\"","text":"<p>The intended take-away from this chapter is that there's a lot more to JS under the hood than is obvious from glancing at the surface.</p> <p>As you are getting started learning and knowing JS more closely, one of the most important skills you can practice and bolster is curiosity, and the art of asking \"Why?\" when you encounter something in the language.</p> <p>Even though this chapter has gone quite deep on some of the topics, many details have still been entirely skimmed over. There's much more to learn here, and the path to that starts with you asking the right questions of your code. Asking the right questions is a critical skill of becoming a better developer.</p> <p>In the final chapter of this book, we're going to briefly look at how JS is divided, as covered across the rest of the You Don't Know JS Yet book series. Also, don't skip Appendix B of this book, which has some practice code to review some of the main topics covered in this book.</p>"},{"location":"get-started/ch4/","title":"Chapter 4: The Bigger Picture","text":"<p>This book surveys what you need to be aware of as you get started with JS. The goal is to fill in gaps that readers newer to JS might have tripped over in their early encounters with the language. I also hope that we've hinted at enough deeper detail throughout to pique your curiosity to want to dig more into the language.</p> <p>The rest of the books in this series are where we will unpack all of the rest of the language, in far greater detail than we could have done in a few brief chapters here.</p> <p>Remember to take your time, though. Rather than rushing onto the next book in an attempt to churn through all the books expediently, spend some time going back over the material in this book. Spend some more time looking through code in your current projects, and comparing what you see to what's been discussed so far.</p> <p>When you're ready, this final chapter divides the organization of the JS language into three main pillars, then offers a brief roadmap of what to expect from the rest of the book series, and how I suggest you proceed. Also, don't skip the appendices, especially Appendix B, \"Practice, Practice, Practice!\".</p>"},{"location":"get-started/ch4/#pillar-1-scope-and-closure","title":"Pillar 1: Scope and Closure","text":"<p>The organization of variables into units of scope (functions, blocks) is one of the most foundational characteristics of any language; perhaps no other characteristic has a greater impact on how programs behave.</p> <p>Scopes are like buckets, and variables are like marbles you put into those buckets. The scope model of a language is like the rules that help you determine which color marbles go in which matching-color buckets.</p> <p>Scopes nest inside each other, and for any given expression or statement, only variables at that level of scope nesting, or in higher/outer scopes, are accessible; variables from lower/inner scopes are hidden and inaccessible.</p> <p>This is how scopes behave in most languages, which is called LEXICAL scope. The scope unit boundaries, and how variables are organized in them, is determined at the time the program is parsed (compiled). In other words, it's an author-time decision: where you locate a function/scope in the program determines what the scope structure of that part of the program will be.</p> <p>JS is lexically scoped, though many claim it isn't, because of two particular characteristics of its model that are not present in other lexically scoped languages.</p> <p>The first is commonly called hoisting: when all variables declared anywhere in a scope are treated as if they're declared at the beginning of the scope. The other is that <code>var</code>-declared variables are function scoped, even if they appear inside a block.</p> <p>Neither hoisting nor function-scoped <code>var</code> are sufficient to back the claim that JS is not lexically scoped. <code>let</code>/<code>const</code> declarations have a peculiar error behavior called the \"Temporal Dead Zone\" (TDZ) which results in observable but unusable variables. Though TDZ can be strange to encounter, it's also not an invalidation of LEXICAL scoping. All of these are just unique parts of the language that should be learned and understood by all JS developers.</p> <p>Closure is a natural result of LEXICAL scope when the language has functions as first-class values, as JS does. When a function makes reference to variables from an outer scope, and that function is passed around as a value and executed in other scopes, it maintains access to its original scope variables; this is closure.</p> <p>Across all of programming, but especially in JS, closure drives many of the most important programming patterns, including modules. As I see it, modules are as with the grain as you can get, when it comes to code organization in JS.</p> <p>To dig further into scope, closures, and how modules work, read Book 2, Scope &amp; Closures.</p>"},{"location":"get-started/ch4/#pillar-2-prototypes","title":"Pillar 2: Prototypes","text":"<p>The second pillar of the language is the prototypes system. We covered this topic in-depth in Chapter 3 (\"Prototypes\"), but I just want to make a few more comments about its importance.</p> <p>JS is one of very few languages where you have the option to create objects directly and explicitly, without first defining their structure in a class.</p> <p>For many years, people implemented the class design pattern on top of prototypes\u2014so-called \"prototypal inheritance\" (see Appendix A, \"Prototypal 'Classes'\")\u2014and then with the advent of ES6's <code>class</code> keyword, the language doubled-down on its inclination toward OO/class-style programming.</p> <p>But I think that focus has obscured the beauty and power of the prototype system: the ability for two objects to simply connect with each other and cooperate dynamically (during function/method execution) through sharing a <code>this</code> context.</p> <p>Classes are just one pattern you can build on top of such power. But another approach, in a very different direction, is to simply embrace objects as objects, forget classes altogether, and let objects cooperate through the prototype chain. This is called behavior delegation. I think delegation is more powerful than class inheritance, as a means for organizing behavior and data in our programs.</p> <p>But class inheritance gets almost all the attention. And the rest goes to functional programming (FP), as the sort of \"anti-class\" way of designing programs. This saddens me, because it snuffs out any chance for exploration of delegation as a viable alternative.</p> <p>I encourage you to spend plenty of time deep in Book 3, Objects &amp; Classes, to see how object delegation holds far more potential than we've perhaps realized. This isn't an anti-<code>class</code> message, but it is intentionally a \"classes aren't the only way to use objects\" message that I want more JS developers to consider.</p> <p>Object delegation is, I would argue, far more with the grain of JS, than classes (more on grains in a bit).</p>"},{"location":"get-started/ch4/#pillar-3-types-and-coercion","title":"Pillar 3: Types and Coercion","text":"<p>The third pillar of JS is by far the most overlooked part of JS's nature.</p> <p>The vast majority of developers have strong misconceptions about how types work in programming languages, and especially how they work in JS. A tidal wave of interest in the broader JS community has begun to shift to \"static typing\" approaches, using type-aware tooling like TypeScript or Flow.</p> <p>I agree that JS developers should learn more about types, and should learn more about how JS manages type conversions. I also agree that type-aware tooling can help developers, assuming they have gained and used this knowledge in the first place!</p> <p>But I don't agree at all that the inevitable conclusion of this is to decide JS's type mechanism is bad and that we need to cover up JS's types with solutions outside the language. We don't have to follow the \"static typing\" way to be smart and solid with types in our programs. There are other options, if you're just willing to go against the grain of the crowd, and with the grain of JS (again, more on that to come).</p> <p>Arguably, this pillar is more important than the other two, in the sense that no JS program will do anything useful if it doesn't properly leverage JS's value types, as well as the conversion (coercion) of values between types.</p> <p>Even if you love TypeScript/Flow, you are not going to get the most out of those tools or coding approaches if you aren't deeply familiar with how the language itself manages value types.</p> <p>To learn more about JS types and coercion, check out Book 4, Types &amp; Grammar. But please don't skip over this topic just because you've always heard that we should use <code>===</code> and forget about the rest.</p> <p>Without learning this pillar, your foundation in JS is shaky and incomplete at best.</p>"},{"location":"get-started/ch4/#with-the-grain","title":"With the Grain","text":"<p>I have some advice to share on continuing your learning journey with JS, and your path through the rest of this book series: be aware of the grain (recall various references to grain earlier in this chapter).</p> <p>First, consider the grain (as in, wood) of how most people approach and use JS. You've probably already noticed that these books cut against that grain in many respects. In YDKJSY, I respect you the reader enough to explain all the parts of JS, not only some select popular parts. I believe you're both capable and deserving of that knowledge.</p> <p>But that is not what you'll find from a lot of other material out there. It also means that the more you follow and adhere to the guidance from these books\u2014that you think carefully and analyze for yourself what's best in your code\u2014the more you will stand out. That can be a good and bad thing. If you ever want to break out from the crowd, you're going to have to break from how the crowd does it!</p> <p>But I've also had many people tell me that they quoted some topic/explanation from these books during a job interview, and the interviewer told the candidate they were wrong; indeed, people have reportedly lost out on job offers as a result.</p> <p>As much as possible, I endeavor in these books to provide completely accurate information about JS, informed generally from the specification itself. But I also dose out quite a bit of my opinions on how you can interpret and use JS to the best benefit in your programs. I don't present opinion as fact, or vice versa. You'll always know which is which in these books.</p> <p>Facts about JS are not really up for debate. Either the specification says something, or it doesn't. If you don't like what the specification says, or my relaying of it, take that up with TC39! If you're in an interview and they claim you're wrong on the facts, ask them right then and there if you can look it up in the specification. If the interviewer won't re-consider, then you shouldn't want to work there anyway.</p> <p>But if you choose to align with my opinions, you have to be prepared to back up those choices with why you feel that way. Don't just parrot what I say. Own your opinions. Defend them. And if someone you were hoping to work with disagrees, walk away with your head still held high. It's a big JS, and there's plenty of room for lots of different ways.</p> <p>In other words, don't be afraid to go against the grain, as I have done with these books and all my teachings. Nobody can tell you how you will best make use of JS; that's for you to decide. I'm merely trying to empower you in coming to your own conclusions, no matter what they are.</p> <p>On the other hand, there's a grain you really should pay attention to and follow: the grain of how JS works, at the language level. There are things that work well and naturally in JS, given the right practice and approach, and there are things you really shouldn't try to do in the language.</p> <p>Can you make your JS program look like a Java, C#, or Perl program? What about Python or Ruby, or even PHP? To varying degrees, sure you can. But should you?</p> <p>No, I don't think you should. I think you should learn and embrace the JS way, and make your JS programs as JS'y as is practical. Some will think that means sloppy and informal programming, but I don't mean that at all. I just mean that JS has a lot of patterns and idioms that are recognizably \"JS,\" and going with that grain is the general path to the best success.</p> <p>Finally, maybe the most important grain to recognize is how the existing program(s) you're working on, and developers you're working with, do stuff. Don't read these books and then try to change all that grain in your existing projects over night. That approach will always fail.</p> <p>You'll have to shift these things little by little, over time. Work on building consensus with your fellow developers on why it's important to re-visit and re-consider an approach. But do so with just one small topic at a time, and let before-and-after code comparisons do most of the talking. Bring everyone on the team together to discuss, and push for decisions that are based on analysis and evidence from the code rather than the inertia of \"our senior devs have always done it this way.\"</p> <p>That's the most important advice I can impart to help you learn JS. Always keep looking for better ways to use what JS gives us to author more readable code. Everyone who works on your code, including your future self, will thank you!</p>"},{"location":"get-started/ch4/#in-order","title":"In Order","text":"<p>So now you've got a broader perspective on what's left to explore in JS, and the right attitude to approach the rest of your journey.</p> <p>But one of the most common practical questions I get at this point is, \"What order should I read the books?\" There is a straightforward answer... but it also depends.</p> <p>My suggestion for most readers is to proceed through this series in this order:</p> <ol> <li> <p>Get started with a solid foundation of JS from Get Started (Book 1) -- good news, you've already almost finished this book!</p> </li> <li> <p>In Scope &amp; Closures (Book 2), dig into the first pillar of JS: LEXICAL scope, how that supports closure, and how the module pattern organizes code.</p> </li> <li> <p>In Objects &amp; Classes (Book 3), focus on the second pillar of JS: how JS's <code>this</code> works, how object prototypes support delegation, and how prototypes enable the <code>class</code> mechanism for OO-style code organization.</p> </li> <li> <p>In Types &amp; Grammar (Book 4), tackle the third and final pillar of JS: types and type coercion, as well as how JS's syntax and grammar define how we write our code.</p> </li> <li> <p>With the three pillars solidly in place, Sync &amp; Async (Book 5) then explores how we use flow control to model state change in our programs, both synchronously (right away) and asynchronously (over time).</p> </li> <li> <p>The series concludes with ES.Next &amp; Beyond (Book 6), a forward look at the near- and mid-term future of JS, including a variety of features likely coming to your JS programs before too long.</p> </li> </ol> <p>That's the intended order to read this book series.</p> <p>However, Books 2, 3, and 4 can generally be read in any order, depending on which topic you feel most curious about and comfortable exploring first. But I don't recommend you skip any of these three books\u2014not even Types &amp; Grammar, as some of you will be tempted to do!\u2014even if you think you already have that topic down.</p> <p>Book 5 (Sync &amp; Async) is crucial for deeply understanding JS, but if you start digging in and find it's too intimidating, this book can be deferred until you're more experienced with the language. The more JS you've written (and struggled with!), the more you'll come to appreciate this book. So don't be afraid to come back to it at a later time.</p> <p>The final book in the series, ES.Next &amp; Beyond, in some respects stands alone. It can be read at the end, as I suggest, or right after Getting Started if you're looking for a shortcut to broaden your radar of what JS is all about. This book will also be more likely to receive updates in the future, so you'll probably want to re-visit it occasionally.</p> <p>However you choose to proceed with YDKJSY, check out the appendices of this book first, especially practicing the snippets in Appendix B, \"Practice, Practice, Practice!\" Did I mention you should go practice!? There's no better way to learn code than to write it.</p>"},{"location":"get-started/toc/","title":"Table of Contents","text":"<ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: What Is JavaScript?</li> <li>About This Book</li> <li>What's With That Name?</li> <li>Language Specification</li> <li>Many Faces</li> <li>Backwards &amp; Forwards</li> <li>What's in an Interpretation?</li> <li>Strictly Speaking</li> <li>Defined</li> <li>Chapter 2: Surveying JS</li> <li>Each File is a Program</li> <li>Values</li> <li>Declaring and Using Variables</li> <li>Functions</li> <li>Comparisons</li> <li>How We Organize in JS</li> <li>The Rabbit Hole Deepens</li> <li>Chapter 3: Digging To The Roots Of JS</li> <li>Iteration</li> <li>Closure</li> <li><code>this</code> Keyword</li> <li>Prototypes</li> <li>Asking \"Why?\"</li> <li>Chapter 4: The Bigger Picture</li> <li>Pillar 1: Scope and Closure</li> <li>Pillar 2: Prototypes</li> <li>Pillar 3: Types and Coercion</li> <li>With the Grain</li> <li>In Order</li> <li>Appendix A: Exploring Further</li> <li>Values vs. References</li> <li>So Many Function Forms</li> <li>Coercive Conditional Comparison</li> <li>Prototypal \"Classes\"</li> <li>Appendix B: Practice, Practice, Practice!</li> <li>Practicing Comparisons</li> <li>Practicing Closure</li> <li>Practicing Prototypes</li> <li>Suggested Solutions</li> </ul>"},{"location":"objects-classes/ch1/","title":"Chapter 1: Object Foundations","text":"NOTE: Work in progress <p>Everything in JS is an object.</p> <p>This is one of the most pervasive, but most incorrect, \"facts\" that perpetually circulates about JS. Let the myth busting commence.</p> <p>JS definitely has objects, but that doesn't mean that all values are objects. Nevertheless, objects are arguably the most important (and varied!) value type in the language, so mastering them is critical to your JS journey.</p> <p>The object mechanism is certainly the most flexible and powerful container type -- something you put other values into; every JS program you write will use them in one way or another. But that's not why objects deserve top billing for this book. Objects are the foundation for the second of JS's three pillars: the prototype.</p> <p>Why are prototypes (along with the <code>this</code> keyword, covered later in the book) so core to JS as to be one of its three pillars? Among other things, prototypes are how JS's object system can express the class design pattern, one of the most widely relied on design patterns in all of programming.</p> <p>So our journey here will start with objects, build up a compelete understanding of prototypes, de-mystify the <code>this</code> keyword, and explore the <code>class</code> system.</p>"},{"location":"objects-classes/ch1/#about-this-book","title":"About This Book","text":"<p>Welcome to book 3 in the You Don't Know JS Yet series! If you already finished Get Started (the first book) and Scope &amp; Closures (the second book), you're in the right spot! If not, before you proceed I encourage you to read those two as foundations before diving into this book.</p> <p>The first edition of this book is titled, \"this &amp; Object Prototypes\". In that book, our focus started with the <code>this</code> keyword, as it's arguably one of the most confused topics in all of JS. The book then spent the majority of its time focused on expositing the prototype system and advocating for embrace of the lesser-known \"delegation\" pattern instead of class designs. At the time of that book's writing (2014), ES6 would still be almost 2 years to its completion, so I felt the early sketches of the <code>class</code> keyword only merited a brief addendum of coverage.</p> <p>It's quite an understatement to say a lot has changed in the JS landscape in the almost 8 years since that book. ES6 is old news now; at the time of this book's writing, JS has seen 7 yearly updates after ES6 (ES2016 through ES2022).</p> <p>Now, we still need to talk about how <code>this</code> works, and how that relates to methods invoked against various objects. And <code>class</code> actually operates (mostly!) via the prototype chain deep under the covers. But JS developers in 2022 are almost never writing code to explicitly wire up prototypal inheritance anymore. And as much as I personally wish differently, class design patterns -- not \"behavior delegation\" -- are how the majority of data and behavior organization (data structures) in JS are expressed.</p> <p>This book reflects JS's current reality: thus the new sub-title, new organization and focus of topics, and complete re-write of the previous edition's text.</p>"},{"location":"objects-classes/ch1/#objects-as-containers","title":"Objects As Containers","text":"<p>One common way of gathering up multiple values in a single container is with an object. Objects are collections of key/value pairs. There are also sub-types of object in JS with specialized behaviors, such as arrays (numerically indexed) and even functions (callable); more on these sub-types later.</p> NOTE: Keys are often referred to as \"property names\", with the pairing of a property name and a value often called a \"property\". This book will use those terms distinctly in that manner. <p>Regular JS objects are typically declared with literal syntax, like this:</p> <pre><code>myObj = {\n// ..\n};\n</code></pre> <p>Note: There's an alternate way to create an object (using <code>myObj = new Object()</code>), but this is not common or preferred, and is almost never the appropriate way to go about it. Stick with object literal syntax.</p> <p>It's easy to get confused what pairs of <code>{ .. }</code> mean, since JS overloads the curly brackets to mean any of the following, depending on the context used:</p> <ul> <li>delimit values, like object literals</li> <li>define object destructuring patterns (more on this later)</li> <li>delimit interpolated string expressions, like <code>`some ${ getNumber() } thing`</code></li> <li>define blocks, like on <code>if</code> and <code>for</code> loops</li> <li>define function bodies</li> </ul> <p>Though it can sometimes be challenging as you read code, look for whether a <code>{ .. }</code> curly brace pair is used in the program where a value/expression is valid to appear; if so, it's an object literal, otherwise it's one of the other overloaded uses.</p>"},{"location":"objects-classes/ch1/#defining-properties","title":"Defining Properties","text":"<p>Inside the object literal curly braces, you define properties (name and value) with <code>propertyName: propertyValue</code> pairs, like this:</p> <pre><code>myObj = {\nfavoriteNumber: 42,\nisDeveloper: true,\nfirstName: \"Kyle\"\n};\n</code></pre> <p>The values you assign to the properties can be literals, as shown, or can be computed by expression:</p> <pre><code>function twenty() { return 20; }\nmyObj = {\nfavoriteNumber: (twenty() + 1) * 2,\n};\n</code></pre> <p>The expression <code>(twenty() + 1) * 2</code> is evaluated immediately, with the result (<code>42</code>) assigned as the property value.</p> <p>Developers sometimes wonder if there's a way to define an expression for a property value where the expression is \"lazy\", meaning it's not computed at the time of assignment, but defined later. JS does not have lazy expressions, so the only way to do so is for the expression to be wrapped in a function:</p> <pre><code>function twenty() { return 20; }\nfunction myNumber() { return (twenty() + 1) * 2; }\nmyObj = {\nfavoriteNumber: myNumber   // notice, NOT `myNumber()` as a function call\n};\n</code></pre> <p>In this case, <code>favoriteNumber</code> is not holding a numeric value, but rather a function reference. To compute the result, that function reference must be explicitly executed.</p>"},{"location":"objects-classes/ch1/#looks-like-json","title":"Looks Like JSON?","text":"<p>You may notice that this object-literal syntax we've seen thus far resembles a related syntax, \"JSON\" (JavaScript Object Notation):</p> <pre><code>{\n\"favoriteNumber\": 42,\n\"isDeveloper\": true,\n\"firstName\": \"Kyle\"\n}\n</code></pre> <p>The biggest differences between JS's object literals and JSON are, for objects defined as JSON:</p> <ol> <li> <p>property names must be quoted with <code>\"</code> double-quote characters</p> </li> <li> <p>property values must be literals (either primitives, objects, or arrays), not arbitrary JS expressions</p> </li> </ol> <p>In JS programs, an object literal does not require quoted property names -- you can quote them (<code>'</code> or <code>\"</code> allowed), but it's usually optional. There are however characters that are valid in a property name, but which cannot be included without surrounding quotes; for example, leading numbers or whitespace:</p> <pre><code>myObj = {\nfavoriteNumber: 42,\nisDeveloper: true,\nfirstName: \"Kyle\",\n\"2 nicknames\": [ \"getify\", \"ydkjs\" ]\n};\n</code></pre> <p>One other minor difference is, JSON syntax -- that is, text that will be parsed as JSON, such as from a <code>.json</code> file -- is stricter than general JS. For example, JS allows comments (<code>// ..</code> and <code>/* .. */</code>), and trailing <code>,</code> commas in object and array expressions; JSON does not allow any of these. Thankfully, JSON does still allow arbitrary whitespace.</p>"},{"location":"objects-classes/ch1/#property-names","title":"Property Names","text":"<p>Property names in object literals are almost always treated/coeced as string values. One exception to this is for integer (or \"integer looking\") property \"names\":</p> <pre><code>anotherObj = {\n42:       \"&lt;-- this property name will be treated as an integer\",\n\"41\":     \"&lt;-- ...and so will this one\",\ntrue:     \"&lt;-- this property name will be treated as a string\",\n[myObj]:  \"&lt;-- ...and so will this one\"\n};\n</code></pre> <p>The <code>42</code> property name will be treated as an integer property name (aka, index); the <code>\"41\"</code> string value will also be treated as such since it looks like an integer. By contrast, the <code>true</code> value will become the string property name <code>\"true\"</code>, and the <code>myObj</code> identifier reference, computed via the surrounding <code>[ .. ]</code>, will coerce the object's value to a string (generally the default <code>\"[object Object]\"</code>).</p> WARNING: If you need to actually use an object as a key/property name, never rely on this computed string coercion; its behavior is surprising and almost certainly not what's expected, so program bugs are likely to occur. Instead, use a more specialized data structure, called a <code>Map</code> (added in ES6), where objects used as property \"names\" are left as-is instead of being coerced to a string value. <p>As with <code>[myObj]</code> above, you can compute any property name (distinct from computing the property value) at the time of object literal definition:</p> <pre><code>anotherObj = {\n[\"x\" + (21 * 2)]: true\n};\n</code></pre> <p>The expression <code>\"x\" + (21 * 2)</code>, which must appear inside of <code>[ .. ]</code> brackets, is computed immediately, and the result (<code>\"x42\"</code>) is used as the property name.</p>"},{"location":"objects-classes/ch1/#symbols-as-property-names","title":"Symbols As Property Names","text":"<p>ES6 added a new primitive value type of <code>Symbol</code>, which is often used as a special property name for storing and retieving property values. They're created via the <code>Symbol(..)</code> function call (without the <code>new</code> keyword), which accepts an optional description string used only for friendlier debugging purposes; if specified, the description is inaccessible to the JS program and thus not used for any other purpose than debug output.</p> <pre><code>myPropSymbol = Symbol(\"optional, developer-friendly description\");\n</code></pre> NOTE: Symbols are sort of like numbers or strings, except that their value is opaque to, and globally unique within, the JS program. In other words, you can create and use symbols, but JS doesn't let you know anything about, or do anything with, the underlying value; that's kept as a hidden implementation detail by the JS engine. <p>Computed property names, as previously described, are how to define a symbol property name on an object literal:</p> <pre><code>myPropSymbol = Symbol(\"optional, developer-friendly description\");\nanotherObj = {\n[myPropSymbol]: \"Hello, symbol!\"\n};\n</code></pre> <p>The computed property name used to define the property on <code>anotherObj</code> will be the actual primitive symbol value (whatever it is), not the optional description string (<code>\"optional, developer-friendly description\"</code>).</p> <p>Because symbols are globally unique in your program, there's no chance of accidental collision where one part of the program might accidentally define a property name the same as another part of the program tried defined/assigned.</p> <p>Symbols are also useful to hook into special default behaviors of objects, and we'll cover that in more detail in \"Extending the MOP\" in the next chapter.</p>"},{"location":"objects-classes/ch1/#concise-properties","title":"Concise Properties","text":"<p>When defining an object literal, it's common to use a property name that's the same as an existing in-scope identifier that holds the value you want to assign.</p> <pre><code>coolFact = \"the first person convicted of speeding was going 8 mph\";\nanotherObj = {\ncoolFact: coolFact\n};\n</code></pre> NOTE: That would have been the same thing as the quoted property name definition <code>\"coolFact\": coolFact</code>, but JS developers rarely quote property names unless strictly necessary. Indeed, it's idiomatic to avoid the quotes unless required, so it's discouraged to include them unneccessarily. <p>In this situation, where the property name and value expression identifier are identical, you can omit the property-name portion of the property definition, as a so-called \"concise property\" definition:</p> <pre><code>coolFact = \"the first person convicted of speeding was going 8 mph\";\nanotherObj = {\ncoolFact   // &lt;-- concise property short-hand\n};\n</code></pre> <p>The property name is <code>\"coolFact\"</code> (string), and the value assigned to the property is what's in the <code>coolFact</code> variable at that moment: <code>\"the first person convicted of speeding was going 8 mph\"</code>.</p> <p>At first, this shorthand convenience may seem confusing. But as you get more familiar with seeing this very common and popular feature being used, you'll likely favor it for typing (and reading!) less.</p>"},{"location":"objects-classes/ch1/#concise-methods","title":"Concise Methods","text":"<p>Another similar shorthand is defining functions/methods in an object literal using a more concise form:</p> <pre><code>anotherObj = {\n// standard function property\ngreet: function() { console.log(\"Hello!\"); },\n// concise function/method property\ngreet2() { console.log(\"Hello, friend!\"); }\n};\n</code></pre> <p>While we're on the topic of concise method properties, we can also define generator functions (another ES6 feature):</p> <pre><code>anotherObj = {\n// instead of:\n//   greet3: function*() { yield \"Hello, everyone!\"; }\n// concise generator method\n*greet3() { yield \"Hello, everyone!\"; }\n};\n</code></pre> <p>And though it's not particularly common, concise methods/generators can even have quoted or computed names:</p> <pre><code>anotherObj = {\n\"greet-4\"() { console.log(\"Hello, audience!\"); },\n// concise computed name\n[ \"gr\" + \"eet 5\" ]() { console.log(\"Hello, audience!\"); },\n// concise computed generator name\n*[ \"ok, greet 6\".toUpperCase() ]() { yield \"Hello, audience!\"; }\n};\n</code></pre>"},{"location":"objects-classes/ch1/#object-spread","title":"Object Spread","text":"<p>Another way to define properties at object literal creation time is with a form of the <code>...</code> syntax -- it's not technically an operator, but it certainly seems like one -- often referred to as \"object spread\".</p> <p>The <code>...</code> when used inside an object literal will \"spread\" out the contents (properties, aka key/value pairs) of another object value into the object being defined:</p> <pre><code>anotherObj = {\nfavoriteNumber: 12,\n...myObj,   // object spread, shallow copies `myObj`\ngreeting: \"Hello!\"\n}\n</code></pre> <p>The spreading of <code>myObj</code>'s properties is shallow, in that it only copies the top-level properties from <code>myObj</code>; any values those properties hold are simply assigned over. If any of those values are references to other objects, the references themselves are assigned (by copy), but the underlying object values are not duplicated -- so you end up with multiple shared references to the same object(s).</p> <p>You can think of object spreading like a <code>for</code> loop that runs through the properties one at a time and does an <code>=</code> style assignment from the source object (<code>myObj</code>) to the target object (<code>anotherObj</code>).</p> <p>Also, consider these property definition operations to happen \"in order\", from top to bottom of the object literal. In the above snippet, since <code>myObj</code> has a <code>favoriteNumber</code> property, the object spread will end up overwriting the <code>favoriteNumber: 12</code> property assignment from the previous line. Moreover, if <code>myObj</code> had contained a <code>greeting</code> property that was copied over, the next line (<code>greeting: \"Hello!\"</code>) would override that property definition.</p> NOTE: Object spread also only copies owned properties (those directly on the object) that are enumerable (allowed to be enumerated/listed). It does not duplicate the property -- as in, actually mimic the property's exact characteristics -- but rather do a simple assignment style copy. We'll cover more such details in the \"Property Descriptors\" section of the next chapter. <p>A common way <code>...</code> object spread is used is for performing shallow object duplication:</p> <pre><code>myObjShallowCopy = { ...myObj };\n</code></pre> <p>Keep in mind you cannot <code>...</code> spread into an existing object value; the <code>...</code> object spread syntax can only appear inside the <code>{ .. }</code> object literal, which is creating a new object value. To perform a similar shallow object copy but with APIs instead of syntax, see the \"Object Entries\" section later in this chapter (with coverage of <code>Object.entries(..)</code> and <code>Object.fromEntries(..)</code>).</p> <p>But if you instead want to copy object properties (shallowly) into an existing object, see the \"Assigning Properties\" section later in this chapter (with coverage of <code>Object.assign(..)</code>).</p>"},{"location":"objects-classes/ch1/#deep-object-copy","title":"Deep Object Copy","text":"<p>Also, since <code>...</code> doesn't do full, deep object duplication, the object spread is generally only suitable for duplicating objects that hold simple, primitive values only, not references to other objects.</p> <p>Deep object duplication is an incredibly complex and nuanced operation. Duplicating a value like <code>42</code> is obvious and straightforward, but what does it mean to copy a function (which is a special kind of object, also held by reference), or to copy an external (not entirely in JS) object reference, such as a DOM element? And what happens if an object has circular references (like where a nested descendant object holds a reference back up to an outer ancestor object)? There's a variety of opinions in the wild about how all these corner cases should be handled, and thus no single standard exists for deep object duplication.</p> <p>For deep object duplication, the standard approaches have been:</p> <ol> <li> <p>Use a library utility that declares a specific opinion on how the duplication behaviors/nuances should be handled.</p> </li> <li> <p>Use the <code>JSON.parse(JSON.stringify(..))</code> round-trip trick -- this only \"works\" correctly if there are no circular references, and if there are no values in the object that cannot be properly serialized with JSON (such as functions).</p> </li> </ol> <p>Recently, though, a third option has landed. This is not a JS feature, but rather a companion API provided to JS by environments like the web platform. Objects can be deep copied now using <code>structuredClone(..)</code>[^stucturedClone].</p> <pre><code>myObjCopy = structuredClone(myObj);\n</code></pre> <p>The underlying algorithm behind this built-in utility supports duplicating circular references, as well as many more types of values than the <code>JSON</code> round-trip trick. However, this algorithm still has its limits, including no support for cloning functions or DOM elements.</p>"},{"location":"objects-classes/ch1/#accessing-properties","title":"Accessing Properties","text":"<p>Property access of an existing object is preferably done with the <code>.</code> operator:</p> <pre><code>myObj.favoriteNumber;    // 42\nmyObj.isDeveloper;       // true\n</code></pre> <p>If it's possible to access a property this way, it's strongly suggested to do so.</p> <p>If the property name contains characters that cannot appear in identifiers, such as leading numbers or whitespace, <code>[ .. ]</code> brackets can be used instead of the <code>.</code>:</p> <pre><code>myObj[\"2 nicknames\"];    // [ \"getify\", \"ydkjs\" ]\n</code></pre> <pre><code>anotherObj[42];          // \"&lt;-- this property name will...\"\nanotherObj[\"41\"];        // \"&lt;-- this property name will...\"\n</code></pre> <p>Even though numeric property \"names\" remain as numbers, property access via the <code>[ .. ]</code> brackets will coerce a string representation to a number (e.g., <code>\"42\"</code> as the <code>42</code> numeric equivalent), and then access the associated numeric property accordingly.</p> <p>Similar to the object literal, the property name to access can be computed via the <code>[ .. ]</code> brackets. The expression can be a simple identifier:</p> <pre><code>propName = \"41\";\nanotherObj[propName];\n</code></pre> <p>Actually, what you put between the <code>[ .. ]</code> brackets can be any arbitrary JS expression, not just identifiers or literal values like <code>42</code> or <code>\"isDeveloper\"</code>. JS will first evaluate the expression, and the resulting value will then be used as the property name to look up on the object:</p> <pre><code>function howMany(x) {\nreturn x + 1;\n}\nmyObj[`${ howMany(1) } nicknames`];   // [ \"getify\", \"ydkjs\" ]\n</code></pre> <p>In this snippet, the expression is a back-tick delimited <code>`template string literal`</code> with an interpolated expression of the function call <code>howMany(1)</code>. The overall result of that expression is the string value <code>\"2 nicknames\"</code>, which is then used as the property name to access.</p>"},{"location":"objects-classes/ch1/#object-entries","title":"Object Entries","text":"<p>You can get a listing of the properties in an object, as an array of tuples (two-element sub-arrays) holding the property name and value:</p> <pre><code>myObj = {\nfavoriteNumber: 42,\nisDeveloper: true,\nfirstName: \"Kyle\"\n};\nObject.entries(myObj);\n// [ [\"favoriteNumber\",42], [\"isDeveloper\",true], [\"firstName\",\"Kyle\"] ]\n</code></pre> <p>Added in ES6, <code>Object.entries(..)</code> retrieves this list of entries -- containing only owned an enumerable properties; see the \"Property Descriptors\" section in the next chapter -- from a source object.</p> <p>Such a list can be looped/iterated over, potentially assigning properties to another existing object. However, it's also possible to create a new object from a list of entries, using <code>Object.fromEntries(..)</code> (added in ES2019):</p> <pre><code>myObjShallowCopy = Object.fromEntries( Object.entries(myObj) );\n// alternate approach to the earlier discussed:\n// myObjShallowCopy = { ...myObj };\n</code></pre>"},{"location":"objects-classes/ch1/#destructuring","title":"Destructuring","text":"<p>Another approach to accessing properties is through object destructuring (added in ES6). Think of destructuring as defining a \"pattern\" that describes what an object value is supposed to \"look like\" (structurally), and then asking JS to follow that \"pattern\" to systematically access the contents of an object value.</p> <p>The end result of object destructuring is not another object, but rather one or more assignments to other targets (variables, etc) of the values from the source object.</p> <p>Imagine this sort of pre-ES6 code:</p> <pre><code>myObj = {\nfavoriteNumber: 42,\nisDeveloper: true,\nfirstName: \"Kyle\"\n};\nconst favoriteNumber = (\nmyObj.favoriteNumber !== undefined ? myObj.favoriteNumber : 42\n);\nconst isDev = myObj.isDeveloper;\nconst firstName = myObj.firstName;\nconst lname = (\nmyObj.lastName !== undefined ? myObj.lastName : \"--missing--\"\n);\n</code></pre> <p>Those accesses of the property values, and assignments to other identifiers, is generally called \"manual destructuring\". To use the declarative object destructuring syntax, it might look like this:</p> <pre><code>myObj = {\nfavoriteNumber: 42,\nisDeveloper: true,\nfirstName: \"Kyle\"\n};\nconst { favoriteNumber = 12 } = myObj;\nconst {\nisDeveloper: isDev,\nfirstName: firstName,\nlastName: lname = \"--missing--\"\n} = myObj;\nfavoriteNumber;   // 42\nisDev;            // true\nfirstName;        // \"Kyle\"\nlname;            // \"--missing--\"\n</code></pre> <p>As shown, the <code>{ .. }</code> object destucturing resembles an object literal value definition, but it appears on the left-hand side of the <code>=</code> operator rather than on the right-hand side where an object value expression would appear. That makes the <code>{ .. }</code> on the left-hand side a destructuring pattern rather than another object definition.</p> <p>The <code>{ favoriteNumber } = myObj</code> destructuring tells JS to find a property named <code>favoriteNumber</code> on the object, and to assign its value to an identifier of the same name. The single instance of the <code>favoriteNumber</code> identifier in the pattern is similar to \"concise properties\" as discussed earlier in this chapter: if the source (property name) and target (identifier) are the same, you can omit one of them and only list it once.</p> <p>The <code>= 12</code> part tells JS to provide <code>12</code> as a default value for the assignment to <code>favoriteNumber</code>, if the source object either doesn't have a <code>favoriteNumber</code> property, or if the property holds an <code>undefined</code> value.</p> <p>In the second destructuring pattern, the <code>isDeveloper: isDev</code> pattern is instructing JS to find a property named <code>isDeveloper</code> on the source object, and assign its value to an identifier named <code>isDev</code>. It's sort of a \"renaming\" of the source to the target. By contrast, <code>firstName: firstName</code> is providing the source and target for an assignment, but is redundant since they're identical; a single <code>firstName</code> would have sufficed here, and is generally more preferred.</p> <p>The <code>lastName: lname = \"--missing--\"</code> combines both source-target renaming and a default value (if the <code>lastName</code> source property is missing or <code>undefined</code>).</p> <p>The above snippet combines object destructuring with variable declarations -- in this example, <code>const</code> is used, but <code>var</code> and <code>let</code> work as well -- but it's not inherently a declaration mechanism. Destructuring is about access and assignment (source to target), so it can operate against existing targets rather than declaring new ones:</p> <pre><code>let fave;\n// surrounding ( ) are required syntax here,\n// when a declarator is not used\n({ favoriteNumber: fave } = myObj);\nfave;  // 42\n</code></pre> <p>Object destructuring syntax is generally preferred for its declarative and more readable style, over the heavily imperative pre-ES6 equivalents. But don't go overboard with destructuring. Sometimes just doing <code>x = someObj.x</code> is perfectly fine!</p>"},{"location":"objects-classes/ch1/#conditional-property-access","title":"Conditional Property Access","text":"<p>Recently (in ES2020), a feature known as \"optional chaining\" was added to JS, which augments property access capabilities (especially nested property access). The primary form is the two-character compound operator <code>?.</code>, like <code>A?.B</code>.</p> <p>This operator will check the left-hand side reference (<code>A</code>) to see if it's null'ish (<code>null</code> or <code>undefined</code>). If so, the rest of the property access expression is short-circuited (skipped), and <code>undefined</code> is returned as the result (even if it was <code>null</code> that was actually encountered!). Otherwise, <code>?.</code> will access the property just as a normal <code>.</code> operator would.</p> <p>For example:</p> <pre><code>myObj?.favoriteNumber\n</code></pre> <p>Here, the null'ish check is performed against the <code>myObj</code>, meaning that the <code>favoriteNumber</code> property access is only performed if the value in <code>myObj</code> is non-null'ish. Note that it doesn't verify that <code>myObj</code> is actually holding a real object, only that it's non-nullish. However, all non-nullish values can \"safely\" (no JS exception) be \"accessed\" via the <code>.</code> operator, even if there's no matching property to retrieve.</p> <p>It's easy to get confused into thinking that the null'ish check is against the <code>favoriteNumber</code> property. But one way to keep it straight is to remember that the <code>?</code> is on the side where the safety check is performed, while the <code>.</code> is on the side that is only conditionally evaluated if the non-null'ish check passes.</p> <p>Typically, the <code>?.</code> operator is used in nested property accesses that may be 3 or more levels deep, such as:</p> <pre><code>myObj?.address?.city\n</code></pre> <p>The equivalent operation with the <code>?.</code> operator would look like this:</p> <pre><code>(myObj != null &amp;&amp; myObj.address != null) ? myObj.address.city : undefined\n</code></pre> <p>Again, remember that no check has been performed against the right-most property (<code>city</code>) here.</p> <p>Also, the <code>?.</code> should not universally be used in place of every single <code>.</code> operator in your programs. You should endeavor to know if a <code>.</code> property access will succeed or not before making the access, whenever possible. Use <code>?.</code> only when the nature of the values being accessed is subject to conditions that cannot be predicted/controlled.</p> <p>For example, in the previous snippet, the <code>myObj?.</code> usage is probably mis-guided, because it really shouldn't be the case that you start a chain of property access against a variable that might not even hold a top-level object (aside from its contents potentially missing certain properties in certain conditions).</p> <p>Instead, I would recommend usage more like this:</p> <pre><code>myObj.address?.city\n</code></pre> <p>And that expression should only be used in part of your program where you're sure that <code>myObj</code> is at least holding a valid object (whether or not it has an <code>address</code> property with a sub-object in it).</p> <p>Another form of the \"optional chaining\" operator is <code>?.[</code>, which is used when the property access you want to make conditional/safe requires a <code>[ .. ]</code> bracket.</p> <pre><code>myObj[\"2 nicknames\"]?.[0];   // \"getify\"\n</code></pre> <p>Everything asserted about how <code>?.</code> behaves goes the same for <code>?.[</code>.</p> WARNING: There's a third form of this feature, named \"optional call\", which uses <code>?.(</code> as the operator. It's used for performing a non-null'ish check on a property before executing the function value in the property. For example, instead of <code>myObj.someFunc(42)</code>, you can do <code>myObj.someFunc?.(42)</code>. The <code>?.(</code> checks to make sure <code>myObj.someFunc</code> is non-null'ish before invoking it (with the <code>(42)</code> part). While that may sound like a useful feature, I think this is dangerous enough to warrant complete avoidance of this form/construct.My concern is that <code>?.(</code> makes it seem as if we're ensuring that the function is \"callable\" before calling it, when in fact we're only checking if it's non-null'ish. Unlike <code>?.</code> which can allow a \"safe\" <code>.</code> access against a non-null'ish value that's also not an object, the <code>?.(</code> non-null'ish check isn't similarly \"safe\". If the property in question has any non-null'ish, non-function value in it, like <code>true</code> or <code>\"Hello\"</code>, the <code>(42)</code> call part will be invoked and yet throw a JS exception. So in other words, this form is unfortunately masquerading as more \"safe\" than it actually is, and should thus be avoided in essentially all circumstances. If a property value can ever not be a function, do a more fullsome check for its function'ness before trying to invoke it. Don't pretend that <code>?.(</code> is doing that for you, or future readers/maintainers of your code (including your future self!) will likely regret it."},{"location":"objects-classes/ch1/#accessing-properties-on-non-objects","title":"Accessing Properties On Non-Objects","text":"<p>This may sound counter-intuitive, but you can generally access properties/methods from values that aren't themselves objects:</p> <pre><code>fave = 42;\nfave;              // 42\nfave.toString();   // \"42\"\n</code></pre> <p>Here, <code>fave</code> holds a primitive <code>42</code> number value. So how can we do <code>.toString</code> to access a property from it, and then <code>()</code> to invoke the function held in that property?</p> <p>This is a tremendously more indepth topic than we'll get into in this book; see book 4, \"Types &amp; Grammar\", of this series for more. However, as a quick glimpse: if you perform a property access (<code>.</code> or <code>[ .. ]</code>) against a non-object, non-null'ish value, JS will by default (temporarily!) coerce the value into an object-wrapped representation, allowing the property access against that implicitly instantiated object.</p> <p>This process is typically called \"boxing\", as in putting a value inside a \"box\" (object container).</p> <p>So in the above snippet, just for the moment that <code>.toString</code> is being accessed on the <code>42</code> value, JS will box this value into a <code>Number</code> object, and then perform the property access.</p> <p>Note that <code>null</code> and <code>undefined</code> can be object-ified, by calling <code>Object(null)</code> / <code>Object(undefined)</code>. However, JS does not automatically box these null'ish values, so property access against them will fail (as discussed earlier in the \"Conditional Property Access\" section).</p> NOTE: Boxing has a counterpart: unboxing. For example, the JS engine will take an object wrapper -- like a <code>Number</code> object wrapped around <code>42</code> -- created with <code>Number(42)</code> or <code>Object(42)</code> -- and unwrap it to retrieve the underlying primitive <code>42</code>, whenever a mathematical operation (like <code>*</code> or <code>-</code>) encounters such an object. Unboxing behavior is way out of scope for our discussion, but is covered fully in the aforementioned \"Types &amp; Grammar\" title."},{"location":"objects-classes/ch1/#assiging-properties","title":"Assiging Properties","text":"<p>Whether a property is defined at the time of object literal definition, or added later, the assignment of a property value is done with the <code>=</code> operator, as any other normal assignment would be:</p> <pre><code>myObj.favoriteNumber = 123;\n</code></pre> <p>If the <code>favoriteNumber</code> property doesn't already exist, that statement will create a new property of that name and assign its value. But if it already exists, that statement will re-assign its value.</p> WARNING: An <code>=</code> assignment to a property may fail (silently or throwing an exception), or it may not directly assign the value but instead invoke a setter function that performs some operation(s). More details on these behaviors in the next chapter. <p>It's also possible to assign one or more properties at once -- assuming the source properties (name and value pairs) are in another object -- using the <code>Object.assign(..)</code> (added in ES6) method:</p> <pre><code>// shallow copy all (owned and enumerable) properties\n// from `myObj` into `anotherObj`\nObject.assign(anotherObj,myObj);\nObject.assign(\n/*target=*/anotherObj,\n/*source1=*/{\nsomeProp: \"some value\",\nanotherProp: 1001,\n},\n/*source2=*/{\nyetAnotherProp: false\n}\n);\n</code></pre> <p><code>Object.assign(..)</code> takes the first object as target, and the second (and optionally subsequent) object(s) as source(s). Copying is done in the same manner as described earlier in the \"Object Spread\" section.</p>"},{"location":"objects-classes/ch1/#deleting-properties","title":"Deleting Properties","text":"<p>Once a property is defined on an object, the only way to remove it is with the <code>delete</code> operator:</p> <pre><code>anotherObj = {\ncounter: 123\n};\nanotherObj.counter;   // 123\ndelete anotherObj.counter;\nanotherObj.counter;   // undefined\n</code></pre> <p>Contrary to common misconception, the JS <code>delete</code> operator does not directly do any deallocation/freeing up of memory, through garbage collection (GC). The only thing it does is remove a property from an object. If the value in the property was a reference (to another object/etc), and there are no other surviving references to that value once the property is removed, that value would likely then be eligible for removal in a future sweep of the GC.</p> <p>Calling <code>delete</code> on anything other than an object property is a misuse of the <code>delete</code> operator, and will either fail silently (in non-strict mode) or throw an exception (in strict mode).</p> <p>Deleting a property from an object is distinct from assigning it a value like <code>undefined</code> or <code>null</code>. A property assigned <code>undefined</code>, either initially or later, is still present on the object, and might still be revealed when enumerating the contents</p>"},{"location":"objects-classes/ch1/#determining-container-contents","title":"Determining Container Contents","text":"<p>You can determine an object's contents in a variety of ways. To ask an object if it has a specific property:</p> <pre><code>myObj = {\nfavoriteNumber: 42,\ncoolFact: \"the first person convicted of speeding was going 8 mph\",\nbeardLength: undefined,\nnicknames: [ \"getify\", \"ydkjs\" ]\n};\n\"favoriteNumber\" in myObj;            // true\nmyObj.hasOwnProperty(\"coolFact\");     // true\nmyObj.hasOwnProperty(\"beardLength\");  // true\nmyObj.nicknames = undefined;\nmyObj.hasOwnProperty(\"nicknames\");    // true\ndelete myObj.nicknames;\nmyObj.hasOwnProperty(\"nicknames\");    // false\n</code></pre> <p>There is an important difference between how the <code>in</code> operator and the <code>hasOwnProperty(..)</code> method behave. The <code>in</code> operator will check not only the target object specified, but if not found there, it will also consult the object's <code>[[Prototype]]</code> chain (covered in the next chapter). By contrast, <code>hasOwnProperty(..)</code> only consults the target object.</p> <p>If you're paying close attention, you may have noticed that <code>myObj</code> appears to have a method property called <code>hasOwnProperty(..)</code> on it, even though we didn't define such. That's because <code>hasOwnProperty(..)</code> is defined as a built-in on <code>Object.prototype</code>, which by default is \"inherited by\" all normal objects. There is risk inherent to accessing such an \"inherited\" method, though. Again, more on prototypes in the next chapter.</p>"},{"location":"objects-classes/ch1/#better-existence-check","title":"Better Existence Check","text":"<p>ES2022 (almost official at time of writing) has already settled on a new feature, <code>Object.hasOwn(..)</code>. It does essentially the same thing as <code>hasOwnProperty(..)</code>, but it's invoked as a static helper external to the object value instead of via the object's <code>[[Prototype]]</code>, making it safer and more consistent in usage:</p> <pre><code>// instead of:\nmyObj.hasOwnProperty(\"favoriteNumber\")\n// we should now prefer:\nObject.hasOwn(myObj,\"favoriteNumber\")\n</code></pre> <p>Even though (at time of writing) this feature is just now emerging in JS, there are polyfills that make this API available in your programs even when running in a previous JS environment that doesn't yet have the feature defined. For example, a quick stand-in polyfill sketch:</p> <pre><code>// simple polyfill sketch for `Object.hasOwn(..)`\nif (!Object.hasOwn) {\nObject.hasOwn = function hasOwn(obj,propName) {\nreturn Object.prototype.hasOwnProperty.call(obj,propName);\n};\n}\n</code></pre> <p>Including a polyfill patch such as that in your program means you can safely start using <code>Object.hasOwn(..)</code> for property existence checks no matter whether a JS environment has <code>Object.hasOwn(..)</code> built in yet or not.</p>"},{"location":"objects-classes/ch1/#listing-all-container-contents","title":"Listing All Container Contents","text":"<p>We already discussed the <code>Object.entries(..)</code> API earlier, which tells us what properties an object has (as long as they're enumerable -- more in the next chapter).</p> <p>There's a variety of other mechanisms available, as well. <code>Object.keys(..)</code> gives us list of the enumerable property names (aka, keys) in an object -- names only, no values; <code>Object.values(..)</code> instead gives us list of all values held in enumerable properties.</p> <p>But what if we wanted to get all the keys in an object (enumerable or not)? <code>Object.getOwnPropertyNames(..)</code> seems to do what we want, in that it's like <code>Object.keys(..)</code> but also returns non-enumerable property names. However, this list will not include any Symbol property names, as those are treated as special locations on the object. <code>Object.getOwnPropertySymbols(..)</code> returns all of an object's Symbol properties. So if you concatenate both of those lists together, you'd have all the direct (owned) contents of an object.</p> <p>Yet as we've implied several times already, and will cover in full detail in the next chapter, an object can also \"inherit\" contents from its <code>[[Prototype]]</code> chain. These are not considered owned contents, so they won't show up in any of these lists.</p> <p>Recall that the <code>in</code> operator will potentially traverse the entire chain looking for the existence of a property. Similarly, a <code>for..in</code> loop will traverse the chain and list any enumerable (owned or inhertied) properties. But there's no built-in API that will traverse the whole chain and return a list of the combined set of both owned and inherited contents.</p>"},{"location":"objects-classes/ch1/#temporary-containers","title":"Temporary Containers","text":"<p>Using a container to hold multiple values is sometimes just a temporary transport mechanism, such as when you want to pass multiple values to a function via a single argument, or when you want a function to return multiple values:</p> <pre><code>function formatValues({ one, two, three }) {\n// the actual object passed in as an\n// argument is not accessible, since\n// we destructured it into three\n// separate variables\none = one.toUpperCase();\ntwo = `--${two}--`;\nthree = three.substring(0,5);\n// this object is only to transport\n// all three values in a single\n// return statement\nreturn { one, two, three };\n}\n// destructuring the return value from\n// the function, because that returned\n// object is just a temporary container\n// to transport us multiple values\nconst { one, two, three } =\n// this object argument is a temporary\n// transport for multiple input values\nformatValues({\none: \"Kyle\",\ntwo: \"Simpson\"\nthree: \"getify\"\n});\none;     // \"KYLE\"\ntwo;     // \"--Simpson--\"\nthree;   // \"getif\"\n</code></pre> <p>The object literal passed into <code>formatValues(..)</code> is immediately parameter destructured, so inside the function we only deal with three separate variables (<code>one</code>, <code>two</code>, and <code>three</code>). The object literal <code>return</code>ed from the function is also immediately destructured, so again we only deal with three separate variables (<code>one</code>, <code>two</code>, <code>three</code>).</p> <p>This snippet illustrates the idiom/pattern that an object is sometimes just a temporary transport container rather than a meaningful value in and of itself.</p>"},{"location":"objects-classes/ch1/#containers-are-collections-of-properties","title":"Containers Are Collections Of Properties","text":"<p>The most common usage of objects is as containers for multiple values. We create and manage property container objects by:</p> <ul> <li>defining properties (named locations), either at object creation time or later</li> <li>assigning values, either at object creation time or later</li> <li>accessing values later, using the location names (property names)</li> <li>deleteing properties via <code>delete</code></li> <li>determining container contents with <code>in</code>, <code>hasOwnProperty(..)</code> / <code>hasOwn(..)</code>, <code>Object.entries(..)</code> / <code>Object.keys(..)</code>, etc</li> </ul> <p>But there's a lot more to objects than just static collections of property names and values. In the next chapter, we'll dive under the hood to look at how they actually work.</p> <ol> <li> <p>\"Structured Clone Algorithm\", HTML Specification; https://html.spec.whatwg.org/multipage/structured-data.html#structured-cloning ; Accessed July 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"objects-classes/ch2/","title":"Chapter 2: How Objects Work","text":"NOTE: Work in progress <p>Objects are not just containers for multiple values, though clearly that's the context for most interactions with objects.</p> <p>To fully understand the object mechanism in JS, and get the most out of using objects in our programs, we need to look more closely at a number of characteristics of objects (and their properties) which can affect their behavior when interacting with them.</p> <p>These characteristics that define the underlying behavior of objects are collectively referred to in formal terms as the \"metaobject protocol\" (MOP)1. The MOP is useful not only for understanding how objects will behave, but also for overriding the default behaviors of objects to bend the language to fit our program's needs more fully.</p>"},{"location":"objects-classes/ch2/#property-descriptors","title":"Property Descriptors","text":"<p>Each property on an object is internally described by what's known as a \"property descriptor\". This is, itself, an object (aka, \"metaobject\") with several properties (aka \"attributes\") on it, dictating how the target property behaves.</p> <p>We can retrieve a property descriptor for any existing property using <code>Object.getOwnPropertyDescriptor(..)</code> (ES5):</p> <pre><code>myObj = {\nfavoriteNumber: 42,\nisDeveloper: true,\nfirstName: \"Kyle\"\n};\nObject.getOwnPropertyDescriptor(myObj,\"favoriteNumber\");\n// {\n//     value: 42,\n//     enumerable: true,\n//     writable: true,\n//     configurable: true\n// }\n</code></pre> <p>We can even use such a descriptor to define a new property on an object, using <code>Object.defineProperty(..)</code> (ES5):</p> <pre><code>anotherObj = {};\nObject.defineProperty(anotherObj,\"fave\",{\nvalue: 42,\nenumerable: true,     // default if omitted\nwritable: true,       // default if omitted\nconfigurable: true    // default if omitted\n});\nanotherObj.fave;          // 42\n</code></pre> <p>If an existing property has not already been marked as non-configurable (with <code>configurable: false</code> in its descriptor), it can always be re-defined/overwritten using <code>Object.defineProperty(..)</code>.</p> WARNING: A number of earlier sections in this chapter refer to \"copying\" or \"duplicating\" properties. One might assume such copying/duplication would be at the property descriptor level. However, none of those operations actually work that way; they all do simple <code>=</code> style access and assignment, which has the effect of ignoring any nuances in how the underlying descriptor for a property is defined. <p>Though it seems far less common out in the wild, we can even define multiple properties at once, each with their own descriptor:</p> <pre><code>anotherObj = {};\nObject.defineProperties(anotherObj,{\n\"fave\": {\n// a property descriptor\n},\n\"superFave\": {\n// another property descriptor\n}\n});\n</code></pre> <p>It's not very common to see this usage, because it's rarer that you need to specifically control the definition of multiple properties. But it may be useful in some cases.</p>"},{"location":"objects-classes/ch2/#accessor-properties","title":"Accessor Properties","text":"<p>A property descriptor usually defines a <code>value</code> property, as shown above. However, a special kind of property, known as an \"accessor property\" (aka, a getter/setter), can be defined. For these a property like this, its descriptor does not define a fixed <code>value</code> property, but would instead look something like this:</p> <pre><code>{\nget() { .. },    // function to invoke when retrieving the value\nset(v) { .. },   // function to invoke when assigning the value\n// .. enumerable, etc\n}\n</code></pre> <p>A getter looks like a property access (<code>obj.prop</code>), but under the covers it invokes the <code>get()</code> method as defined; it's sort of like if you had called <code>obj.prop()</code>. A setter looks like a property assignment (<code>obj.prop = value</code>), but it invokes the <code>set(..)</code> method as defined; it's sort of like if you had called <code>obj.prop(value)</code>.</p> <p>Let's illustrate a getter/setter accessor property:</p> <pre><code>anotherObj = {};\nObject.defineProperty(anotherObj,\"fave\",{\nget() { console.log(\"Getting 'fave' value!\"); return 123; },\nset(v) { console.log(`Ignoring ${v} assignment.`); }\n});\nanotherObj.fave;\n// Getting 'fave' value!\n// 123\nanotherObj.fave = 42;\n// Ignoring 42 assignment.\nanotherObj.fave;\n// Getting 'fave' value!\n// 123\n</code></pre>"},{"location":"objects-classes/ch2/#enumerable-writable-configurable","title":"Enumerable, Writable, Configurable","text":"<p>Besides <code>value</code> or <code>get()</code> / <code>set(..)</code>, the other 3 attributes of a property descriptor are (as shown above):</p> <ul> <li><code>enumerable</code></li> <li><code>writable</code></li> <li><code>configurable</code></li> </ul> <p>The <code>enumerable</code> attribute controls whether the property will appear in various enumerations of object properties, such as <code>Object.keys(..)</code>, <code>Object.entries(..)</code>, <code>for..in</code> loops, and the copying that occurs with the <code>...</code> object spread and <code>Object.assign(..)</code>. Most properties should be left enumerable, but you can mark certain special properties on an object as non-enumerable if they shouldn't be iterated/copied.</p> <p>The <code>writable</code> attribute controls whether a <code>value</code> assignment (via <code>=</code>) is allowed. To make a property \"read only\", define it with <code>writable: false</code>. However, as long as the property is still configurable, <code>Object.defineProperty(..)</code> can still change the value by setting <code>value</code> differently.</p> <p>The <code>configurable</code> attribute controls whether a property's descriptor can be re-defined/overwritten. A property that's <code>configurable: false</code> is locked to its definition, and any further attempts to change it with <code>Object.defineProperty(..)</code> will fail. A non-configurable property can still be assigned new values (via <code>=</code>), as long as <code>writable: true</code> is still set on the property's descriptor.</p>"},{"location":"objects-classes/ch2/#object-sub-types","title":"Object Sub-Types","text":"<p>There are a variety of specialized sub-types of objects in JS. But by far, the two most common ones you'll interact with are arrays and <code>function</code>s.</p> NOTE: By \"sub-type\", we mean the notion of a derived type that has inherited the behaviors from a parent type but then specialized or extended those behaviors. In other words, values of these sub-types are fully objects, but are also more than just objects."},{"location":"objects-classes/ch2/#arrays","title":"Arrays","text":"<p>Arrays are objects that are specifically intended to be numerically indexed, rather than using string named property locations. They are still objects, so a named property like <code>favoriteNumber</code> is legal. But it's greatly frowned upon to mix named properties into numerically indexed arrays.</p> <p>Arrays are preferably defined with literal syntax (similar to objects), but with the <code>[ .. ]</code> square brackets rather than <code>{ .. }</code> curly brackets:</p> <pre><code>myList = [ 23, 42, 109 ];\n</code></pre> <p>JS allows any mixture of value types in arrays, including objects, other arrays, functions, etc. As you're likely already aware, arrays are \"zero-indexed\", meaning the first element in the array is at the index <code>0</code>, not <code>1</code>:</p> <pre><code>myList = [ 23, 42, 109 ];\nmyList[0];      // 23\nmyList[1];      // 42\n</code></pre> <p>Recall that any string property name on an object that \"looks like\" an integer -- is able to be validly coerced to a numeric integer -- will actually be treated like an integer property (aka, integer index). The same goes for arrays. You should always use <code>42</code> as an integer index (aka, property name), but if you use the string <code>\"42\"</code>, JS will assume you meant that as an integer and do that for you.</p> <pre><code>// \"2\" works as an integer index here, but it's not advised\nmyList[\"2\"];    // 109\n</code></pre> <p>One exception to the \"no named properties on arrays\" rule is that all arrays automatically expose a <code>length</code> property, which is automatically kept updated with the \"length\" of the array.</p> <pre><code>myList = [ 23, 42, 109 ];\nmyList.length;   // 3\n// \"push\" another value onto the end of the list\nmyList.push(\"Hello\");\nmyList.length;   // 4\n</code></pre> WARNING: Many JS developers incorrectly believe that array <code>length</code> is basically a getter (see \"Accessor Properties\" earlier in this chapter), but it's not. The offshoot is that these developers feel like it's \"expensive\" to access this property -- as if JS has to on-the-fly recompute the length -- and will thus do things like capture/store the length of an array before doing a non-mutating loop over it. This used to be \"best practice\" from a performance perspective. But for at least 10 years now, that's actually been an anti-pattern, because the JS engine is more efficient at managing the <code>length</code> property than our JS code is at trying to \"outsmart\" the engine to avoid invoking something we think is a getter. It's more efficient to let the JS engine do its job, and just access the property whenever and however often it's needed."},{"location":"objects-classes/ch2/#empty-slots","title":"Empty Slots","text":"<p>JS arrays also have a really unfortunate \"flaw\" in their design, referred to as \"empty slots\". If you assign an index of an array more than one position beyond the current end of the array, JS will leave the in between slots \"empty\" rather than auto-assigning them to <code>undefined</code> as you might expect:</p> <pre><code>myList = [ 23, 42, 109 ];\nmyList.length;              // 3\nmyList[14] = \"Hello\";\nmyList.length;              // 15\nmyList;                     // [ 23, 42, 109, empty x 11, \"Hello\" ]\n// looks like a real slot with a\n// real `undefined` value in it,\n// but beware, it's a trick!\nmyList[9];                  // undefined\n</code></pre> <p>You might wonder why empty slots are so bad? One reason: there are APIs in JS, like array's <code>map(..)</code>, where empty slots are suprisingly skipped over! Never, ever intentionally create empty slots in your arrays. This in undebateably one of JS's \"bad parts\".</p>"},{"location":"objects-classes/ch2/#functions","title":"Functions","text":"<p>I don't have much specifically to say about functions here, other than to point out that they are also sub-object-types. This means that in addition to being executable, they can also have named properties added to or accessed from them.</p> <p>Functions have two pre-defined properties you may find yourself interacting with, specifially for meta-programming purposes:</p> <pre><code>function help(opt1,opt2,...remainingOpts) {\n// ..\n}\nhelp.name;          // \"help\"\nhelp.length;        // 2\n</code></pre> <p>The <code>length</code> of a function is the count of its explicitly defined parameters, up to but not including a parameter that either has a default value defined (e.g., <code>param = 42</code>) or a \"rest parameter\" (e.g., <code>...remainingOpts</code>).</p>"},{"location":"objects-classes/ch2/#avoid-setting-function-object-properties","title":"Avoid Setting Function-Object Properties","text":"<p>You should avoid assigning properties on function objects. If you're looking to store extra information associated with a function, use a separate <code>Map(..)</code> (or <code>WeakMap(..)</code>) with the function object as the key, and the extra information as the value.</p> <pre><code>extraInfo = new Map();\nextraInfo.set(help,\"this is some important information\");\n// later:\nextraInfo.get(help);   // \"this is some important information\"\n</code></pre>"},{"location":"objects-classes/ch2/#object-characteristics","title":"Object Characteristics","text":"<p>In addition to defining behaviors for specific properties, certain behaviors are configurable across the whole object:</p> <ul> <li>extensible</li> <li>sealed</li> <li>frozen</li> </ul>"},{"location":"objects-classes/ch2/#extensible","title":"Extensible","text":"<p>Extensibility refers to whether an object can have new properties defined/added to it. By default, all objects are extensible, but you can change shut off extensibility for an object:</p> <pre><code>myObj = {\nfavoriteNumber: 42\n};\nmyObj.firstName = \"Kyle\";                  // works fine\nObject.preventExtensions(myObj);\nmyObj.nicknames = [ \"getify\", \"ydkjs\" ];   // fails\nmyObj.favoriteNumber = 123;                // works fine\n</code></pre> <p>In non-strict-mode, an assignment that creates a new property will silently fail, whereas in strict mode an exception will be thrown.</p>"},{"location":"objects-classes/ch2/#sealed","title":"Sealed","text":"<p>// TODO</p>"},{"location":"objects-classes/ch2/#frozen","title":"Frozen","text":"<p>// TODO</p>"},{"location":"objects-classes/ch2/#extending-the-mop","title":"Extending The MOP","text":"<p>As mentioned at the start of this chapter, objects in JS behave according to a set of rules referred to as the Metaobject Protocol (MOP)1. Now that we understand more fully how objects work by default, we want to turn our attention to how we can hook into some of these default behaviors and override/customize them.</p> <p>// TODO</p>"},{"location":"objects-classes/ch2/#prototype-chain","title":"<code>[[Prototype]]</code> Chain","text":"<p>One of the most important, but least obvious, characteristics of an object (part of the MOP) is referred to as its \"prototype chain\"; the official JS specification notation is <code>[[Prototype]]</code>. Make sure not to confuse this <code>[[Prototype]]</code> with a public property named <code>prototype</code>. Despite the naming, these are distinct concepts.</p> <p>The <code>[[Prototype]]</code> is an internal linkage that an object gets by default when its created, pointing to another object. This linkage is a hidden, often subtle characteristic of an object, but it has profound impacts on how interactions with the object will play out. It's referred to as a \"chain\" because one object links to another, which in turn links to another, ... and so on. There is an end or top to this chain, where the linkage stops and there's no further to go. More on that shortly.</p> <p>We already saw several implications of <code>[[Prototype]]</code> linkage in Chapter 1. For example, by default, all objects are <code>[[Prototype]]</code>-linked to the built-in object named <code>Object.prototype</code>.</p> WARNING: That <code>Object.prototype</code> name itself can be confusing, since it uses a property called <code>prototype</code>. How are <code>[[Prototype]]</code> and <code>prototype</code> related!? Put such questions/confusion on pause for a bit, as we'll come back an explain the differences between <code>[[Prototype]]</code> and <code>prototype</code> later in this chapter. For the moment, just assume the presence of this important but weirdly named built-in object, <code>Object.prototype</code>. <p>Let's consider some code:</p> <pre><code>myObj = {\nfavoriteNumber: 42\n};\n</code></pre> <p>That should look familiar from Chapter 1. But what you don't see in this code is that the object there was automatically linked (via its internal <code>[[Prototype]]</code>) to that automatically built-in, but weirdly named, <code>Object.prototype</code> object.</p> <p>When we do things like:</p> <pre><code>myObj.toString();                             // \"[object Object]\"\nmyObj.hasOwnProperty(\"favoriteNumber\");   // true\n</code></pre> <p>We're taking advantage of this internal <code>[[Prototype]]</code> linkage, without really realizing it. Since <code>myObj</code> does not have <code>toString</code> or <code>hasOwnProperty</code> properties defined on it, those property accesses actually end up DELEGATING the access to continue its lookup along the <code>[[Prototype]]</code> chain.</p> <p>Since <code>myObj</code> is <code>[[Prototype]]</code>-linked to the object named <code>Object.prototype</code>, the lookup for <code>toString</code> and <code>hasOwnProperty</code> properties continues on that object; and indeed, these methods are found there!</p> <p>The ability for <code>myObj.toString</code> to access the <code>toString</code> property even though it doesn't actually have it, is commonly referred to as \"inheritance\", or more specifically, \"prototypal inheritance\". The <code>toString</code> and <code>hasOwnProperty</code> properties, along with many others, are said to be \"inherited properties\" on <code>myObj</code>.</p> NOTE: I have a lot of frustrations with the usage of the word \"inheritance\" here -- it should be called \"delegation\"! --  but that's what most people refer to it as, so we'll begrudgingly comply and use that same terminology for now (albeit under protest, with \" quotes). I'll save my objections for an appendix of this book. <p><code>Object.prototype</code> has several built-in properties and methods, all of which are \"inherited\" by any object that is <code>[[Prototype]]</code>-linked, either directly or indirectly through another object's linkage, to <code>Object.prototype</code>.</p> <p>Some common \"inherited\" properties from <code>Object.prototype</code> include:</p> <ul> <li><code>constructor</code></li> <li><code>__proto__</code></li> <li><code>toString()</code></li> <li><code>valueOf()</code></li> <li><code>hasOwnProperty(..)</code></li> <li><code>isPrototypeOf(..)</code></li> </ul> <p>Recall <code>hasOwnProperty(..)</code>, which we saw earlier gives us a boolean check for whether a certain property (by string name) is owned by an object:</p> <pre><code>myObj = {\nfavoriteNumber: 42\n};\nmyObj.hasOwnProperty(\"favoriteNumber\");   // true\n</code></pre> <p>It's always been considered somewhat unfortunate (semantic organization, naming conflicts, etc) that such an important utility as <code>hasOwnProperty(..)</code> was included on the Object <code>[[Prototype]]</code> chain as an instance method, instead of being defined as a static utility.</p> <p>As of ES2022, JS has finally added the static version of this utility: <code>Object.hasOwn(..)</code>.</p> <pre><code>myObj = {\nfavoriteNumber: 42\n};\nObject.hasOwn(myObj,\"favoriteNumber\");   // true\n</code></pre> <p>This form is now considered the more preferable and robust option, and the instance method (<code>hasOwnProperty(..)</code>) form should now generally be avoided.</p> <p>Somewhat unfortunately and inconsisently, there's not (yet, as of time of writing) corresponding static utilities, like <code>Object.isPrototype(..)</code> (instead of the instance method <code>isPrototypeOf(..)</code>). But at least <code>Object.hasOwn(..)</code> exists, so that's progress.</p>"},{"location":"objects-classes/ch2/#creating-an-object-with-a-different-prototype","title":"Creating An Object With A Different <code>[[Prototype]]</code>","text":"<p>By default, any object you create in your programs will be <code>[[Prototype]]</code>-linked to that <code>Object.prototype</code> object. However, you can create an object with a different linkage like this:</p> <pre><code>myObj = Object.create(differentObj);\n</code></pre> <p>The <code>Object.create(..)</code> method takes its first argument as the value to set for the newly created object's <code>[[Prototype]]</code>.</p> <p>One downside to this approach is that you aren't using the <code>{ .. }</code> literal syntax, so you don't initially define any contents for <code>myObj</code>. You typically then have to define properties one-by-one, using <code>=</code>.</p> NOTE: The second, optional argument to <code>Object.create(..)</code> is -- like the second argument to <code>Object.defineProperties(..)</code> as discussed earlier -- an object with properties that hold descriptors to initially define the new object with. In practice out in the wild, this form is rarely used, likely because it's more awkward to specify full descriptors instead of just name/value pairs. But it may come in handy in some limited cases. <p>Alternately, but less preferably, you can use the <code>{ .. }</code> literal syntax along with a special (and strange looking!) property:</p> <pre><code>myObj = {\n__proto__: differentObj,\n// .. the rest of the object definition\n};\n</code></pre> WARNING: The strange looking <code>__proto__</code> property has been in some JS engines for more than 20 years, but was only standardized in JS as of ES6 (in 2015). Even still, it was added in Appendix B of the specification2, which lists features that TC39 begrudgingly includes because they exist popularly in various browser-based JS engines and therefore are a de-facto reality even if they didn't originate with TC39. This feature is thus \"guaranteed\" by the spec to exist in all conforming browser-based JS engines, but is not necessarily guaranteed to work in other independent JS engines. Node.js uses the JS engine (v8) from the Chrome browser, so Node.js gets <code>__proto__</code> by default/accident. Be careful when using <code>__proto__</code> to be aware of all the JS engine environments your code will run in. <p>Whether you use <code>Object.create(..)</code> or <code>__proto__</code>, the created object in question will usually be <code>[[Prototype]]</code>-linked to a different object than the default <code>Object.prototype</code>.</p>"},{"location":"objects-classes/ch2/#empty-prototype-linkage","title":"Empty <code>[[Prototype]]</code> Linkage","text":"<p>We mentioned above that the <code>[[Prototype]]</code> chain has to stop somewhere, so as to have lookups not continue forever. <code>Object.prototype</code> is typically the top/end of every <code>[[Prototype]]</code> chain, as its own <code>[[Prototype]]</code> is <code>null</code>, and therefore there's nowhere else to continue looking.</p> <p>However, you can also define objects with their own <code>null</code> value for <code>[[Prototype]]</code>, such as:</p> <pre><code>emptyObj = Object.create(null);\n// or: emptyObj = { __proto__: null }\nemptyObj.toString;   // undefined\n</code></pre> <p>It can be quite useful to create an object with no <code>[[Prototype]]</code> linkage to <code>Object.prototype</code>. For example, as mentioned in Chapter 1, the <code>in</code> and <code>for..in</code> constructs will consult the <code>[[Prototype]]</code> chain for inherited properties. But this may be undesirable, as you may not want something like <code>\"toString\" in myObj</code> to resolve successfully.</p> <p>Moreover, an object with an empty <code>[[Prototype]]</code> is safe from any accidental \"inheritance\" collision between its own property names and the ones it \"inherits\" from elsewhere. These types of (useful!) objects are sometimes referred to in popular parlance as \"dictionary objects\".</p>"},{"location":"objects-classes/ch2/#prototype-vs-prototype","title":"<code>[[Prototype]]</code> vs <code>prototype</code>","text":"<p>Notice that public property name <code>prototype</code> in the name/location of this special object, <code>Object.prototype</code>? What's that all about?</p> <p><code>Object</code> is the <code>Object(..)</code> function; by default, all functions (which are themselves objects!) have such a <code>prototype</code> property on them, pointing at an object.</p> <p>Any here's where the name conflict between <code>[[Prototype]]</code> and <code>prototype</code> really bites us. The <code>prototype</code> property on a function doesn't define any linkage that the function itself experiences. Indeed, functions (as objects) have their own internal <code>[[Prototype]]</code> linkage somewhere else -- more on that in a second.</p> <p>Rather, the <code>prototype</code> property on a function refers to an object that should be linked TO by any other object that is created when calling that function with the <code>new</code> keyword:</p> <pre><code>myObj = {};\n// is basically the same as:\nmyObj = new Object();\n</code></pre> <p>Since the <code>{ .. }</code> object literal syntax is essentially the same as a <code>new Object()</code> call, the built-in object named/located at <code>Object.prototype</code> is used as the internal <code>[[Prototype]]</code> value for the new object we create and name <code>myObj</code>.</p> <p>Phew! Talk about a topic made significantly more confusing just because of the name overlap between <code>[[Prototype]]</code> and <code>prototype</code>!</p> <p>But where do functions themselves (as objects!) link to, <code>[[Prototype]]</code> wise? They link to <code>Function.prototype</code>, yet another built-in object, located at the <code>prototype</code> property on the <code>Function(..)</code> function.</p> <p>In other words, you can think of functions themselves as having been \"created\" by a <code>new Function(..)</code> call, and then <code>[[Prototype]]</code>-linked to the <code>Function.prototype</code> object. This object contains properties/methods all functions \"inherit\" by default, such as <code>toString()</code> (to string serialize the source code of a function) and <code>call(..)</code> / <code>apply(..)</code> / <code>bind(..)</code> (we'll explain these later in this book).</p>"},{"location":"objects-classes/ch2/#objects-behavior","title":"Objects Behavior","text":"<p>Properties on objects are internally defined and controlled by a \"descriptor\" metaobject, which includes attributes such as <code>value</code> (the property's present value) and <code>enumerable</code> (a boolean controlling whether the property is included in enumerable-only listings of properties/property names).</p> <p>The way object and their properties work in JS is referred to as the \"metaobject protocol\" (MOP)1. We can control the precise behavior of properties via <code>Object.defineProperty(..)</code>, as well as object-wide behaviors with <code>Object.freeze(..)</code>. But even more powerfully, we can hook into and override certain default behaviors on objects using special pre-defined Symbols.</p> <p>Prototypes are internal linkages between objects that allow property or method access against one object -- if the property/method requested is absent -- to be handled by \"delegating\" that access lookup to another object. When the delegation involves a method, the context for the method to run in is shared from the initial object to the target object via the <code>this</code> keyword.</p> <ol> <li> <p>\"Metaobject\", Wikipedia; https://en.wikipedia.org/wiki/Metaobject ; Accessed July 2022.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>\"Appendix B: Additional ECMAScript Features for Web Browsers\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-additional-ecmascript-features-for-web-browsers ; Accessed July 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"objects-classes/ch3/","title":"Chapter 3: Classy Objects","text":"NOTE: Work in progress <p>The class-design pattern generally entails defining a type of thing (class), including data (members) and behaviors (methods), and then creating one or more concrete instances of this class definition as actual objects that can interact and perform tasks. Moreover, class-orientation allows declaring a relationship between two or more classes, through what's called \"inheritance\", to derive new and augmented \"subclasses\" that mix-n-match and even re-define behaviors.</p> <p>Prior to ES6 (2015), JS developers mimicked aspects of class-oriented (aka \"object-oriented\") design using plain functions and objects, along with the <code>[[Prototype]]</code> mechanism (as explained in the previous chapter) -- so called \"prototypal classes\".</p> <p>But to many developers joy and relief, ES6 introduced dedicated syntax, including the <code>class</code> and <code>extends</code> keywords, to express class-oriented design more declaratively.</p> <p>At the time of ES6's <code>class</code> being introduced, this new dedicated syntax was almost entirely just syntactic sugar to make class definitions more convenient and readable. However, in the many years since ES6, <code>class</code> has matured and grown into its own first class feature mechanism, accruing a significant amount of dedicated syntax and complex behaviors that far surpass the pre-ES6 \"prototypal class\" capabilities.</p> <p>Even though <code>class</code> now bears almost no resemblance to older \"prototypal class\" code style, the JS engine is still just wiring up objects to each other through the existing <code>[[Prototype]]</code> mechanism. In other words, <code>class</code> is not its own separate pillar of the language (as <code>[[Prototype]]</code> is), but more like the fancy, decorative Capital that tops the pillar/column.</p> <p>That said, since <code>class</code> style code has now replaced virtually all previous \"prototypal class\" coding, the main text here focuses only on <code>class</code> and its various particulars. For historical purposes, we'll briefly cover the old \"prototypal class\" style in an appendix.</p>"},{"location":"objects-classes/ch3/#when-should-i-class-orient-my-code","title":"When Should I Class-Orient My Code?","text":"<p>Class-orientation is a design pattern, which means it's a choice for how you organize the information and behavior in your program. It has pros and cons. It's not a universal solution for all tasks.</p> <p>So how do you know when you should use classes?</p> <p>In a theoretical sense, class-orientation is a way of dividing up the business domain of a program into one or more pieces that can each be defined by an \"is-a\" classification: grouping a thing into the set (or sets) of characteristics that thing shares with other similar things. You would say \"X is a Y\", meaning X has (at least) all the characteristics of a thing of kind Y.</p> <p>For example, consider computers. We could say a computer is electrical, since it uses electrical current (voltage, amps, etc) as power. It's furthermore electronic, because it manipulates the electrical current beyond simply routing electrons around (electrical/magnetic fields), creating a meaningful circuit to manipulate the current into performing more complex tasks. By contrast, a basic desk lamp is electrical, but not really electronic.</p> <p>We could thus define a class <code>Electrical</code> to describe what electrical devices need and can do. We could then define a further class <code>Electronic</code>, and define that in addition to being electrical, <code>Electronic</code> things manipulate electricity to create more specialized outcomes.</p> <p>Here's where class-orientation starts to shine. Rather than re-define all the <code>Electrical</code> characteristics in the <code>Electronic</code> class, we can define <code>Electronic</code> in such a way that it \"shares\" or \"inherits\" those characteristics from <code>Electrical</code>, and then augments/redefines the unique behaviors that make a device electronic. This relationship between the two classes -- called \"inheritance\" -- is a key aspect of class-orientation.</p> <p>So class-orientation is a way of thinking about the entities our program needs, and classifying them into groupings based on their characteristics (what information they hold, what operations can be performed on that data), and defining the relationships between the different grouping of characteristics.</p> <p>But moving from the theoretical into in a bit more pragmatic perspective: if your program needs to hold and use multiple collections (instances) of alike data/behavior at once, you may benefit from class-orientation.</p>"},{"location":"objects-classes/ch3/#time-for-an-example","title":"Time For An Example","text":"<p>Here's a short illustration.</p> <p>A couple of decades ago, right after I had gone through nearly all of a Computer Science degree in college, I found myself sitting in my first professional software developer job. I was tasked with building, all by myself, a timesheet and payroll tracking system. I built the backend in PHP (using MySQL for the DB) and used JS for the interface (early as it was in its maturity way back around the turn of the century).</p> <p>Since my CS degree had emphasized class-orientation heavily throughout my courses, I was eager to put all that theory to work. For my program's design, I defined the concept of a \"timesheet\" entity as a collection of 2-3 \"week\" entities, and each \"week\" as a collection of 5-7 \"day\" entities, and each \"day\" as a collection of \"task\" entities.</p> <p>If I wanted to know how many hours were logged into a timesheet instance, I could call a <code>totalTime()</code> operation on that instance. The timesheet defined this operation by looping over its collection of weeks, calling <code>totalTime()</code> on each of them and summing the values. Each week did the same for all its days, and each day did the same for all its tasks.</p> <p>The notion being illustrated here, one of the fundamentals of design patterns like class-orientation, is called encapsulation. Each entity level encapsulated (e.g., controlled, hid, abstracted) internal details (data and behavior) while presenting a useful external interface.</p> <p>But encapsulation alone isn't a sufficient justification for class-orientation. Other design patterns offer sufficient encapsulation.</p> <p>How did my class design take advantage of inheritance? I had a base class that defined a set of operations like <code>totalTime()</code>, and each of my entity class types extended/subclassed this base class. That meant that each of them inherited this summation-of-total-time capability, but where each of them applied their own extensions and definitions for the internal details of how to do that work.</p> <p>There's yet another aspect of the design pattern at play, which is composition: each entity was defined as a collection of other entities.</p>"},{"location":"objects-classes/ch3/#single-vs-multiple","title":"Single vs Multiple","text":"<p>I mentioned above that a pragmatic way of deciding if you need class-orientation is if your program is going to have multiple instances of a single kind/type of behavior (aka, \"class\"). In the timesheet example, we had 4 classes: Timesheet, Week, Day, and Task. But for each class, we had multiple instances of each at once.</p> <p>Had we instead only needed a single instance of a class, like just one <code>Computer</code> thing that was an instance of the <code>Electronic</code> class, which was a subclass of the <code>Electrical</code> class, then class-orientation may not offer quite as much benefit. In particular, if the program doesn't need to create an instance of the <code>Electrical</code> class, then there's no particular benefit to separating <code>Electrical</code> from <code>Electronic</code>, so we aren't really getting any help from the inheritance aspect of class-orientation.</p> <p>So, if you find yourself designing a program by dividing up a business problem domain into different \"classes\" of entities, but in the actual code of the program you are only ever need one concrete thing of one kind/definition of behavior (aka, \"class\"), you might very well not actually need class-orientation. There are other design patterns which may be a more efficient match to your effort.</p> <p>But if you find yourself wanting to define classes, and subclasses which inherit from them, and if you're going to be instantiating one or more of those classes multiple times, then class-orientation is a good candidate. And to do class-orientation in JS, you're going to need the <code>class</code> keyword.</p>"},{"location":"objects-classes/ch3/#keep-it-classy","title":"Keep It <code>class</code>y","text":"<p><code>class</code> defines either a declaration or expression for a class. As a declaration, a class definition appears in a statement position and looks like this:</p> <pre><code>class Point2d {\n// ..\n}\n</code></pre> <p>As an expression, a class definition appears in a value position and can either have a name or be anonymous:</p> <pre><code>// named class expression\nconst pointClass = class Point2d {\n// ..\n};\n// anonymous class expression\nconst anotherClass = class {\n// ..\n};\n</code></pre> <p>The contents of a <code>class</code> body typically include one or more method definitions:</p> <pre><code>class Point2d {\nsetX(x) {\n// ..\n}\nsetY(y) {\n// ..\n}\n}\n</code></pre> <p>Inside a <code>class</code> body, methods are defined without the <code>function</code> keyword, and there's no <code>,</code> or <code>;</code> separators between the method definitions.</p> NOTE: Inside a <code>class</code> block, all code runs in strict-mode even without the <code>\"use strict\"</code> pragma present in the file or its functions. In particular, this impacts the <code>this</code> behavior for function calls, as explained in Chapter 4."},{"location":"objects-classes/ch3/#the-constructor","title":"The Constructor","text":"<p>One special method that all classes have is called a \"constructor\". If omitted, there's a default empty constructor assumed in the definition.</p> <p>The constructor is invoked any time a <code>new</code> instance of the class is created:</p> <pre><code>class Point2d {\nconstructor() {\nconsole.log(\"Here's your new instance!\");\n}\n}\nvar point = new Point2d();\n// Here's your new instance!\n</code></pre> <p>Even though the syntax implies a function actually named <code>constructor</code> exists, JS defines a function as specified, but with the name of the class (<code>Point2d</code> above):</p> <pre><code>typeof Point2d;       // \"function\"\n</code></pre> <p>It's not just a regular function, though; this special kind of function behaves a bit differently:</p> <pre><code>Point2d.toString();\n// class Point2d {\n//   ..\n// }\nPoint2d();\n// TypeError: Class constructor Point2d cannot\n// be invoked without 'new'\nPoint2d.call({});\n// TypeError: Class constructor Point2d cannot\n// be invoked without 'new'\n</code></pre> <p>You can construct as many different instances of a class as you need:</p> <pre><code>var one = new Point2d();\nvar two = new Point2d();\nvar three = new Point2d();\n</code></pre> <p>Each of <code>one</code>, <code>two</code>, and <code>three</code> here are objects that are independent instances of the <code>Point2d</code> class.</p> NOTE: Each of the <code>one</code>, <code>two</code>, and <code>three</code> objects have a <code>[[Prototype]]</code> linkage to the <code>Point2d.prototype</code> object (see Chapter 2). In this code, <code>Point2d</code> is both a <code>class</code> definition and the constructor function of the same name. <p>If you add a property to the object <code>one</code>:</p> <pre><code>one.value = 42;\n</code></pre> <p>That property now exists only on <code>one</code>, and does not exist in any way that the independent <code>two</code> or <code>three</code> objects can access:</p> <pre><code>two.value;      // undefined\nthree.value;    // undefined\n</code></pre>"},{"location":"objects-classes/ch3/#class-methods","title":"Class Methods","text":"<p>As shown above, a class definition can include one or more method definitions:</p> <pre><code>class Point2d {\nconstructor() {\nconsole.log(\"Here's your new instance!\");\n}\nsetX(x) {\nconsole.log(`Setting x to: ${x}`);\n// ..\n}\n}\nvar point = new Point2d();\npoint.setX(3);\n// Setting x to: 3\n</code></pre> <p>The <code>setX</code> property (method) looks like it exists on (is owned by) the <code>point</code> object here. But that's a mirage. Each class method is added to the <code>prototype</code>object, a property of the constructor function.</p> <p>So, <code>setX(..)</code> only exists as <code>Point2d.prototype.setX</code>. Since <code>point</code> is <code>[[Prototype]]</code> linked to <code>Point2d.prototype</code> (see Chapter 2) via the <code>new</code> keyword instantiation, the <code>point.setX(..)</code> reference traverses the <code>[[Prototype]]</code> chain and finds the method to execute.</p> <p>Class methods should only be invoked via an instance; <code>Point2d.setX(..)</code> doesn't work because there is no such property. You could invoke <code>Point2d.prototype.setX(..)</code>, but that's not generally proper/advised in standard class-oriented coding. Always access class methods via the instances.</p>"},{"location":"objects-classes/ch3/#class-instance-this","title":"Class Instance <code>this</code>","text":"<p>We will cover the <code>this</code> keyword in much more detail in a subsequent chapter. But as it relates to class-oriented code, the <code>this</code> keyword generally refers to the current instance that is the context of any method invocation.</p> <p>In the constructor, as well as any methods, you can use <code>this.</code> to either add or access properties on the current instance:</p> <pre><code>class Point2d {\nconstructor(x,y) {\n// add properties to the current instance\nthis.x = x;\nthis.y = y;\n}\ntoString() {\n// access the properties from the current instance\nconsole.log(`(${this.x},${this.y})`);\n}\n}\nvar point = new Point2d(3,4);\npoint.x;                // 3\npoint.y;                // 4\npoint.toString();       // (3,4)\n</code></pre> <p>Any properties not holding function values, which are added to a class instance (usually via the constructor), are referred to as members, as opposed to the term methods for executable functions.</p> <p>While the <code>point.toString()</code> method is running, its <code>this</code> reference is pointing at the same object that <code>point</code> references. That's why both <code>point.x</code> and <code>this.x</code> reveal the same <code>3</code> value that the constructor set with its <code>this.x = x</code> operation.</p>"},{"location":"objects-classes/ch3/#public-fields","title":"Public Fields","text":"<p>Instead of defining a class instance member imperatively via <code>this.</code> in the constructor or a method, classes can declaratively define fields in the <code>class</code> body, which correspond directly to members that will be created on each instance:</p> <pre><code>class Point2d {\n// these are public fields\nx = 0\ny = 0\nconstructor(x,y) {\n// set properties (fields) on the current instance\nthis.x = x;\nthis.y = y;\n}\ntoString() {\n// access the properties from the current instance\nconsole.log(`(${this.x},${this.y})`);\n}\n}\n</code></pre> <p>Public fields can have a value initialization, as shown above, but that's not required. If you don't initialize a field in the class definition, you almost always should initialize it in the constructor.</p> <p>Fields can also reference each other, via natural <code>this.</code> access syntax:</p> <pre><code>class Point3d {\n// these are public fields\nx\ny = 4\nz = this.y * 5\n// ..\n}\n</code></pre> TIP: You can mostly think of public field declarations as if they appear at the top of the <code>constructor(..)</code>, each prefixed with an implied <code>this.</code> that you get to omit in the declarative <code>class</code> body form. But, there's a catch! See \"That's Super!\" later for more information about it. <p>Just like computed property names (see Chapter 1), field names can be computed:</p> <pre><code>var coordName = \"x\";\nclass Point2d {\n// computed public field\n[coordName.toUpperCase()] = 42\n// ..\n}\nvar point = new Point2d(3,4);\npoint.x;        // 3\npoint.y;        // 4\npoint.X;        // 42\n</code></pre>"},{"location":"objects-classes/ch3/#avoid-this","title":"Avoid This","text":"<p>One pattern that has emerged and grown quite popular, but which I firmly believe is an anti-pattern for <code>class</code>, looks like the following:</p> <pre><code>class Point2d {\nx = null\ny = null\ngetDoubleX = () =&gt; this.x * 2\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\n}\ntoString() { /* .. */ }\n}\nvar point = new Point2d(3,4);\npoint.getDoubleX();    // 6\n</code></pre> <p>See the field holding an <code>=&gt;</code> arrow function? I say this is a no-no. But why? Let's unwind what's going on.</p> <p>First, why do this? Because JS developers seem to be perpetually frustrated by the dynamic <code>this</code> binding rules (see Chapter 4), so they force a <code>this</code> binding via the <code>=&gt;</code> arrow function. That way, no matter how <code>getDoubleX()</code> is invoked, it's always <code>this</code>-bound to the particular instance. That's an understandable convenience to desire, but... it betrays the very nature of the <code>this</code> / <code>[[Prototype]]</code> pillar of the language. How?</p> <p>Let's consider the equivalent code to the previous snippet:</p> <pre><code>class Point2d {\nconstructor(x,y) {\nthis.x = null;\nthis.y = null;\nthis.getDoubleX = () =&gt; this.x * 2;\nthis.x = x;\nthis.y = y;\n}\ntoString() { /* .. */ }\n}\nvar point = new Point2d(3,4);\npoint.getDoubleX();    // 6\n</code></pre> <p>Can you spot the problem? Look closely. I'll wait.</p> <p>...</p> <p>We've made it clear repeatedly so far that <code>class</code> definitions put their methods on the class constructor's <code>prototype</code> object -- that's where they belong! -- such that there's just one of each function and it's inherited (shared) by all instances. That's what will happen with <code>toString()</code> in the above snippet.</p> <p>But what about <code>getDoubleX()</code>? That's essentially a class method, but it won't be handled by JS quite the same as <code>toString()</code> will. Consider:</p> <pre><code>Object.hasOwn(point,\"x\");               // true -- good\nObject.hasOwn(point,\"toString\");        // false -- good\nObject.hasOwn(point,\"getDoubleX\");      // true -- oops :(\n</code></pre> <p>You see now? By defining a function value and attaching it as a field/member property, we're losing the shared prototypal method'ness of the function, and it becomes just like any per-instance property. That means we're creating a new function property for each instance, rather than it being created just once on the class constructor's <code>prototype</code>.</p> <p>That's wasteful in performance and memory, even if by a tiny bit. That alone should be enough to avoid it.</p> <p>But I would argue that way more importantly, what you've done with this pattern is invalidate the very reason why using <code>class</code> and <code>this</code>-aware methods is even remotely useful/powerful!</p> <p>If you go to all the trouble to define class methods with <code>this.</code> references throughout them, but then you lock/bind most or all of those methods to a specific object instance, you've basically travelled all the way around the world just to go next door.</p> <p>If all you want are function(s) that are statically fixed to a particular \"context\", and don't need any dynamicism or sharing, what you want is... closure. And you're in luck: I wrote a whole book in this series (\"Scope &amp; Closures\") on how to use closure so functions remember/access their statically defined scope (aka \"context\"). That's a way more appropriate, and simpler to code, approach to get what you're after.</p> <p>Don't abuse/misuse <code>class</code> and turn it into a over-hyped, glorified collection of closure.</p> <p>To be clear, I'm not saying: never use <code>=&gt;</code> arrow functions inside classes.</p> <p>I am saying: never attach an <code>=&gt;</code> arrow function as an instance property in place of a dynamic prototypal class method, either out of mindless habit, or laziness in typing fewer characters, or misguided <code>this</code>-binding convenience.</p> <p>In a subsequent chapter, we'll dive deep into how to understand and properly leverage the full power of the dynamic <code>this</code> mechanism.</p>"},{"location":"objects-classes/ch3/#class-extension","title":"Class Extension","text":"<p>The way to unlock the power of class inheritance is through the <code>extends</code> keyword, which defines a relationship between two classes:</p> <pre><code>class Point2d {\nx = 3\ny = 4\ngetX() {\nreturn this.x;\n}\n}\nclass Point3d extends Point2d {\nx = 21\ny = 10\nz = 5\nprintDoubleX() {\nconsole.log(`double x: ${this.getX() * 2}`);\n}\n}\nvar point = new Point2d();\npoint.getX();                   // 3\nvar anotherPoint = new Point3d();\nanotherPoint.getX();            // 21\nanotherPoint.printDoubleX();    // double x: 42\n</code></pre> <p>Take a few moments to re-read that code snippet and make sure you fully understand what's happening.</p> <p>The base class <code>Point2d</code> defines fields (members) called <code>x</code> and <code>y</code>, and gives them the initial values <code>3</code> and <code>4</code>, respectively. It also defines a <code>getX()</code> method that accesses this <code>x</code> instance member and returns it. We see that behavior illustrated in the <code>point.getX()</code> method call.</p> <p>But the <code>Point3d</code> class extends <code>Point2d</code>, making <code>Point3d</code> a derived-class, child-class, or (most commonly) subclass. In <code>Point3d</code>, the same <code>x</code> property that's inherited from <code>Point2d</code> is re-initialized with a different <code>21</code> value, as is the <code>y</code> overriden to value from <code>4</code>, to <code>10</code>.</p> <p>It also adds a new <code>z</code> field/member method, as well as a <code>printDoubleX()</code> method, which itself calls <code>this.getX()</code>.</p> <p>When <code>anotherPoint.printDoubleX()</code> is invoked, the inherited <code>this.getX()</code> is thus invoked, and that method makes reference to <code>this.x</code>. Since <code>this</code> is pointing at the class instance (aka, <code>anotherPoint</code>), the value it finds is now <code>21</code> (instead of <code>3</code> from the <code>point</code> object's <code>x</code> member).</p>"},{"location":"objects-classes/ch3/#extending-expressions","title":"Extending Expressions","text":"<p>// TODO: cover <code>class Foo extends ..</code> where <code>..</code> is an expression, not a class-name</p>"},{"location":"objects-classes/ch3/#overriding-methods","title":"Overriding Methods","text":"<p>In addition to overriding a field/member in a subclass, you can also override (redefine) a method:</p> <pre><code>class Point2d {\nx = 3\ny = 4\ngetX() {\nreturn this.x;\n}\n}\nclass Point3d extends Point2d {\nx = 21\ny = 10\nz = 5\ngetX() {\nreturn this.x * 2;\n}\nprintX() {\nconsole.log(`double x: ${this.getX()}`);\n}\n}\nvar point = new Point3d();\npoint.printX();       // double x: 42\n</code></pre> <p>The <code>Point3d</code> subclass overrides the inherited <code>getX()</code> method to give it different behavior. However, you can still instantiate the base <code>Point2d</code> class, which would then give an object that uses the original (<code>return this.x;</code>) definition for <code>getX()</code>.</p> <p>If you want to access an inherited method from a subclass even if it's been overriden, you can use <code>super</code> instead of <code>this</code>:</p> <pre><code>class Point2d {\nx = 3\ny = 4\ngetX() {\nreturn this.x;\n}\n}\nclass Point3d extends Point2d {\nx = 21\ny = 10\nz = 5\ngetX() {\nreturn this.x * 2;\n}\nprintX() {\nconsole.log(`x: ${super.getX()}`);\n}\n}\nvar point = new Point3d();\npoint.printX();       // x: 21\n</code></pre> <p>The ability for methods of the same name, at different levels of the inheritance hierarchy, to exhibit different behavior when either accessed directly, or relatively with <code>super</code>, is called method polymorphism. It's a very powerful part of class-orientation, when used appropriately.</p>"},{"location":"objects-classes/ch3/#thats-super","title":"That's Super!","text":"<p>In addition to a subclass method accessing an inherited method definition (even if overriden on the subclass) via <code>super.</code> reference, a subclass constructor must manually invoke the inherited base class constructor via <code>super(..)</code> function invocation:</p> <pre><code>class Point2d {\nx\ny\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\n}\n}\nclass Point3d extends Point2d {\nz\nconstructor(x,y,z) {\nsuper(x,y);\nthis.z = z;\n}\ntoString() {\nconsole.log(`(${this.x},${this.y},${this.z})`);\n}\n}\nvar point = new Point3d(3,4,5);\npoint.toString();       // (3,4,5)\n</code></pre> WARNING: An explicitly defined subclass constructor must call <code>super(..)</code> to run the inherited class's initialization, and that must occur before the subclass constructor makes any references to <code>this</code> or finishes/returns. Otherwise, a runtime exception will be thrown when that subclass constructor is invoked (via <code>new</code>). If you omit the subclass constructor, the default constructor automatically -- thankfully! -- invokes <code>super()</code> for you. <p>One nuance to be aware of: if you define a field (public or private) inside a subclass, and explicitly define a <code>constructor(..)</code> for this subclass, the field initializations will be processed not at the top of the constructor, but between the <code>super(..)</code> call and any subsequent code in the constructor.</p> <p>Pay close attention to the order of console messages here:</p> <pre><code>class Point2d {\nx\ny\nconstructor(x,y) {\nconsole.log(\"Running Point2d(..) constructor\");\nthis.x = x;\nthis.y = y;\n}\n}\nclass Point3d extends Point2d {\nz = console.log(\"Initializing field 'z'\")\nconstructor(x,y,z) {\nconsole.log(\"Running Point3d(..) constructor\");\nsuper(x,y);\nconsole.log(`Setting instance property 'z' to ${z}`);\nthis.z = z;\n}\ntoString() {\nconsole.log(`(${this.x},${this.y},${this.z})`);\n}\n}\nvar point = new Point3d(3,4,5);\n// Running Point3d(..) constructor\n// Running Point2d(..) constructor\n// Initializing field 'z'\n// Setting instance property 'z' to 5\n</code></pre> <p>As the console messages illustrate, the <code>z = ..</code> field initialization happens immediately after the <code>super(x,y)</code> call, before the <code>console.log(`Setting instance...`)</code> is executed. Perhaps think of it like the field initializations attached to the end of the <code>super(..)</code> call, so they run before anything else in the constructor does.</p>"},{"location":"objects-classes/ch3/#which-class","title":"Which Class?","text":"<p>You may need to determine in a constructor if that class is being instantiated directly, or being instantiated from a subclass with a <code>super()</code> call. We can use a special \"pseudo property\" <code>new.target</code>:</p> <pre><code>class Point2d {\n// ..\nconstructor(x,y) {\nif (new.target === Point2) {\nconsole.log(\"Constructing 'Point2d' instance\");\n}\n}\n// ..\n}\nclass Point3d extends Point2d {\n// ..\nconstructor(x,y,z) {\nsuper(x,y);\nif (new.target === Point3d) {\nconsole.log(\"Constructing 'Point3d' instance\");\n}\n}\n// ..\n}\nvar point = new Point2d(3,4);\n// Constructing 'Point2d' instance\nvar anotherPoint = new Point3d(3,4,5);\n// Constructing 'Point3d' instance\n</code></pre>"},{"location":"objects-classes/ch3/#but-which-kind-of-instance","title":"But Which Kind Of Instance?","text":"<p>You may want to introspect a certain object instance to see if it's an instance of a specific class. We do this with the <code>instanceof</code> operator:</p> <pre><code>class Point2d { /* .. */ }\nclass Point3d extends Point2d { /* .. */ }\nvar point = new Point2d(3,4);\npoint instanceof Point2d;           // true\npoint instanceof Point3d;           // false\nvar anotherPoint = new Point3d(3,4,5);\nanotherPoint instanceof Point2d;    // true\nanotherPoint instanceof Point3d;    // true\n</code></pre> <p>It may seem strange to see <code>anotherPoint instanceof Point2d</code> result in <code>true</code>. To understand why better, perhaps it's useful to visualize both <code>[[Prototype]]</code> chains:</p> <pre><code>Point2d.prototype\n        /       \\\n       /         \\\n      /           \\\n  point   Point3d.prototype\n                    \\\n                     \\\n                      \\\n                    anotherPoint\n</code></pre> <p>The <code>instanceof</code> operator doesn't just look at the current object, but rather traverses the entire class inheritance hierarchy (the <code>[[Prototype]]</code> chain) until it finds a match. Thus, <code>anotherPoint</code> is an instance of both <code>Point3d</code> and <code>Point2d</code>.</p> <p>To illustrate this fact a little more obviously, another (less ergonomic) way of going about the same kind of check as <code>instanceof</code> is with the (inherited from <code>Object.prototype</code>) utility, <code>isPrototypeOf(..)</code>:</p> <pre><code>Point2d.prototype.isPrototypeOf(point);             // true\nPoint3d.prototype.isPrototypeOf(point);             // false\nPoint2d.prototype.isPrototypeOf(anotherPoint);      // true\nPoint3d.prototype.isPrototypeOf(anotherPoint);      // true\n</code></pre> <p>This utility makes it a little clearer why both <code>Point2d.prototype.isPrototypeOf(anotherPoint)</code> and <code>anotherPoint instanceof Point2d</code> result in <code>true</code>: the object <code>Point2d.prototype</code> is in the <code>[[Prototype]]</code> chain of <code>anotherPoint</code>.</p> <p>If you instead wanted to check if the object instance was only and directly created by a certain class, check the instance's <code>constructor</code> property.</p> <pre><code>point.constructor === Point2d;          // true\npoint.constructor === Point3d;          // false\nanotherPoint.constructor === Point2d;   // false\nanotherPoint.constructor === Point3d;   // true\n</code></pre> NOTE: The <code>constructor</code> property shown here is not actually present on (owned) the <code>point</code> or <code>anotherPoint</code> instance objects. So where does it come from!? It's on each object's <code>[[Prototype]]</code> linked prototype object: <code>Point2d.prototype.constructor === Point2d</code> and <code>Point3d.prototype.constructor === Point3d</code>."},{"location":"objects-classes/ch3/#inheritance-is-sharing-not-copying","title":"\"Inheritance\" Is Sharing, Not Copying","text":"<p>It may seem as if <code>Point3d</code>, when it <code>extends</code> the <code>Point2d</code> class, is in essence getting a copy of all the behavior defined in <code>Point2d</code>. Moreover, it may seem as if the concrete object instance <code>anotherPoint</code> receives, copied down to it, all the methods from <code>Point3d</code> (and by extension, also from <code>Point2d</code>).</p> <p>However, that's not the correct mental model to use for JS's implementation of class-orientation. Recall this base class and subclass definition, as well as instantiation of <code>anotherPoint</code>:</p> <pre><code>class Point2d {\nx\ny\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\n}\n}\nclass Point3d extends Point2d {\nz\nconstructor(x,y,z) {\nsuper(x,y);\nthis.z = z;\n}\ntoString() {\nconsole.log(`(${this.x},${this.y},${this.z})`);\n}\n}\nvar anotherPoint = new Point3d(3,4,5);\n</code></pre> <p>If you inspect the <code>anotherPoint</code> object, you'll see it only has the <code>x</code>, <code>y</code>, and <code>z</code> properties (instance members) on it, but not the <code>toString()</code> method:</p> <pre><code>Object.hasOwn(anotherPoint,\"x\");                       // true\nObject.hasOwn(anotherPoint,\"y\");                       // true\nObject.hasOwn(anotherPoint,\"z\");                       // true\nObject.hasOwn(anotherPoint,\"toString\");                // false\n</code></pre> <p>Where is that <code>toString()</code> method located? On the prototype object:</p> <pre><code>Object.hasOwn(Point3d.prototype,\"toString\");    // true\n</code></pre> <p>And <code>anotherPoint</code> has access to that method via its <code>[[Prototype]]</code> linkage (see Chapter 2). In other words, the prototype objects share access to their method(s) with the subclass(es) and instance(s). The method(s) stay in place, and are not copied down the inheritance chain.</p> <p>As nice as the <code>class</code> syntax is, don't forget what's really happening under the syntax: JS is just wiring up objects to each other along a <code>[[Prototype]]</code> chain.</p>"},{"location":"objects-classes/ch3/#static-class-behavior","title":"Static Class Behavior","text":"<p>We've so far emphasized two different locations for data or behavior (methods) to reside: on the constructor's prototype, or on the instance. But there's a third option: on the constructor (function object) itself.</p> <p>In a traditional class-oriented system, methods defined on a class are not concrete things you could ever invoke or interact with. You have to instantiate a class to have a concrete object to invoke those methods with. Prototypal languages like JS blur this line a bit: all class-defined methods are \"real\" functions residing on the constructor's prototype, and you could therefore invoke them. But as I asserted earlier, you really should not do so, as this is not how JS assumes you will write your <code>class</code>es, and there are some weird corner-case behaviors you may run into. Best to stay on the narrow path that <code>class</code> lays out for you.</p> <p>Not all behavior that we define and want to associate/organize with a class needs to be aware of an instance. Moreover, sometimes a class needs to publicly define data (like constants) that developers using that class need to access, independent of any instance they may or may not have created.</p> <p>So, how does a class system enable defining such data and behavior that should be available with a class but independent of (unaware of) instantiated objects? Static properties and functions.</p> NOTE: I'll use \"static property\" / \"static function\", rather than \"member\" / \"method\", just so it's clearer that there's a distinction between instance-bound members / instance-aware methods, and non-instance properties and instance-unaware functions. <p>We use the <code>static</code> keyword in our <code>class</code> bodies to distinguish these definitions:</p> <pre><code>class Point2d {\n// class statics\nstatic origin = new Point2d(0,0)\nstatic distance(point1,point2) {\nreturn Math.sqrt(\n((point2.x - point1.x) ** 2) +\n((point2.y - point1.y) ** 2)\n);\n}\n// instance members and methods\nx\ny\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\n}\ntoString() {\nreturn `(${this.x},${this.y})`;\n}\n}\nconsole.log(`Starting point: ${Point2d.origin}`);\n// Starting point: (0,0)\nvar next = new Point2d(3,4);\nconsole.log(`Next point: ${next}`);\n// Next point: (3,4)\nconsole.log(`Distance: ${\nPoint2d.distance( Point2d.origin, next )\n}`);\n// Distance: 5\n</code></pre> <p>The <code>Point2d.origin</code> is a static property, which just so happens to hold a constructed instance of our class. And <code>Point2d.distance(..)</code> is a static function that computes the 2-dimensional cartesian distance between two points.</p> <p>Of course, we could have put these two somewhere other than as <code>static</code>s on the class definition. But since they're directly related to the <code>Point2d</code> class, it makes most sense to organize them there.</p> NOTE: Don't forget that when you use the <code>class</code> syntax, the name <code>Point2d</code> is actually the name of a constructor function that JS defines. So <code>Point2d.origin</code> is just a regular property access on that function object. That's what I meant at the top of this section when I referred to a third location for storing things related to classes; in JS, <code>static</code>s are stored as properties on the constructor function. Take care not to confuse those with properties stored on the constructor's <code>prototype</code> (methods) and properties stored on the instance (members)."},{"location":"objects-classes/ch3/#static-property-initializations","title":"Static Property Initializations","text":"<p>The value in a static initialization (<code>static whatever = ..</code>) can include <code>this</code> references, which refers to the class itself (actually, the constructor) rather than to an instance:</p> <pre><code>class Point2d {\n// class statics\nstatic originX = 0\nstatic originY = 0\nstatic origin = new this(this.originX,this.originY)\n// ..\n}\n</code></pre> WARNING: I don't recommend actually doing the <code>new this(..)</code> trick I've illustrated here. That's just for illustration purposes. The code would read more cleanly with <code>new Point2d(this.originX,this.originY)</code>, so prefer that approach. <p>An important detail not to gloss over: unlike public field initializations, which only happen once an instantiation (with <code>new</code>) occurs, class static initializations always run immediately after the <code>class</code> has been defined. Moreover, the order of static initializations matters; you can think of the statements as if they're being evaluated one at a time.</p> <p>Also like class members, static properties do not have to be initialized (default: <code>undefined</code>), but it's much more common to do so. There's not much utility in declaring a static property with no initialized value (<code>static whatever</code>); Accessing either <code>Point2d.whatever</code> or <code>Point2d.nonExistent</code> would both result in <code>undefined</code>.</p> <p>Recently (in ES2022), the <code>static</code> keyword was extended so it can now define a block inside the <code>class</code> body for more sophisticated initialization of <code>static</code>s:</p> <pre><code>class Point2d {\n// class statics\nstatic origin = new Point2d(0,0)\nstatic distance(point1,point2) {\nreturn Math.sqrt(\n((point2.x - point1.x) ** 2) +\n((point2.y - point1.y) ** 2)\n);\n}\n// static initialization block (as of ES2022)\nstatic {\nlet outerPoint = new Point2d(6,8);\nthis.maxDistance = this.distance(\nthis.origin,\nouterPoint\n);\n}\n// ..\n}\nPoint2d.maxDistance;        // 10\n</code></pre> <p>The <code>let outerPoint = ..</code> here is not a special <code>class</code> feature; it's exactly like a normal <code>let</code> declaration in any normal block of scope (see the \"Scope &amp; Closures\" book of this series). We're merely declaring a localized instance of <code>Point2d</code> assigned to <code>outerPoint</code>, then using that value to derive the assignment to the <code>maxDistance</code> static property.</p> <p>Static initialization blocks are also useful for things like <code>try..catch</code> statements around expression computations.</p>"},{"location":"objects-classes/ch3/#static-inheritance","title":"Static Inheritance","text":"<p>Class statics are inherited by subclasses (obviously, as statics!), can be overriden, and <code>super</code> can be used for base class references (and static function polymorphism), all in much the same way as inheritance works with instance members/methods:</p> <pre><code>class Point2d {\nstatic origin = /* .. */\nstatic distance(x,y) { /* .. */ }\nstatic {\n// ..\nthis.maxDistance = /* .. */;\n}\n// ..\n}\nclass Point3d extends Point2d {\n// class statics\nstatic origin = new Point3d(\n// here, `this.origin` references wouldn't\n// work (self-referential), so we use\n// `super.origin` references instead\nsuper.origin.x, super.origin.y, 0\n)\nstatic distance(point1,point2) {\n// here, super.distance(..) is Point2d.distance(..),\n// if we needed to invoke it\nreturn Math.sqrt(\n((point2.x - point1.x) ** 2) +\n((point2.y - point1.y) ** 2) +\n((point2.z - point1.z) ** 2)\n);\n}\n// instance members/methods\nz\nconstructor(x,y,z) {\nsuper(x,y);     // &lt;-- don't forget this line!\nthis.z = z;\n}\ntoString() {\nreturn `(${this.x},${this.y},${this.z})`;\n}\n}\nPoint2d.maxDistance;        // 10\nPoint3d.maxDistance;        // 10\n</code></pre> <p>As you can see, the static property <code>maxDistance</code> we defined on <code>Point2d</code> was inherited as a static property on <code>Point3d</code>.</p> TIP: Remember: any time you define a subclass constructor, you'll need to call <code>super(..)</code> in it, usually as the first statement. I find that all too easy to forget. <p>Don't skip over the underlying JS behavior here. Just like method inheritance discussed earlier, the static \"inheritance\" is not a copying of these static properties/functions from base class to subclass; it's sharing via the <code>[[Prototype]]</code> chain. Specifically, the constructor function <code>Point3d()</code> has its <code>[[Prototype]]</code> linkage changed by JS (from the default of <code>Function.prototype</code>) to <code>Point2d</code>, which is what allows <code>Point3d.maxDistance</code> to delegate to <code>Point2d.maxDistance</code>.</p> <p>It's also interesting, perhaps only historically now, to note that static inheritance -- which was part of the original ES6 <code>class</code> mechanism feature set! -- was one specific feature that went beyond \"just syntax sugar\". Static inheritance, as we see it illustrated here, was not possible to achieve/emulate in JS prior to ES6, in the old prototypal-class style of code. It's a special new behavior introduced only as of ES6.</p>"},{"location":"objects-classes/ch3/#private-class-behavior","title":"Private Class Behavior","text":"<p>Everything we've discussed so far as part of a <code>class</code> definition is publicly visible/accessible, either as static properties/functions on the class, methods on the constructor's <code>prototype</code>, or member properties on the instance.</p> <p>But how do you store information that cannot be seen from outside the class? This was one of the most asked for features, and biggest complaints with JS's <code>class</code>, up until it was finally addressed in ES2022.</p> <p><code>class</code> now supports new syntax for declaring private fields (instance members) and private methods. In addition, private static properties/functions are possible.</p>"},{"location":"objects-classes/ch3/#motivation","title":"Motivation?","text":"<p>Before we illustrate how to do <code>class</code> privates, it bears contemplating why this is a helpful feature?</p> <p>With closure-oriented design patterns (again, see the \"Scope &amp; Closures\" book of this series), we automatically get \"privacy\" built-in. When you declare a variable inside a scope, it cannot be seen outside that scope. Period. Reducing the scope visibility of a declaration is helpful in preventing namespace collisions (identical variable names).</p> <p>But it's even more important to ensure proper \"defensive\" design of software, the so called \"Principle of Least Privilege\" 1. POLP states that we should only expose a piece of information or capability in our software to the smallest surface area necessary.</p> <p>Over-exposure opens our software up to several issues that complicate software security/maintenance, including another piece of code acting maliciously to do something our code didn't expect or intend. Moreover, there's the less critical but still as problematic concern of other parts of our software relying on (using) parts of our code that we should have reserved as hidden implementation detail. Once other code relies on our code's implementation details, we stop being able to refactor our code without potentially breaking other parts of the program.</p> <p>So, in short, we should hide implementation details if they're not necessary to be exposed. In this sense, JS's <code>class</code> system feels a bit too permissive in that everything defaults to being public. Class-private features are a welcomed addition to more proper software design.</p>"},{"location":"objects-classes/ch3/#too-private","title":"Too Private?","text":"<p>All that said, I have to throw a bit of a damper on the class-private party.</p> <p>I've suggested strongly that you should only use <code>class</code> if you're going to really take advantage of most or all of what class-orientation gives you. Otherwise, you'd be better suited using other core pillar features of JS for organizing code, such as with the closure pattern.</p> <p>One of the most important aspects of class-orientation is subclass inheritance, as we've seen illustrated numerous times so far in this chapter. Guess what happens to a private member/method in a base class, when it's extended by a subclass?</p> <p>Private members/methods are private only to the class they're defined in, and are not inherited in any way by a subclass. Uh oh.</p> <p>That might not seem like too big of a concern, until you start working with <code>class</code> and private members/methods in real software. You might quickly run up against a situation where you need to access a private method, or more often even, just a private member, from the subclass, so that the subclass can extend/augment the behavior of the base class as desired. And you might scream in frustration pretty quickly once you realize this is not possible.</p> <p>What comes next is inevitably an awkward decision: do you just go back to making it public, so the subclass can access it? Ugh. Or, worse, do you try to re-design the base class to contort the design of its members/methods, such that the lack of access is partially worked around. That often involves exhausting over-parameterization (with privates as default parameter values) of methods, and other such tricks. Double ugh.</p> <p>There's not a particularly great answer here, to be honest. If you have experience with class-orientation in more traditional class languages like Java or C++, you're probably dubious as to why we don't have protected visibility in between public and private. That's exactly what protected is for: keeping something private to a class AND any of its subclasses. Those languages also have friend features, but that's beyond the scope of our discussion here.</p> <p>Sadly, not only does JS not have protected visibility, it seems (even as useful as it is!) to be unlikely as a JS feature. It's been discussed in great detail for over a decade (before ES6 was even a thing), and there've been multiple proposals for it.</p> <p>I shouldn't say it will never happen, because that's not solid ground to stake on in any software. But it's very unlikely, because it actually betrays the very pillar that <code>class</code> is built on. If you are curious, or (more likely) certain that there's just got to be a way, I'll cover the incompatibility of protected visibility within JS's mechanisms in an appendix.</p> <p>The point here is, as of now, JS has no protected visibility, and it won't any time soon. And protected visibility is actually, in practice, way more useful than private visibility.</p> <p>So we return to the question: Why should you care to make any <code>class</code> contents private?</p> <p>If I'm being honest: maybe you shouldn't. Or maybe you should. That's up to you. Just go into it aware of the stumbling blocks.</p>"},{"location":"objects-classes/ch3/#private-membersmethods","title":"Private Members/Methods","text":"<p>You're excited to finally see the syntax for magical private visibility, right? Please don't shoot the messenger if you feel angered or sad at what you're about to see.</p> <pre><code>class Point2d {\n// statics\nstatic samePoint(point1,point2) {\nreturn point1.#ID === point2.#ID;\n}\n// privates\n#ID = null\n#assignID() {\nthis.#ID = Math.round(Math.random() * 1e9);\n}\n// publics\nx\ny\nconstructor(x,y) {\nthis.#assignID();\nthis.x = x;\nthis.y = y;\n}\n}\nvar one = new Point2d(3,4);\nvar two = new Point2d(3,4);\nPoint2d.samePoint(one,two);         // false\nPoint2d.samePoint(one,one);         // true\n</code></pre> <p>No, JS didn't do the sensible thing and introduce a <code>private</code> keyword like they did with <code>static</code>. Instead, they introduced the <code>#</code>. (insert lame joke about social-media millienials loving hashtags, or something)</p> TIP: And yes, there's a million and one discussions about why not. I could spend chapters recounting the whole history, but honestly I just don't care to. I think this syntax is ugly, and many others do, too. And some love it! If you're in the latter camp, though I rarely do something like this, I'm just going to say: just accept it. It's too late for any more debate or pleading. <p>The <code>#whatever</code> syntax (including <code>this.#whatever</code> form) is only valid inside <code>class</code> bodies. It will throw syntax errors if used outside of a <code>class</code>.</p> <p>Unlike public fields/instance members, private fields/instance members must be declared in the <code>class</code> body. You cannot add a private member to a class declaration dynamically while in the constructor method; <code>this.#whatever = ..</code> type assignments only work if the <code>#whatever</code> private field is declared in the class body. Moreover, though private fields can be re-assigned, they cannot be <code>delete</code>d from an instance, the way a public field/class member can.</p>"},{"location":"objects-classes/ch3/#subclassing-privates","title":"Subclassing + Privates","text":"<p>I warned earlier that subclassing with classes that have private members/methods can be a limiting trap. But that doesn't mean they cannot be used together.</p> <p>Because \"inheritance\" in JS is sharing (through the <code>[[Prototype]]</code> chain), if you invoke an inherited method in a subclass, and that inherited method in turn accesses/invokes privates in its host (base) class, this works fine:</p> <pre><code>class Point2d { /* .. */ }\nclass Point3d extends Point2d {\nz\nconstructor(x,y,z) {\nsuper(x,y);\nthis.z = z;\n}\n}\nvar one = new Point3d(3,4,5);\n</code></pre> <p>The <code>super(x,y)</code> call in this constructor invokes the inherited base class constructor (<code>Point2d(..)</code>), which itself accesses <code>Point2d</code>'s private method <code>#assignID()</code> (see the earlier snippet). No exception is thrown, even though <code>Point3d</code> cannot directly see or access the <code>#ID</code> / <code>#assignID()</code> privates that are indeed stored on the instance (named <code>one</code> here).</p> <p>In fact, even the inherited <code>static samePoint(..)</code> function will work from either <code>Point3d</code> or <code>Point2d</code>:</p> <pre><code>Point2d.samePoint(one,one);         // true\nPoint3d.samePoint(one,one);         // true\n</code></pre> <p>Actually, that shouldn't be that suprising, since:</p> <pre><code>Point2d.samePoint === Point3d.samePoint;\n</code></pre> <p>The inherited function reference is the exact same function as the base function reference; it's not some copy of the function. Because the function in question has no <code>this</code> reference in it, no matter from where it's invoked, it should produce the same outcome.</p> <p>It's still a shame though that <code>Point3d</code> has no way to access/influence, or indeed even knowledge of, the <code>#ID</code> / <code>#assignID()</code> privates from <code>Point2d</code>:</p> <pre><code>class Point2d { /* .. */ }\nclass Point3d extends Point2d {\nz\nconstructor(x,y,z) {\nsuper(x,y);\nthis.z = z;\nconsole.log(this.#ID);      // will throw!\n}\n}\n</code></pre> WARNING: Notice that this snippet throws an early static syntax error at the time of defining the <code>Point3d</code> class, before ever even getting a chance to create an instance of the class. The same exception would be thrown if the reference was <code>super.#ID</code> instead of <code>this.#ID</code>."},{"location":"objects-classes/ch3/#existence-check","title":"Existence Check","text":"<p>Keep in mind that only the <code>class</code> itself knows about, and can therefore check for, such a private field/method.</p> <p>You may want to check to see if a private field/method exists on an object instance. For example (as shown below), you may have a static function or method in a class, which receives an external object reference passed in. To check to see if the passed-in object reference is of this same class (and therefore has the same private members/methods in it), you basically need to do a \"brand check\" against the object.</p> <p>Such a check could be rather convoluted, because if you access a private field that doesn't already exist on the object, you get a JS exception thrown, requiring ugly <code>try..catch</code> logic.</p> <p>But there's a cleaner approach, so called an \"ergonomic brand check\", using the <code>in</code> keyword:</p> <pre><code>class Point2d {\n// statics\nstatic samePoint(point1,point2) {\n// \"ergonomic brand checks\"\nif (#ID in point1 &amp;&amp; #ID in point2) {\nreturn point1.#ID === point2.#ID;\n}\nreturn false;\n}\n// privates\n#ID = null\n#assignID() {\nthis.#ID = Math.round(Math.random() * 1e9);\n}\n// publics\nx\ny\nconstructor(x,y) {\nthis.#assignID();\nthis.x = x;\nthis.y = y;\n}\n}\nvar one = new Point2d(3,4);\nvar two = new Point2d(3,4);\nPoint2d.samePoint(one,two);         // false\nPoint2d.samePoint(one,one);         // true\n</code></pre> <p>The <code>#privateField in someObject</code> check will not throw an exception if the field isn't found, so it's safe to use without <code>try..catch</code> and use its simple boolean result.</p>"},{"location":"objects-classes/ch3/#exfiltration","title":"Exfiltration","text":"<p>Even though a member/method may be declared with private visibility, it can still be exfiltrated (extracted) from a class instance:</p> <pre><code>var id, func;\nclass Point2d {\n// privates\n#ID = null\n#assignID() {\nthis.#ID = Math.round(Math.random() * 1e9);\n}\n// publics\nx\ny\nconstructor(x,y) {\nthis.#assignID();\nthis.x = x;\nthis.y = y;\n// exfiltration\nid = this.#ID;\nfunc = this.#assignID;\n}\n}\nvar point = new Point2d(3,4);\nid;                     // 7392851012 (...for example)\nfunc;                   // function #assignID() { .. }\nfunc.call(point,42);\nfunc.call({},100);\n// TypeError: Cannot write private member #ID to an\n// object whose class did not declare it\n</code></pre> <p>The main concern here is to be careful when passing private methods as callbacks (or in any way exposing privates to other parts of the program). There's nothing stopping you from doing so, which can create a bit of an unintended privacy disclosure.</p>"},{"location":"objects-classes/ch3/#private-statics","title":"Private Statics","text":"<p>Static properties and functions can also use <code>#</code> to be marked as private:</p> <pre><code>class Point2d {\nstatic #errorMsg = \"Out of bounds.\"\nstatic #printError() {\nconsole.log(`Error: ${this.#errorMsg}`);\n}\n// publics\nx\ny\nconstructor(x,y) {\nif (x &gt; 100 || y &gt; 100) {\nPoint2d.#printError();\n}\nthis.x = x;\nthis.y = y;\n}\n}\nvar one = new Point2d(30,400);\n// Error: Out of bounds.\n</code></pre> <p>The <code>#printError()</code> static private function here has a <code>this</code>, but that's referencing the <code>Point2d</code> class, not an instance. As such, the <code>#errorMsg</code> and <code>#printError()</code> are independent of instances and thus are best as statics. Moreover, there's no reason for them to be accessible outside the class, so they're marked private.</p> <p>Remember: private statics are similarly not-inherited by subclasses just as private members/methods are not.</p>"},{"location":"objects-classes/ch3/#gotcha-subclassing-with-static-privates-and-this","title":"Gotcha: Subclassing With Static Privates and <code>this</code>","text":"<p>Recall that inherited methods, invoked from a subclass, have no trouble accessing (via <code>this.#whatever</code> style references) any privates from their own base class:</p> <pre><code>class Point2d {\n// ..\ngetID() {\nreturn this.#ID;\n}\n// ..\n}\nclass Point3d extends Point2d {\n// ..\nprintID() {\nconsole.log(`ID: ${this.getID()}`);\n}\n}\nvar point = new Point3d(3,4,5);\npoint.printID();\n// ID: ..\n</code></pre> <p>That works just fine.</p> <p>Unfortunately, and (to me) quite unexpectedly/inconsistently, the same is not true of private statics accessed from inherited public static functions:</p> <pre><code>class Point2d {\nstatic #errorMsg = \"Out of bounds.\"\nstatic printError() {\nconsole.log(`Error: ${this.#errorMsg}`);\n}\n// ..\n}\nclass Point3d extends Point2d {\n// ..\n}\nPoint2d.printError();\n// Error: Out of bounds.\nPoint3d.printError === Point2d.printError;\n// true\nPoint3d.printError();\n// TypeError: Cannot read private member #errorMsg\n// from an object whose class did not declare it\n</code></pre> <p>The <code>printError()</code> static is inherited (shared via <code>[[Prototype]]</code>) from <code>Point2d</code> to <code>Point3d</code> just fine, which is why the function references are identical. Like the non-static snippet just above, you might have expected the <code>Point3d.printError()</code> static invocation to resolve via the <code>[[Prototype]]</code> chain to its original base class (<code>Point2d</code>) location, thereby letting it access the base class's <code>#errorMsg</code> static private.</p> <p>But it fails, as shown by the last statement in that snippet. The reason it fails here, but not with the previous snippet, is a convoluted brain twister. I'm not going to dig into the why explanation here, frankly because it boils my blood to do so.</p> <p>There's a fix, though. In the static function, instead of <code>this.#errorMsg</code>, swap that for <code>Point2d.#errorMsg</code>, and now it works:</p> <pre><code>class Point2d {\nstatic #errorMsg = \"Out of bounds.\"\nstatic printError() {\n// the fixed reference vvvvvv\nconsole.log(`Error: ${Point2d.#errorMsg}`);\n}\n// ..\n}\nclass Point3d extends Point2d {\n// ..\n}\nPoint2d.printError();\n// Error: Out of bounds.\nPoint3d.printError();\n// Error: Out of bounds.  &lt;-- phew, it works now!\n</code></pre> <p>If public static functions are being inherited, use the class name to access any private statics instead of using <code>this.</code> references. Beware that gotcha!</p>"},{"location":"objects-classes/ch3/#class-example","title":"Class Example","text":"<p>OK, we've laid out a bunch of disparate class features. I want to wrap up this chapter by trying to illustrate a sampling of these capabilities in a single example that's a little less basic/contrived.</p> <pre><code>class CalendarItem {\nstatic #UNSET = Symbol(\"unset\")\nstatic #isUnset(v) {\nreturn v === this.#UNSET;\n}\nstatic #error(num) {\nreturn this[`ERROR_${num}`];\n}\nstatic {\nfor (let [idx,msg] of [\n\"ID is already set.\",\n\"ID is unset.\",\n\"Don't instantiate 'CalendarItem' directly.\",\n].entries()) {\nthis[`ERROR_${(idx+1)*100}`] = msg;\n}\n}\nstatic isSameItem(item1,item2) {\nif (#ID in item1 &amp;&amp; #ID in item2) {\nreturn item1.#ID === item2.#ID;\n}\nelse {\nreturn false;\n}\n}\n#ID = CalendarItem.#UNSET\n#setID(id) {\nif (CalendarItem.#isUnset(this.#ID)) {\nthis.#ID = id;\n}\nelse {\nthrow new Error(CalendarItem.#error(100));\n}\n}\ndescription = null\nstartDateTime = null\nconstructor() {\nif (new.target !== CalendarItem) {\nlet id = Math.round(Math.random() * 1e9);\nthis.#setID(id);\n}\nelse {\nthrow new Error(CalendarItem.#error(300));\n}\n}\ngetID() {\nif (!CalendarItem.#isUnset(this.#ID)) {\nreturn this.#ID;\n}\nelse {\nthrow new Error(CalendarItem.#error(200));\n}\n}\ngetDateTimeStr() {\nif (this.startDateTime instanceof Date) {\nreturn this.startDateTime.toUTCString();\n}\n}\nsummary() {\nconsole.log(`(${\nthis.getID()\n}) ${\nthis.description\n} at ${\nthis.getDateTimeStr()\n}`);\n}\n}\nclass Reminder extends CalendarItem {\n#complete = false;  // &lt;-- no ASI, semicolon needed\n[Symbol.toStringTag] = \"Reminder\"\nconstructor(description,startDateTime) {\nsuper();\nthis.description = description;\nthis.startDateTime = startDateTime;\n}\nisComplete() {\nreturn !!this.#complete;\n}\nmarkComplete() {\nthis.#complete = true;\n}\nsummary() {\nif (this.isComplete()) {\nconsole.log(`(${this.getID()}) Complete.`);\n}\nelse {\nsuper.summary();\n}\n}\n}\nclass Meeting extends CalendarItem {\n#getEndDateTimeStr() {\nif (this.endDateTime instanceof Date) {\nreturn this.endDateTime.toUTCString();\n}\n}\nendDateTime = null;  // &lt;-- no ASI, semicolon needed\n[Symbol.toStringTag] = \"Meeting\"\nconstructor(description,startDateTime,endDateTime) {\nsuper();\nthis.description = description;\nthis.startDateTime = startDateTime;\nthis.endDateTime = endDateTime;\n}\ngetDateTimeStr() {\nreturn `${\nsuper.getDateTimeStr()\n} - ${\nthis.#getEndDateTimeStr()\n}`;\n}\n}\n</code></pre> <p>Take some time to read and digest those <code>class</code> definitions. Did you spot most of the <code>class</code> features we talked about in this chapter?</p> NOTE: One question you may have: why didn't I move the repeated logic of <code>description</code> and <code>startDateTime</code> setting from both subclass constructors into the single base constructor? This is a nuanced point, but it's not my intention that <code>CalendarItem</code> ever be directly instantiated; it's what in class-oriented terms we refer to as an \"abstract class\". That's why I'm using <code>new.target</code> to throw an error if the <code>CalendarItem</code> class is ever directly instantiated! So I don't want to imply by signature that the <code>CalendarItem(..)</code> constructor should ever be directly used. <p>Let's now see these three classes in use:</p> <pre><code>var callMyParents = new Reminder(\n\"Call my parents to say hi\",\nnew Date(\"July 7, 2022 11:00:00 UTC\")\n);\ncallMyParents.toString();\n// [object Reminder]\ncallMyParents.summary();\n// (586380912) Call my parents to say hi at\n// Thu, 07 Jul 2022 11:00:00 GMT\ncallMyParents.markComplete();\ncallMyParents.summary();\n// (586380912) Complete.\ncallMyParents instanceof Reminder;\n// true\ncallMyParents instanceof CalendarItem;\n// true\ncallMyParents instanceof Meeting;\n// false\nvar interview = new Meeting(\n\"Job Interview: ABC Tech\",\nnew Date(\"June 23, 2022 08:30:00 UTC\"),\nnew Date(\"June 23, 2022 09:15:00 UTC\")\n);\ninterview.toString();\n// [object Meeting]\ninterview.summary();\n// (994337604) Job Interview: ABC Tech at Thu,\n// 23 Jun 2022 08:30:00 GMT - Thu, 23 Jun 2022\n// 09:15:00 GMT\ninterview instanceof Meeting;\n// true\ninterview instanceof CalendarItem;\n// true\ninterview instanceof Reminder;\n// false\nReminder.isSameItem(callMyParents,callMyParents);\n// true\nMeeting.isSameItem(callMyParents,interview);\n// false\n</code></pre> <p>Admittedly, some bits of this example are a little contrived. But honestly, I think pretty much all of this is plausible and reasonable usages of the various <code>class</code> features.</p> <p>By the way, there's probably a million different ways to structure the above code logic. I'm by no means claiming this is the right or best way to do so. As an exercise for the reader, try your hand and writing it yourself, and take note of things you did differently than my approach.</p> <ol> <li> <p>\"Principle of Least Privilege\", Wikipedia; https://en.wikipedia.org/wiki/Principle_of_least_privilege ; Accessed July 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"objects-classes/ch4/","title":"Chapter 4: This Works","text":"NOTE: Work in progress <p>We've seen the <code>this</code> keyword used quite a bit so far, but haven't really dug in to understand exactly how it works in JS. It's time we do so.</p> <p>But to properly understand <code>this</code> in JS, you need to set aside any preconceptions you may have, especially assumptions from how <code>this</code> works in other programming languages you may have experience in.</p> <p>Here's the most important thing to understand about <code>this</code>: the determination of what value (usually, object) <code>this</code> points at is not made at author time, but rather determined at runtime. That means you cannot simply look at a <code>this</code>-aware function (even a method in a <code>class</code> definition) and know for sure what <code>this</code> will hold while that function runs.</p> <p>Instead, you have to find each place the function is invoked, and look at how it's invoked (not even where matters). That's the only way to fully answer what <code>this</code> will point to.</p> <p>In fact, a single <code>this</code>-aware function can be invoked at least four different ways, and any of those approaches will end up assigning a different <code>this</code> for that particular function invocation.</p> <p>So the typical question we might ask when reading code -- \"What does <code>this</code> point to the function?\" -- is not actually a valid question. The question you really have to ask is, \"When the function is invoked a certain way, what <code>this</code> will be assigned for that invocation?\"</p> <p>If your brain is already twisting around just reading this chapter intro... good! Settle in for a rewiring of how you think about <code>this</code> in JS.</p>"},{"location":"objects-classes/ch4/#this-aware","title":"This Aware","text":"<p>I used the phrase <code>this</code>-aware just a moment ago. But what exactly do I mean by that?</p> <p>Any function that has a <code>this</code> keyword in it.</p> <p>If a function does not have <code>this</code> in it anywhere, then the rules of how <code>this</code> behaves don't affect that function in any way. But if it does have even a single <code>this</code> in it, then you absolutely cannot determine how the function will behave without figuring out, for each invocation of the function, what <code>this</code> will point to.</p> <p>It's sort of like the <code>this</code> keyword is a placeholder in a template. That placeholder's value-replacement doesn't get determined when we author the code; it gets determined while the code is running.</p> <p>You might think I'm just playing word games here. Of course, when you write the program, you write out all the calls to each function, so you've already determined what the <code>this</code> is going to be when you authored the code, right? Right!?</p> <p>Not so fast!</p> <p>First of all, you don't always write all the code that invokes your function(s). Your <code>this</code>-aware function(s) might be passed as a callback(s) to some other code, either in your code base, or in a third-party framework/utility, or even inside a native built-in mechanism of the language or environment that's hosting your program.</p> <p>But even aside from passing functions as callbacks, several mechanisms in JS allow for conditional runtime behaviors to determine which value (again, usually object) will be set for the <code>this</code> of a particular function invocation. So even though you may have written all that code, you at best will have to mentally execute the different conditions/paths that end up affecting the function invocation.</p> <p>And why does all this matter?</p> <p>Because it's not just you, the author of the code, that needs to figure this stuff out. It's every single reader of your code, forever. If anyone (even your future self) wants to read a piece of code that defines a <code>this</code>-aware function, that inevitably means that, to fully understand and predict its behavior, that person will have to find, read, and understand every single invocation of that function.</p>"},{"location":"objects-classes/ch4/#this-confuses-me","title":"This Confuses Me","text":"<p>Now, in fairness, that's already partially true if we consider a function's parameters. To understand how a function is going to work, we need to know what is being passed into it. So any function with at least one parameter is, in a similar sense, argument-aware -- meaning, what argument(s) is/are passed in and assigned to the parameter(s) of the function.</p> <p>But with parameters, we often have a bit more of a hint from the function itself what the parameters will do and hold.</p> <p>We often see the names of the parameters declared right in the function header, which goes a long way to explaining their nature/purpose. And if there are defaults for the parameters, we often see them declared inline with <code>= whatever</code> clauses. Moreover, depending on the code style of the author, we may see in the first several lines of the function a set of logic that applies to these parameters; this could be assertions about the values (disallowed values, etc), or even modifications (type conversion, formatting, etc).</p> <p>Actually, <code>this</code> is very much like a parameter to a function, but it's an implicit parameter rather than an explicit one. You don't see any signal that <code>this</code> is going to be used, in the function header anywhere. You have to read the entire function body to see if <code>this</code> appears anywhere.</p> <p>The \"parameter\" name is always <code>this</code>, so we don't get much of a hint as to its nature/purpose from such a general name. In fact, there's historically a lot of confusion of what \"this\" even is supposed to mean. And we rarely see much if anything done to validate/convert/etc the <code>this</code> value applied to a function invocation. In fact, virtually all <code>this</code>-aware code I've seen just neatly assumes the <code>this</code> \"parameter\" is holding exactly what value is expected. Talk about a trap for unexpected bugs!</p>"},{"location":"objects-classes/ch4/#so-what-is-this","title":"So What Is This?","text":"<p>If <code>this</code> is an implicit parameter, what's its purpose? What's being passed in?</p> <p>Hopefully you have already read the \"Scope &amp; Closures\" book of this series. If not, I strongly encourage you to circle back and read that one once you've finished this one. In that book, I explained at length how scopes (and closures!) work, an especially important characteristic of functions.</p> <p>Lexical scope (including all the variables closed over) represents a static context for the function's LEXICAL identifier references to be evaluated against. It's fixed/static because at author time, when you place functions and variable declarations in various (nested) scopes, those decisions are fixed, and unaffected by any runtime conditions.</p> <p>By contrast, a different programming language might offer dynamic scope, where the context for a function's variable references is not determined by author-time decisions but by runtime conditions. Such a system would be undoubtedly more flexible than static context -- though with flexibility often comes complexity.</p> <p>To be clear: JS scope is always and only LEXICAL and static (if we ignore non-strict mode cheats like <code>eval(..)</code> and <code>with</code>). However, one of the truly powerful things about JS is that it offers another mechanism with similar flexibility and capabilities to dynamic scope.</p> <p>The <code>this</code> mechanism is, effectively, dynamic context (not scope); it's how a <code>this</code>-aware function can be dynamically invoked against different contexts -- something that's impossible with closure and LEXICAL scope identifiers!</p>"},{"location":"objects-classes/ch4/#why-is-this-so-implicit","title":"Why Is This So Implicit?","text":"<p>You might wonder why something as important as a dynamic context is handled as an implicit input to a function, rather than being an explicit argument passed in.</p> <p>That's a very important question, but it's not one we can quite answer, yet. Hold onto that question though.</p>"},{"location":"objects-classes/ch4/#can-we-get-on-with-this","title":"Can We Get On With This?","text":"<p>So why have I belabored this subject for a couple of pages now? You get it, right!? You're ready to move on.</p> <p>My point is, you the author of code, and all other readers of the code even years or decades in the future, need to be <code>this</code>-aware. That's the choice, the burden, you place on the reading of such code. And yes, that goes for the choice to use <code>class</code> (see Chapter 3), as most class methods will be <code>this</code>-aware out of necessity.</p> <p>Be aware of this <code>this</code> choice in code you write. Do it intentionally, and do it in such a way as to produce more outcome benefit than burden. Make sure <code>this</code> usage in your code carries its own weight.</p> <p>Let me put it this way: don't use <code>this</code>-aware code unless you really can justify it, and you've carefully weighed the costs. Just because you've seen a lot of code examples slinging around <code>this</code> in others' code, doesn't mean that <code>this</code> belongs in this code you're writing.</p> <p>The <code>this</code> mechanism in JS, paired with <code>[[Prototype]]</code> delegation, is an extremely powerful pillar of the language. But as the cliche goes: \"with great power comes great responsibility\". Anecdotally, even though I really like and appreciate this pillar of JS, probably less than 5% of the JS code I ever write uses it. And when I do, it's with restraint. It's not my default, go-to JS capability.</p>"},{"location":"objects-classes/ch4/#this-is-it","title":"This Is It!","text":"<p>OK, enough of the wordy lecture. You're ready to dive into <code>this</code> code, right?</p> <p>Let's revisit (and extend) <code>Point2d</code> from Chapter 3, but just as an object with data properties and functions on it, instead of using <code>class</code>:</p> <pre><code>var point = {\nx: null,\ny: null,\ninit(x,y) {\nthis.x = x;\nthis.y = y;\n},\nrotate(angleRadians) {\nvar rotatedX = this.x * Math.cos(angleRadians) -\nthis.y * Math.sin(angleRadians);\nvar rotatedY = this.x * Math.sin(angleRadians) +\nthis.y * Math.cos(angleRadians);\nthis.x = rotatedX;\nthis.y = rotatedY;\n},\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n};\n</code></pre> <p>As you can see, the <code>init(..)</code>, <code>rotate(..)</code>, and <code>toString()</code> functions are <code>this</code>-aware. You might be in the habit of assuming that the <code>this</code> reference will obviously always hold the <code>point</code> object. But that's not guaranteed in any way.</p> <p>Keep reminding yourself as you go through the rest of this chapter: the <code>this</code> value for a function is determined by how the function is invoked. That means you can't look at the function's definition, nor where the function is defined (not even the enclosing <code>class</code>!). In fact, it doesn't even matter where the function is called from.</p> <p>We only need to look at how the functions are called; that's the only factor that matters.</p>"},{"location":"objects-classes/ch4/#implicit-context-invocation","title":"Implicit Context Invocation","text":"<p>Consider this call:</p> <pre><code>point.init(3,4);\n</code></pre> <p>We're invoking the <code>init(..)</code> function, but notice the <code>point.</code> in front of it? This is an implicit context binding. It says to JS: invoke the <code>init(..)</code> function with <code>this</code> referencing <code>point</code>.</p> <p>That is the normal way we'd expect a <code>this</code> to work, and that's also one of the most common ways we invoke functions. So the typical invocation gives us the intuitive outcome. That's a good thing!</p>"},{"location":"objects-classes/ch4/#default-context-invocation","title":"Default Context Invocation","text":"<p>But what happens if we do this?</p> <pre><code>const init = point.init;\ninit(3,4);\n</code></pre> <p>You might assume that we'd get the same outcome as the previous snippet. But that's not how JS <code>this</code> assignment works.</p> <p>The call-site for the function is <code>init(3,4)</code>, which is different than <code>point.init(3,4)</code>. When there's no implicit context (<code>point.</code>), nor any other kind of <code>this</code> assignment mechanism, the default context assignment occurs.</p> <p>What will <code>this</code> reference when <code>init(3,4)</code> is invoked like that?</p> <p>It depends.</p> <p>Uh oh. Depends? That sounds confusing.</p> <p>Don't worry, it's not as bad as it sounds. The default context assignment depends on whether the code is in strict-mode or not. But thankfully, virtually all JS code these days is running in strict-mode; for example, ESM (ES Modules) always run in strict-mode, as does code inside a <code>class</code> block. And virtually all transpiled JS code (via Babel, TypeScript, etc) is written to declare strict-mode.</p> <p>So almost all of the time, modern JS code will be running in strict-mode, and thus the default assignment context won't \"depend\" on anything; it's pretty straightforward: <code>undefined</code>. That's it!</p> NOTE: Keep in mind: <code>undefined</code> does not mean \"not defined\"; it means, \"defined with the special empty <code>undefined</code> value\". I know, I know... the name and meaning are mismatched. That's language legacy baggage, for you. (shrugging shoulders) <p>That means <code>init(3,4)</code>, if run in strict-mode, would throw an exception. Why? Because the <code>this.x</code> reference in <code>init(..)</code> is a <code>.x</code> property access on <code>undefined</code> (i.e., <code>undefined.x</code>), which is not allowed:</p> <pre><code>\"use strict\";\nvar point = { /* .. */ };\nconst init = point.init;\ninit(3,4);\n// TypeError: Cannot set properties of\n// undefined (setting 'x')\n</code></pre> <p>Stop for a moment and consider: why would JS choose to default the context to <code>undefined</code>, so that any default context invocation of a <code>this</code>-aware function will fail with such an exception?</p> <p>Because a <code>this</code>-aware function always needs a <code>this</code>. The invocation <code>init(3,4)</code> isn't providing a <code>this</code>, so that is a mistake, and should raise an exception so the mistake can be corrected. The lesson: never invoke a <code>this</code>-aware function without providing it a <code>this</code>!</p> <p>Just for completeness sake: in the less common non-strict mode, the default context is the global object -- JS defines it as <code>globalThis</code>, which in browser JS is essentially an alias to <code>window</code>, and in Node it's <code>global</code>. So, when <code>init(3,4)</code> runs in non-strict mode, the <code>this.x</code> expression is <code>globalThis.x</code> -- also known as <code>window.x</code> in the browser, or <code>global.x</code> in Node. Thus, <code>globalThis.x</code> gets set as <code>3</code> and <code>globalThis.y</code> gets set as <code>4</code>.</p> <pre><code>// no strict-mode here, beware!\nvar point = { /* .. */ };\nconst init = point.init;\ninit(3,4);\nglobalThis.x;   // 3\nglobalThis.y;   // 4\npoint.x;        // null\npoint.y;        // null\n</code></pre> <p>That's unfortunate, because it's almost certainly not the intended outcome. Not only is it bad if it's a global variable, but it's also not changing the property on our <code>point</code> object, so program bugs are guaranteed.</p> WARNING: Ouch! Nobody wants accidental global variables implicitly created from all over the code. The lesson: always make sure your code is running in strict-mode!"},{"location":"objects-classes/ch4/#explicit-context-invocation","title":"Explicit Context Invocation","text":"<p>Functions can alternately be invoked with explicit context, using the built-in <code>call(..)</code> or <code>apply(..)</code> utilities:</p> <pre><code>var point = { /* .. */ };\nconst init = point.init;\ninit.call( point, 3, 4 );\n// or: init.apply( point, [ 3, 4 ] )\npoint.x;        // 3\npoint.y;        // 4\n</code></pre> <p><code>init.call(point,3,4)</code> is effectively the same as <code>point.init(3,4)</code>, in that both of them assign <code>point</code> as the <code>this</code> context for the <code>init(..)</code> invocation.</p> NOTE: Both <code>call(..)</code> and <code>apply(..)</code> utilities take as their first argument a <code>this</code> context value; that's almost always an object, but can technically can be any value (number, string, etc). The <code>call(..)</code> utility takes subsequent arguments and passes them through to the invoked function, whereas <code>apply(..)</code> expects its second argument to be an array of values to pass as arguments. <p>It might seem awkward to contemplate invoking a function with the explicit context assignment (<code>call(..)</code> / <code>apply(..)</code>) style in your program. But it's more useful than might be obvious at first glance.</p> <p>Let's recall the original snippet:</p> <pre><code>var point = {\nx: null,\ny: null,\ninit(x,y) {\nthis.x = x;\nthis.y = y;\n},\nrotate(angleRadians) { /* .. */ },\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n};\npoint.init(3,4);\nvar anotherPoint = {};\npoint.init.call( anotherPoint, 5, 6 );\npoint.x;                // 3\npoint.y;                // 4\nanotherPoint.x;         // 5\nanotherPoint.y;         // 6\n</code></pre> <p>Are you seeing what I did there?</p> <p>I wanted to define <code>anotherPoint</code>, but I didn't want to repeat the definitions of those <code>init(..)</code> / <code>rotate(..)</code> / <code>toString()</code> functions from <code>point</code>. So I \"borrowed\" a function reference, <code>point.init</code>, and explicitly set the empty object <code>anotherPoint</code> as the <code>this</code> context, via <code>call(..)</code>.</p> <p>When <code>init(..)</code> is running at that moment, <code>this</code> inside it will reference <code>anotherPoint</code>, and that's why the <code>x</code> / <code>y</code> properties (values <code>5</code> / <code>6</code>, respectively) get set there.</p> <p>Any <code>this</code>-aware functions can be borrowed like this: <code>point.rotate.call(anotherPoint, ..)</code>, <code>point.toString.call(anotherPoint)</code>.</p>"},{"location":"objects-classes/ch4/#revisiting-implicit-context-invocation","title":"Revisiting Implicit Context Invocation","text":"<p>Another approach to share behavior between <code>point</code> and <code>anotherPoint</code> would have been:</p> <pre><code>var point = { /* .. */ };\nvar anotherPoint = {\ninit: point.init,\nrotate: point.rotate,\ntoString: point.toString,\n};\nanotherPoint.init(5,6);\nanotherPoint.x;         // 5\nanotherPoint.y;         // 6\n</code></pre> <p>This is another way of \"borrowing\" the functions, by adding shared references to the functions on any target object (e.g., <code>anotherPoint</code>). The call-site invocation <code>anotherPoint.init(5,6)</code> is the more natural/ergonomic style that relies on implicit context assignment.</p> <p>It may seem this approach is a little cleaner, comparing <code>anotherPoint.init(5,6)</code> to <code>point.init.call(anotherPoint,5,6)</code>.</p> <p>But the main downside is having to modify any target object with such shared function references, which can be verbose, manual, and error-prone. Sometimes such an approach is acceptable, but many other times, explicit context assignment with <code>call(..)</code> / <code>apply(..)</code> is more preferable.</p>"},{"location":"objects-classes/ch4/#new-context-invocation","title":"New Context Invocation","text":"<p>We've so far seen three different ways of context assignment at the function call-site: default, implicit, and explicit.</p> <p>A fourth way to call a function, and assign the <code>this</code> for that invocation, is with the <code>new</code> keyword:</p> <pre><code>var point = {\n// ..\ninit: function() { /* .. */ }\n// ..\n};\nvar anotherPoint = new point.init(3,4);\nanotherPoint.x;     // 3\nanotherPoint.y;     // 4\n</code></pre> TIP: This example has a bit of nuance to be explained. The <code>init: function() { .. }</code> form shown here -- specifically, a function expression assigned to a property -- is required for the function to be validly called with the <code>new</code> keyword. From previous snippets, the concise method form of <code>init() { .. }</code> defines a function that cannot be called with <code>new</code>. <p>You've typically seen <code>new</code> used with <code>class</code> for creating instances. But as an underlying mechanism of the JS language, <code>new</code> is not inherently a <code>class</code> operation.</p> <p>In a sense, the <code>new</code> keyword hijacks a function and forces its behavior into a different mode than a normal invocation. Here are the 4 special steps that JS performs when a function is invoked with <code>new</code>:</p> <ol> <li> <p>create a brand new empty object, out of thin air.</p> </li> <li> <p>link the <code>[[Prototype]]</code> of that new empty object to the function's <code>.prototype</code> object (see Chapter 2).</p> </li> <li> <p>invoke the function with the <code>this</code> context set to that new empty object.</p> </li> <li> <p>if the function doesn't return its own object value explicitly (with a <code>return ..</code> statement), assume the function call should instead return the new object (from steps 1-3).</p> </li> </ol> WARNING: Step 4 implies that if you <code>new</code> invoke a function that does return its own object -- like <code>return { .. }</code>, etc -- then the new object from steps 1-3 is not returned. That's a tricky gotcha to be aware of, in that it effectively discards that new object before the program has a chance to receive and store a reference to it. Essentially, <code>new</code> should never be used to invoke a function that has explicit <code>return ..</code> statement(s) in it. <p>To understand these 4 <code>new</code> steps more concretely, I'm going to illustrate them in code, as an alternate to using the <code>new</code> keyword:</p> <pre><code>// alternative to:\n//   var anotherPoint = new point.init(3,4)\nvar anotherPoint;\n// this is a bare block to hide local\n// `let` declarations\n{\n// (Step 1)\nlet tmpObj = {};\n// (Step 2)\nObject.setPrototypeOf(\ntmpObj, point.init.prototype\n);\n// or: tmpObj.__proto__ = point.init.prototype\n// (Step 3)\nlet res = point.init.call(tmpObj,3,4);\n// (Step 4)\nanotherPoint = (\ntypeof res !== \"object\" ? tmpObj : res\n);\n}\n</code></pre> <p>Clearly, the <code>new</code> invocation streamlines that set of manual steps!</p> TIP: The <code>Object.setPrototypeOf(..)</code> in step 2 could also have been done via the <code>__proto__</code> property, such as <code>tmpObj.__proto__ = point.init.prototype</code>, or even as part of the object literal (step 1) with <code>tmpObj = { __proto__: point.init.prototype }</code>. <p>Skipping some of the formality of these steps, let's recall an earlier snippet and see how <code>new</code> approximates a similar outcome:</p> <pre><code>var point = { /* .. */ };\n// this approach:\nvar anotherPoint = {};\npoint.init.call(anotherPoint,5,6);\n// can instead be approximated as:\nvar yetAnotherPoint = new point.init(5,6);\n</code></pre> <p>That's a bit nicer! But there's a caveat here.</p> <p>Using the other functions that <code>point</code> holds against <code>anotherPoint</code> / <code>yetAnotherPoint</code>, we won't want to do with <code>new</code>. Why? Because <code>new</code> is creating a new object, but that's not what we want if we intend to invoke a function against an existing object.</p> <p>Instead, we'll likely use explicit context assignment:</p> <pre><code>point.rotate.call( anotherPoint, /*angleRadians=*/Math.PI );\npoint.toString.call( yetAnotherPoint );\n// (5,6)\n</code></pre>"},{"location":"objects-classes/ch4/#review-this","title":"Review This","text":"<p>We've seen four rules for <code>this</code> context assignment in function calls. Let's put them in order of precedence:</p> <ol> <li> <p>Is the function invoked with <code>new</code>, creating and setting a new <code>this</code>?</p> </li> <li> <p>Is the function invoked with <code>call(..)</code> or <code>apply(..)</code>, explicitly setting <code>this</code>?</p> </li> <li> <p>Is the function invoked with an object reference at the call-site (e.g., <code>point.init(..)</code>), implicitly setting <code>this</code>?</p> </li> <li> <p>If none of the above... are we in non-strict mode? If so, default the <code>this</code> to <code>globalThis</code>. But if in strict-mode, default the <code>this</code> to <code>undefined</code>.</p> </li> </ol> <p>These rules, in this order, are how JS determines the <code>this</code> for a function invocation. If multiple rules match a call-site (e.g., <code>new point.init.call(..)</code>), the first rule from the list to match wins.</p> <p>That's it, you're now master over the <code>this</code> keyword. Well, not quite. There's a bunch more nuance to cover. But you're well on your way!</p>"},{"location":"objects-classes/ch4/#an-arrow-points-somewhere","title":"An Arrow Points Somewhere","text":"<p>Everything I've asserted so far about <code>this</code> in functions, and how its determined based on the call-site, makes one giant assumption: that you're dealing with a regular function (or method).</p> <p>So what's an irregular function?!? It looks like this:</p> <pre><code>const x = x =&gt; x &lt;= x;\n</code></pre> NOTE: Yes, I'm being a tad sarcastic and unfair to call an arrow function \"irregular\" and to use such a contrived example. It's a joke, ok? <p>Here's a real example of an <code>=&gt;</code> arrow function:</p> <pre><code>const clickHandler = evt =&gt;\nevt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation();\n</code></pre> <p>For comparison sake, let me also show the non-arrow equivalent:</p> <pre><code>const clickHandler = function(evt) {\nevt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation();\n};\n</code></pre> <p>Or if we went a bit old-school about it -- this is my jam! -- we could try the standalone function declaration form:</p> <pre><code>function clickHandler(evt) {\nevt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation();\n}\n</code></pre> <p>Or if the function appeared as a method in a <code>class</code> definition, or as a concise method in an object literal, it would look like this:</p> <pre><code>// ..\nclickHandler(evt) {\nevt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation();\n}\n</code></pre> <p>What I really want to focus on is how each of these forms of the function will behave with respect to their <code>this</code> reference, and whether the first <code>=&gt;</code> form differs from the others (hint: it does!). But let's start with a little quiz to see if you've been paying attention.</p> <p>For each of those function forms just shown, how do we know what each <code>this</code> will reference?</p>"},{"location":"objects-classes/ch4/#wheres-the-call-site","title":"Where's The Call-site?","text":"<p>Hopefully, you responded with something like: \"first, we need to see how the functions are called.\"</p> <p>Fair enough.</p> <p>Let's say our program looks like this:</p> <pre><code>var infoForm = {\ntheFormElem: null,\ntheSubmitBtn: null,\ninit() {\nthis.theFormElem =\ndocument.getElementById(\"the-info-form\");\nthis.theSubmitBtn =\ntheFormElem.querySelector(\"button[type=submit]\");\n// is *this* the call-site?\nthis.theSubmitBtn.addEventListener(\n\"click\",\nthis.clickHandler,\nfalse\n);\n},\n// ..\n}\n</code></pre> <p>Ah, interesting. Half of you readers have never seen actual DOM API code like <code>getElementById(..)</code>, <code>querySelector(..)</code>, and <code>addEventListener(..)</code> before. I heard the confusion bells whistle just now!</p> NOTE: Sorry, I'm dating myself, here. I've been doing this stuff long enough that I remember when we did that kind of code long before we had utilities like jQuery cluttering up the code with <code>$</code> everywhere. And after many years of front-end evolution, we seem to have landed somewhere quite a bit more \"modern\" -- at least, that's the prevailing presumption. <p>I'm guessing many of you these days are used to seeing component-framework code (React, etc) somewhat like this:</p> <pre><code>// ..\n\ninfoForm(props) {\n    return (\n        &lt;form ref={this.theFormElem}&gt;\n            &lt;button type=submit onClick=this.clickHandler&gt;\n                Click Me\n            &lt;/button&gt;\n        &lt;/form&gt;\n    );\n}\n\n// ..\n</code></pre> <p>Of course, there's a bunch of other ways that code might be shaped, depending on if you're using one framework or another, etc.</p> <p>Or maybe you're not even using <code>class</code> / <code>this</code> style components anymore, because you've moved everything to hooks and closures. In any case, for our discussion purposes, this chapter is all about <code>this</code>, so we need to stick to a coding style like the above, to have code related to the discussion.</p> <p>And neither of those two previous code snippets show the <code>clickHandler</code> function being defined. But I've said repeatedly so far, that doesn't matter; all that matters is ... what? say it with me... all that matters is how the function is invoked.</p> <p>So how is <code>clickHandler</code> being invoked? What's the call-site, and which context assignment rule does it match?</p>"},{"location":"objects-classes/ch4/#hidden-from-sight","title":"Hidden From Sight","text":"<p>If you're stuck, don't worry. I'm deliberately making this difficult, to point something very important out.</p> <p>When the <code>\"click\"</code> or <code>onClick=</code> event handler bindings happen, in both cases, we specified <code>this.clickHandler</code>, which implies that there is a <code>this</code> context object with a property on it called <code>clickHandler</code>, which is holding our function definition.</p> <p>So, is <code>this.clickHandler</code> the call-site? If it was, what assignment rule applies? The implicit context rule (#3)?</p> <p>Unfortunately, no.</p> <p>The problem is, we cannot actually see the call-site in this program. Uh oh.</p> <p>If we can't see the call-site, how do we know how the function is going to actually get called?</p> <p>That's the exact point I'm making.</p> <p>It doesn't matter that we passed in <code>this.clickHandler</code>. That is merely a reference to a function object value. It's not a call-site.</p> <p>Under the covers, somewhere inside a framework, library, or even the JS environment itself, when a user clicks the button, a reference to the <code>clickHandler(..)</code> function is going to be invoked. And as we've implied, that call-site is even going to pass in the DOM event object as the <code>evt</code> argument.</p> <p>Since we can't see the call-site, we have to imagine it. Might it look like...?</p> <pre><code>// ..\neventCallback( domEventObj );\n// ..\n</code></pre> <p>If it did, which <code>this</code> rule would apply? The default context rule (#4)?</p> <p>Or, what if the call-site looked like this...?</p> <pre><code>// ..\neventCallback.call( domElement, domEventObj );\n</code></pre> <p>Now which <code>this</code> rule would apply? The explicit context rule (#2)?</p> <p>Unless you open and view the source code for the framework/library, or read the documentation/specification, you won't know what to expect of that call-site. Which means that predicting, ultimately, what <code>this</code> points to in the <code>clickHandler</code> function you write, is... to put it mildly... a bit convoluted.</p>"},{"location":"objects-classes/ch4/#this-is-wrong","title":"This Is Wrong","text":"<p>To spare you any more pain here, I'll cut to the chase.</p> <p>Pretty much all implementations of a click-handler mechanism are going to do something like the <code>.call(..)</code>, and they're going to set the DOM element (e.g., button) the event listener is bound to, as the explicit context for the invocation.</p> <p>Hmmm... is that ok, or is that going to be a problem?</p> <p>Recall that our <code>clickHandler(..)</code> function is <code>this</code>-aware, and that its <code>this.theFormElem</code> reference implies referencing an object with a <code>theFormElem</code> property, which in turn is pointing at the parent <code>&lt;form&gt;</code> element. DOM buttons do not, by default, have a <code>theFormElem</code> property on them.</p> <p>In other words, the <code>this</code> reference that our event handler will have set for it is almost certainly wrong. Oops.</p> <p>Unless we want to rewrite the <code>clickHandler</code> function, we're going to need to fix that.</p>"},{"location":"objects-classes/ch4/#fixing-this","title":"Fixing <code>this</code>","text":"<p>Let's consider some options to address the mis-assignment. To keep things focused, I'll stick to this style of event binding for the discussion:</p> <pre><code>this.submitBtnaddEventListener(\n\"click\",\nthis.clickHandler,\nfalse\n);\n</code></pre> <p>Here's one way to address it:</p> <pre><code>// store a fixed reference to the current\n// `this` context\nvar context = this;\nthis.submitBtn.addEventListener(\n\"click\",\nfunction handler(evt){\nreturn context.clickHandler(evt);\n},\nfalse\n);\n</code></pre> TIP: Most older JS code that uses this approach will say something like <code>var self = this</code> instead of the <code>context</code> name I'm giving it here. \"Self\" is a shorter word, and sounds cooler. But it's also entirely the wrong semantic meaning. The <code>this</code> keyword is not a \"self\" reference to the function, but rather the context for that current function invocation. Those may seem like the same thing at a glance, but they're completely different concepts, as different as apples and a Beatles song. So... to paraphrase them, \"Hey developer, don't make it bad. Take a sad <code>self</code> and make it better <code>context</code>.\" <p>What's going on here? I recognized that the enclosing code, where the <code>addEventListener</code> call is going to run, has a current <code>this</code> context that is correct, and we need to ensure that same <code>this</code> context is applied when <code>clickHandler(..)</code> gets invoked.</p> <p>I defined a surrounding function (<code>handler(..)</code>) and then forced the call-site to look like:</p> <pre><code>context.clickHandler(evt);\n</code></pre> TIP: Which <code>this</code> context assignment rule is applied here? That's right, the implicit context rule (#3). <p>Now, it doesn't matter what the internal call-site of the library/framework/environment looks like. But, why?</p> <p>Because we're now actually in control of the call-site. It doesn't matter how <code>handler(..)</code> gets invoked, or what its <code>this</code> is assigned. It only matters than when <code>clickHandler(..)</code> is invoked, the <code>this</code> context is set to what we wanted.</p> <p>I pulled off that trick not only by defining a surrounding function (<code>handler(..)</code>) so I can control the call-site, but... and this is important, so don't miss it... I defined <code>handler(..)</code> as a NON-<code>this</code>-aware function! There's no <code>this</code> keyword inside of <code>handler(..)</code>, so whatever <code>this</code> gets set (or not) by the library/framework/environment, is completely irrelevant.</p> <p>The <code>var context = this</code> line is critical to the trick. It defines a LEXICAL variable <code>context</code>, which is not some special keyword, holding a snapshot of the value in the outer <code>this</code>. Then inside <code>clickHandler</code>, we merely reference a LEXICAL variable (<code>context</code>), no relative/magic <code>this</code> keyword.</p>"},{"location":"objects-classes/ch4/#lexical-this","title":"Lexical This","text":"<p>The name for this pattern, by the way, is \"LEXICAL this\", meaning a <code>this</code> that behaves like a LEXICAL scope variable instead of like a dynamic context binding.</p> <p>But it turns out JS has an easier way of performing the \"LEXICAL this\" magic trick. Are you ready for the trick reveal!?</p> <p>...</p> <p>The <code>=&gt;</code> arrow function! Tada!</p> <p>That's right, the <code>=&gt;</code> function is, unlike all other function forms, special, in that it's not special at all. Or, rather, that it doesn't define anything special for <code>this</code> behavior whatsoever.</p> <p>In an <code>=&gt;</code> function, the <code>this</code> keyword... is not a keyword. It's absolutely no different from any other variable, like <code>context</code> or <code>happyFace</code> or <code>foobarbaz</code>.</p> <p>Let me illustrate this point more directly:</p> <pre><code>function outer() {\nconsole.log(this.value);\n// define a return an \"inner\"\n// function\nvar inner = () =&gt; {\nconsole.log(this.value);\n};\nreturn inner;\n}\nvar one = {\nvalue: 42,\n};\nvar two = {\nvalue: \"sad face\",\n};\nvar innerFn = outer.call(one);\n// 42\ninnerFn.call(two);\n// 42   &lt;-- not \"sad face\"\n</code></pre> <p>The <code>innerFn.call(two)</code> would, for any regular function definition, have resulted in <code>\"sad face\"</code> here. But since the <code>inner</code> function we defined and returned (and assigned to <code>innerFn</code>) was an irregular <code>=&gt;</code> arrow function, it has no special <code>this</code> behavior, but instead has \"LEXICAL this\" behavior.</p> <p>When the <code>innerFn(..)</code> (aka <code>inner(..)</code>) function is invoked, even with an explicit context assignment via <code>.call(..)</code>, that assignment is ignored.</p> NOTE: I'm not sure why <code>=&gt;</code> arrow functions even have a <code>call(..)</code> / <code>apply(..)</code> on them, since they are silent no-op functions. I guess it's for consistency with normal functions. But as we'll see later, there are other inconsistencies between regular functions and irregular <code>=&gt;</code> arrow functions. <p>When a <code>this</code> is encountered (<code>this.value</code>) inside an <code>=&gt;</code> arrow function, <code>this</code> is treated like a normal LEXICAL variable, not a special keyword. And since there is no <code>this</code> variable in that function itself, JS does what it always does with LEXICAL variables: it goes up one level of LEXICAL scope -- in this case, to the surrounding <code>outer(..)</code> function, and it checks to see if there's any registered <code>this</code> in that scope.</p> <p>Luckily, <code>outer(..)</code> is a regular function, which means it has a normal <code>this</code> keyword. And the <code>outer.call(one)</code> invocation assigned <code>one</code> to its <code>this</code>.</p> <p>So, <code>innerFn.call(two)</code> is invoking <code>inner()</code>, but when <code>inner()</code> looks up a value for <code>this</code>, it gets... <code>one</code>, not <code>two</code>.</p>"},{"location":"objects-classes/ch4/#back-to-the-button","title":"Back To The... Button","text":"<p>You thought I was going to make a pun joke and say \"future\" there, didn't you!?</p> <p>A more direct and appropriate way of solving our earlier issue, where we had done <code>var context = this</code> to get a sort of faked \"LEXICAL this\" behavior, is to use the <code>=&gt;</code> arrow function, since its primary design feature is... \"LEXICAL this\".</p> <pre><code>this.submitBtn.addEventListener(\n\"click\",\nevt =&gt; this.clickHandler(evt),\nfalse\n);\n</code></pre> <p>Boom! Problem solved! Mic drop!</p> <p>Hear me on this: the <code>=&gt;</code> arrow function is not -- I repeat, not -- about typing fewer characters. The primary point of the <code>=&gt;</code> function being added to JS was to give us \"LEXICAL this\" behavior without having to resort to <code>var context = this</code> (or worse, <code>var self = this</code>) style hacks.</p> TIP: If you need \"LEXICAL this\", always prefer an <code>=&gt;</code> arrow function. If you don't need \"LEXICAL this\", well... the <code>=&gt;</code> arrow function might not be the best tool for the job."},{"location":"objects-classes/ch4/#confession-time","title":"Confession Time","text":"<p>I've said all along in this chapter, that how you write a function, and where you write the function, has nothing to do with how its <code>this</code> will be assigned.</p> <p>For regular functions, that's true. But when we consider an irregular <code>=&gt;</code> arrow function, it's not entirely accurate anymore.</p> <p>Recall the original <code>=&gt;</code> form of <code>clickHandler</code> from earlier in the chapter?</p> <pre><code>const clickHandler = evt =&gt;\nevt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation();\n</code></pre> <p>If we use that form, in the same context as our event binding, it could look like this:</p> <pre><code>const clickHandler = evt =&gt;\nevt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation();\nthis.submitBtn.addEventListener(\"click\",clickHandler,false);\n</code></pre> <p>A lot of developers prefer to even further reduce it, to an inline <code>=&gt;</code> arrow function:</p> <pre><code>this.submitBtn.addEventListener(\n\"click\",\nevt =&gt; evt.target.matches(\"button\") ?\nthis.theFormElem.submit() :\nevt.stopPropagation(),\nfalse\n);\n</code></pre> <p>When we write an <code>=&gt;</code> arrow function, we know for sure that its <code>this</code> binding will exactly be the current <code>this</code> binding of whatever surrounding function is running, regardless of what the call-site of the <code>=&gt;</code> arrow function looks like. So in other words, how we wrote the <code>=&gt;</code> arrow function, and where we wrote it, does matter.</p> <p>That doesn't fully answer the <code>this</code> question, though. It just shifts the question to how the enclosing function was invoked. Actually, the focus on the call-site is still the only thing that matters.</p> <p>But the nuance I'm confessing to having omitted until this moment is: it matters which call-site we consider, not just any call-site in the current call stack. The call-site that matters is, the nearest function-invocation in the current call stack that actually assigns a <code>this</code> context.</p> <p>Since an <code>=&gt;</code> arrow function never has a <code>this</code>-assigning call-site (no matter what), that call-site isn't relevant to the question. We have to keep stepping up the call stack until we find a function invocation that is <code>this</code>-assigning -- even if such invoked function is not itself <code>this</code>-aware.</p> <p>THAT is the only call-site that matters.</p>"},{"location":"objects-classes/ch4/#find-the-right-call-site","title":"Find The Right Call-Site","text":"<p>Let me illustrate, with a convoluted mess of a bunch of nested functions/calls:</p> <pre><code>globalThis.value = { result: \"Sad face\" };\nfunction one() {\nfunction two() {\nvar three = {\nvalue: { result: \"Hmmm\" },\nfn: () =&gt; {\nconst four = () =&gt; this.value;\nreturn four.call({\nvalue: { result: \"OK\", },\n});\n},\n};\nreturn three.fn();\n};\nreturn two();\n}\nnew one();          // ???\n</code></pre> <p>Can you run through that (nightmare) in your head and determine what will be returned from the <code>new one()</code> invocation?</p> <p>It could be any of these:</p> <pre><code>// from `four.call(..)`:\n{ result: \"OK\" }\n// or, from `three` object:\n{ result: \"Hmmm\" }\n// or, from the `globalThis.value`:\n{ result: \"Sad face\" }\n// or, empty object from the `new` call:\n{}\n</code></pre> <p>The call-stack for that <code>new one()</code> invocation is:</p> <pre><code>four         |\nthree.fn     |\ntwo          | (this = globalThis)\none          | (this = {})\n[ global ]   | (this = globalThis)\n</code></pre> <p>Since <code>four()</code> and <code>fn()</code> are both <code>=&gt;</code> arrow functions, the <code>three.fn()</code> and <code>four.call(..)</code> call-sites are not <code>this</code>-assigning; thus, they're irrelvant for our query. What's the next invocation to consider in the call-stack? <code>two()</code>. That's a regular function (it can accept <code>this</code>-assignment), and the call-site matches the default context assignment rule (#4). Since we're not in strict-mode, <code>this</code> is assigned <code>globalThis</code>.</p> <p>When <code>four()</code> is running, <code>this</code> is just a normal variable. It looks then to its containing function (<code>three.fn()</code>), but it again finds a function with no <code>this</code>. So it goes up another level, and finds a <code>two()</code> regular function that has a <code>this</code> defined. And that <code>this</code> is <code>globalThis</code>. So the <code>this.value</code> expression resolves to <code>globalThis.value</code>, which returns us... <code>{ result: \"Sad face\" }</code>.</p> <p>...</p> <p>Take a deep breath. I know that's a lot to mentally process. And in fairness, that's a super contrived example. You'll almost never see all that complexity mixed in one call-stack.</p> <p>But you absolutely will find mixed call-stacks in real programs. You need to get comfortable with the analysis I just illustrated, to be able to unwind the call-stack until you find the most recent <code>this</code>-assigning call-site.</p> <p>Remember the addage I quoted earlier: \"with great power comes great responsibility\". Choosing <code>this</code>-oriented code (even <code>class</code>es) means choosing both the flexibility it affords us, as well as needing to be comfortable navigating the call-stack to understand how it will behave.</p> <p>That's the only way to effectively write (and later read!) <code>this</code>-aware code.</p>"},{"location":"objects-classes/ch4/#this-is-bound-to-come-up","title":"This Is Bound To Come Up","text":"<p>Backing up a bit, there's another option if you don't want to use an <code>=&gt;</code> arrow function's \"LEXICAL this\" behavior to address the button event handler functionality.</p> <p>In addition to <code>call(..)</code> / <code>apply(..)</code> -- these invoke functions, remember! -- JS functions also have a third utility built in, called <code>bind(..)</code> -- which does not invoke the function, just to be clear.</p> <p>The <code>bind(..)</code> utility defines a new wrapped/bound version of a function, where its <code>this</code> is preset and fixed, and cannot be overridden with a <code>call(..)</code> or <code>apply(..)</code>, or even an implicit context object at the call-site:</p> <pre><code>this.submitBtn.addEventListener(\n\"click\",\nthis.clickHandler.bind(this),\nfalse\n);\n</code></pre> <p>Since I'm passing in a <code>this</code>-bound function as the event handler, it similarly doesn't matter how that utility tries to set a <code>this</code>, because I've already forced the <code>this</code> to be what I wanted: the value of <code>this</code> from the surrounding function invocation context.</p>"},{"location":"objects-classes/ch4/#hardly-new","title":"Hardly New","text":"<p>This pattern is often referred to as \"hard binding\", since we're creating a function reference that is strongly bound to a particular <code>this</code>. A lot of JS writings have claimed that the <code>=&gt;</code> arrow function is essentially just syntax for the <code>bind(this)</code> hard-binding. It's not. Let's dig in.</p> <p>If you were going to create a <code>bind(..)</code> utility, it might look kinda like this:</p> <pre><code>function bind(fn,context) {\nreturn function bound(...args){\nreturn fn.apply(context,args);\n};\n}\n</code></pre> NOTE: This is not actually how <code>bind(..)</code> is implemented. The behavior is more sophisticated and nuanced. I'm only illustrating one portion of its behavior in this snippet. <p>Does that look familiar? It's using the good ol' fake \"LEXICAL this\" hack. And under the covers, it's an explicit context assignment, in this case via <code>apply(..)</code>.</p> <p>So wait... doesn't that mean we could just do it with an <code>=&gt;</code> arrow function?</p> <pre><code>function bind(fn,context) {\nreturn (...args) =&gt; fn.apply(context,args);\n}\n</code></pre> <p>Eh... not quite. As with most things in JS, there's a bit of nuance. Let me illustrate:</p> <pre><code>// candidate implementation, for comparison\nfunction fakeBind(fn,context) {\nreturn (...args) =&gt; fn.apply(context,args);\n}\n// test subject\nfunction thisAwareFn() {\nconsole.log(`Value: ${this.value}`);\n}\n// control data\nvar obj = {\nvalue: 42,\n};\n// experiment\nvar f = thisAwareFn.bind(obj);\nvar g = fakeBind(thisAwareFn,obj);\nf();            // Value: 42\ng();            // Value: 42\nnew f();        // Value: undefined\nnew g();        // &lt;--- ???\n</code></pre> <p>First, look at the <code>new f()</code> call. That's admittedly a strange usage, to call <code>new</code> on a hard-bound function. It's probably quite rare that you'd ever do so. But it shows something kind of interesting. Even though <code>f()</code> was hard-bound to a <code>this</code> context of <code>obj</code>, the <code>new</code> operator was able to hijack the hard-bound function's <code>this</code> and re-bind it to the newly created and empty object. That object has no <code>value</code> property, which is why we see <code>\"Value: undefined\"</code> printed out.</p> <p>If that feels strange, I agree. It's a weird corner nuance. It's not something you'd likely ever exploit. But I point it out not just for trivia. Refer back to the four rules presented earlier in this chapter. Remember how I asserted their order-of-precedence, and <code>new</code> was at the top (#1), ahead of explicit <code>call(..)</code> / <code>apply(..)</code> assignment rule (#2)?</p> <p>Since we can sort of think of <code>bind(..)</code> as a variation of that rule, we now see that order-of-precedence proven. <code>new</code> is more precedent than, and can override, even a hard-bound function. Sort of makes you think the hard-bound function is maybe not so \"hard\"-bound, huh?!</p> <p>But... what's going to happen with the <code>new g()</code> call, which is invoking <code>new</code> on the returned <code>=&gt;</code> arrow function? Do you predict the same outcome as <code>new f()</code>?</p> <p>Sorry to disappoint.</p> <p>That line will actually throw an exception, because an <code>=&gt;</code> function cannot be used with the <code>new</code> keyword.</p> <p>But why? My best answer, not being authoritative on TC39 myself, is that conceptually and actually, an <code>=&gt;</code> arrow function is not a function with a hard-bound <code>this</code>, it's a function that has no <code>this</code> at all. As such, <code>new</code> makes no sense against such a function, so JS just disallows it.</p> NOTE: Recall earlier, when I pointed out that <code>=&gt;</code> arrow functions have <code>call(..)</code>, <code>apply(..)</code>, and indeed even a <code>bind(..)</code>. But we've see that such functions basically ignore these utilities as no-ops. It's a bit strange, in my opinion, that <code>=&gt;</code> arrow functions have all those utilties as pass-through no-ops, but for the <code>new</code> keyword, that's not just, again, a no-op pass-through, but rather disallowed with an exception. <p>But the main point is: an <code>=&gt;</code> arrow function is not a syntactic form of <code>bind(this)</code>.</p>"},{"location":"objects-classes/ch4/#losing-this-battle","title":"Losing This Battle","text":"<p>Returning once again to our button event handler example:</p> <pre><code>this.submitBtnaddEventListener(\n\"click\",\nthis.clickHandler,\nfalse\n);\n</code></pre> <p>There's a deeper concern we haven't yet addressed.</p> <p>We've seen several different approaches to construct a different callback function reference to pass in there, in place of <code>this.clickHandler</code>.</p> <p>But whichever of those ways we choose, they are producing literally a different function, not just an in-place modification to our existing <code>clickHandler</code> function.</p> <p>Why does that matter?</p> <p>Well, first of all, the more functions we create (and re-create), the more processing time (very slight) and the more memory (pretty small, usually) we're chewing up. And when we're re-creating a function reference, and throwing an old one away, that's also leaving un-reclaimed memory sitting around, which puts pressure on the garbage collector (GC) to more often, pause the universe of our program momentarily while it cleans up and reclaims that memory.</p> <p>If hooking up this event listening is a one-time operation, no big deal. But if it's happening over and over again, the system-level performance effects can start to add up. Ever had an otherwise smooth animation jitter? That was probably the GC kicking in, cleaning up a bunch of reclaimable memory.</p> <p>But another concern is, for things like event handlers, if we're going to remove an event listener at some later time, we need to keep a reference to the exact same function we attached originally. If we're using a library/framework, often (but not always!) they take care of that little dirty-work detail for you. But otherwise, it's on us to make sure that whatever function we plan to attach, we hold onto a reference just in case we need it later.</p> <p>So the point I'm making is: presetting a <code>this</code> assignment, no matter how you do it, so that it's predictable, comes with a cost. A system level cost and a program maintenance/complexity cost. It is never free.</p> <p>One way of reacting to that fact is to decide, OK, we're just going to manufacture all those <code>this</code>-assigned function references once, ahead of time, up-front. That way, we're sure to reduce both the system pressure, and the code pressure, to a minimum.</p> <p>Sounds reasonable, right? Not so fast.</p>"},{"location":"objects-classes/ch4/#pre-binding-function-contexts","title":"Pre-Binding Function Contexts","text":"<p>If you have a one-off function reference that needs to be <code>this</code>-bound, and you use an <code>=&gt;</code> arrow or a <code>bind(this)</code> call, I don't see any problems with that.</p> <p>But if most or all of the <code>this</code>-aware functions in a segment of your code invoked in ways where the <code>this</code> isn't the predictable context you expect, and so you decide you need to hard-bind them all... I think that's a big warning signal that you're going about things the wrong way.</p> <p>Please recall the discussion in the \"Avoid This\" section from Chapter 3, which started with this snippet of code:</p> <pre><code>class Point2d {\nx = null\ngetDoubleX = () =&gt; this.x * 2\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\n}\ntoString() { /* .. */ }\n}\nvar point = new Point2d(3,4);\n</code></pre> <p>Now imagine we did this with that code:</p> <pre><code>const getX = point.getDoubleX;\n// later, elsewhere\ngetX();         // 6\n</code></pre> <p>As you can see, the problem we were trying to solve is the same as we've been dealing with here in this chapter. It's that we wanted to be able to invoke a function reference like <code>getX()</code>, and have that mean and behave like <code>point.getDoubleX()</code>. But <code>this</code> rules on regular functions don't work that way.</p> <p>So we used an <code>=&gt;</code> arrow function. No big deal, right!?</p> <p>Wrong.</p> <p>The real root problem is that we want two conflicting things out of our code, and we're trying to use the same hammer for both nails.</p> <p>We want to have a <code>this</code>-aware method stored on the <code>class</code> prototype, so that there's only one definition for the function, and all our subclasses and instances nicely share that same function. And the way they all share is through the power of the dynamic <code>this</code> binding.</p> <p>But at the same time, we also want those function references to magically stay <code>this</code>-assinged to our instance when we pass those function references around and other code is in charge of the call-site.</p> <p>In other words, sometimes we want something like <code>point.getDoubleX</code> to mean, \"give me a reference that's <code>this</code>-assigned to <code>point</code>\", and other times we want the same expression <code>point.getDoubleX</code> to mean, give me a dynamic <code>this</code>-assignable function reference so it can properly get the context I need it to at this moment.</p> <p>Perhaps JS could offer a different operator besides <code>.</code>, like <code>::</code> or <code>-&gt;</code> or something like that, which would let you distinguish what kind of function reference you're after. In fact, there's a long-standing proposal for a <code>this</code>-binding operator (<code>::</code>), that picks up attention from time to time, and then seems to stall out. Who knows, maybe someday such an operator will finally land, and we'll have better options.</p> <p>But I strongly suspect that even if it does land someday, it's going to vend a whole new function reference, exactly as the <code>=&gt;</code> or <code>bind(this)</code> approaches we've already talked about. It won't come as a free and perfect solution. There will always be a tension between wanting the same function to sometimes be <code>this</code>-flexible and sometimes be <code>this</code>-predictable.</p> <p>What JS authors of <code>class</code>-oriented code often run up against, sooner or later, is this exact tension. And you know what they do?</p> <p>They don't consider the costs of simply pre-binding all the class's <code>this</code>-aware methods as instead <code>=&gt;</code> arrow functions in member properties. They don't realize that it's completely defeated the entire purpose of the <code>[[Prototype]]</code> chain. And they don't realize that if fixed-context is what they really need, there's an entirely different mechanism in JS that is better suited for that purpose.</p>"},{"location":"objects-classes/ch4/#take-a-more-critical-look","title":"Take A More Critical Look","text":"<p>So when you do this sort of thing:</p> <pre><code>class Point2d {\nx = null\ny = null\ngetDoubleX = () =&gt; this.x * 2\ntoString = () =&gt; `(${this.x},${this.y})`\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\n}\n}\nvar point = new Point2d(3,4);\nvar anotherPoint = new Point2d(5,6);\nvar f = point.getDoubleX;\nvar g = anotherPoint.toString;\nf();            // 6\ng();            // (5,6)\n</code></pre> <p>I say, \"ick!\", to the hard-bound <code>this</code>-aware methods <code>getDoubleX()</code> and <code>toString()</code> there. To me, that's a code smell. But here's an even worse approach that has been favored by many developers in the past:</p> <pre><code>class Point2d {\nx = null\ny = null\nconstructor(x,y) {\nthis.x = x;\nthis.y = y;\nthis.getDoubleX = this.getDoubleX.bind(this);\nthis.toString = this.toString.bind(this);\n}\ngetDoubleX() { return this.x * 2; }\ntoString() { return `(${this.x},${this.y})`; }\n}\nvar point = new Point2d(3,4);\nvar anotherPoint = new Point2d(5,6);\nvar f = point.getDoubleX;\nvar g = anotherPoint.toString;\nf();            // 6\ng();            // (5,6)\n</code></pre> <p>Double ick.</p> <p>In both cases, you're using a <code>this</code> mechanism but completely betraying/neutering it, by taking away all the powerful dynamicism of <code>this</code>.</p> <p>You really should at least be contemplating this alternate approach, which skips the whole <code>this</code> mechanism altogether:</p> <pre><code>function Point2d(px,py) {\nvar x = px;\nvar y = py;\nreturn {\ngetDoubleX() { return x * 2; },\ntoString() { return `(${x},${y})`; }\n};\n}\nvar point = Point2d(3,4);\nvar anotherPoint = Point2d(5,6);\nvar f = point.getDoubleX;\nvar g = anotherPoint.toString;\nf();            // 6\ng();            // (5,6)\n</code></pre> <p>You see? No ugly or complex <code>this</code> to clutter up that code or worry about corner cases for. Lexical scope is super straightforward and intuitive.</p> <p>When all we want is for most/all of our function behaviors to have a fixed and predictable context, the most appropriate solution, the most straightfoward and even performant solution, is LEXICAL variables and scope closure.</p> <p>When you go to all to the trouble of sprinkling <code>this</code> references all over a piece of code, and then you cut off the whole mechanism at the knees with <code>=&gt;</code> \"LEXICAL this\" or <code>bind(this)</code>, you chose to make the code more verbose, more complex, more overwrought. And you got nothing out of it that was more beneficial, except to follow the <code>this</code> (and <code>class</code>) bandwagon.</p> <p>...</p> <p>Deep breath. Collect yourself.</p> <p>I'm talking to myself, not you. But if what I just said bothers you, I'm talking to you, too!</p> <p>OK, listen. That's just my opinion. If you don't agree, that's fine. But apply the same level of rigor to thinking about how these mechanisms work, as I have, when you decide what conclusions you want to arrive at.</p>"},{"location":"objects-classes/ch4/#variations","title":"Variations","text":"<p>Before we close out our lengthy discussion of <code>this</code>, there's a few irregular variations on function calls that we should discuss.</p>"},{"location":"objects-classes/ch4/#indirect-function-calls","title":"Indirect Function Calls","text":"<p>Recall this example from earlier in the chapter?</p> <pre><code>var point = {\nx: null,\ny: null,\ninit(x,y) {\nthis.x = x;\nthis.y = y;\n},\nrotate(angleRadians) { /* .. */ },\ntoString() { /* .. */ },\n};\nvar init = point.init;\ninit(3,4);                  // broken!\n</code></pre> <p>This is broken because the <code>init(3,4)</code> call-site doesn't provide the necessary <code>this</code>-assignment signal. But there's other ways to observe a similar breakage. For example:</p> <pre><code>(1,point.init)(3,4);        // broken!\n</code></pre> <p>This strange looking syntax is first evaluating an expression <code>(1,point.init)</code>, which is a comma series expression. The result of such an expression is the final evaluated value, which in this case is the function reference (held by <code>point.init</code>).</p> <p>So the outcome puts that function reference onto the expression stack, and then invokes that value with <code>(3,4)</code>. That's an indirect invocation of the function. And what's the result? It actually matches the default context assignment rule (#4) we looked at earlier in the chapter.</p> <p>Thus, in non-strict mode, the <code>this</code> for the <code>point.init(..)</code> call will be <code>globalThis</code>. Had we been in strict-mode, it would have been <code>undefined</code>, and the <code>this.x = x</code> operation would then have thrown an exception for invalidly accessing the <code>x</code> property on the <code>undefined</code> value.</p> <p>There's several different ways to get an indirect function invocation. For example:</p> <pre><code>(()=&gt;point.init)()(3,4);    // broken!\n</code></pre> <p>And another example of indirect function invocation is the Immediately Invoked Function Expression (IIFE) pattern:</p> <pre><code>(function(){\n// `this` assigned via \"default\" rule\n})();\n</code></pre> <p>As you can see, the function expression value is put onto the expression stack, and then it's invoked with the <code>()</code> on the end.</p> <p>But what about this code:</p> <pre><code>(point.init)(3,4);\n</code></pre> <p>What will be the outcome of that code?</p> <p>By the same reasoning we've seen in the previous examples, it stands to reason that the <code>point.init</code> expression puts the function value onto the expression stack, and then invoked indirectly with <code>(3,4)</code>.</p> <p>Not quite, though! JS grammar has a special rule to handle the invocation form <code>(someIdentifier)(..)</code> as if it had been <code>someIdentifier(..)</code> (without the <code>(..)</code> around the identifier name).</p> <p>Wondering why you might want to ever force the default context for <code>this</code> assignment via an indirect function invocation?</p>"},{"location":"objects-classes/ch4/#accessing-globalthis","title":"Accessing <code>globalThis</code>","text":"<p>Before we answer that, let's introduce another way of performing indirect function <code>this</code> assignment. Thus far, the indirect function invocation patterns shown are sensitive to strict-mode. But what if we wanted an indirect function <code>this</code> assignment that doesn't respect strict-mode.</p> <p>The <code>Function(..)</code> constructor takes a string of code and dynamically defines the equivalent function. However, it always does so as if that function had been declared in the global scope. And furthermore, it ensures such function does not run in strict-mode, no matter the strict-mode status of the program. That's the same outcome as running an indirect</p> <p>One niche usage of such strict-mode agnostic indirect function <code>this</code> assignment is for getting a reliable reference to the true global object prior to when the JS specification actually defined the <code>globalThis</code> identifier (for example, in a polyfill for it):</p> <pre><code>\"use strict\";\nvar gt = new Function(\"return this\")();\ngt === globalThis;                      // true\n</code></pre> <p>In fact, a similar outcome, using the comma operator trick (see previous section) and <code>eval(..)</code>:</p> <pre><code>\"use strict\";\nfunction getGlobalThis() {\nreturn (1,eval)(\"this\");\n}\ngetGlobalThis() === globalThis;      // true\n</code></pre> NOTE: <code>eval(\"this\")</code> would be sensitive to strict-mode, but <code>(1,eval)(\"this\")</code> is not, and therefor reliably gives us the <code>globalThis</code> in any program. <p>Unfortunately, the <code>new Function(..)</code> and <code>(1,eval)(..)</code> approaches both have an important limitation: that code will be blocked in browser-based JS code if the app is served with certain Content-Security-Policy (CSP) restrictions, disallowing dynamic code evaluation (for security reasons).</p> <p>Can we get around this? Yes, mostly. 1</p> <p>The JS specification says that a getter function defined on the global object, or on any object that inherits from it (like <code>Object.prototype</code>), runs the getter function with <code>this</code> context assigned to <code>globalThis</code>, regardless of the program's strict-mode.</p> <pre><code>// Adapted from: https://mathiasbynens.be/notes/globalthis#robust-polyfill\nfunction getGlobalThis() {\nObject.defineProperty(Object.prototype,\"__get_globalthis__\",{\nget() { return this; },\nconfigurable: true\n});\nvar gt = __get_globalthis__;\ndelete Object.prototype.__get_globalthis__;\nreturn gt;\n}\ngetGlobalThis() === globalThis;      // true\n</code></pre> <p>Yeah, that's super gnarly. But that's JS <code>this</code> for you!</p>"},{"location":"objects-classes/ch4/#template-tag-functions","title":"Template Tag Functions","text":"<p>There's one more unusual variation of function invocation we should cover: tagged template functions.</p> <p>Template strings -- what I prefer to call interpolated literals -- can be \"tagged\" with a prefix function, which is invoked with the parsed contents of the template literal:</p> <pre><code>function tagFn(/* .. */) {\n// ..\n}\ntagFn`actually a function invocation!`;\n</code></pre> <p>As you can see, there's no <code>(..)</code> invocation syntax, just the tag function (<code>tagFn</code>) appearing before the <code>`template literal`</code>; whitespace is allowed between them, but is very uncommon.</p> <p>Despite the strange appearance, the function <code>tagFn(..)</code> will be invoked. It's passed the list of one or more string literals that were parsed from the template literal, along with any interpolated expression values that were encountered.</p> <p>We're not going to cover all the ins and outs of tagged template functions -- they're seriously one of the most powerful and interesting features ever added to JS -- but since we're talking about <code>this</code> assignment in function invocations, for completeness sake we need to talk about how <code>this</code> will be assigned.</p> <p>The other form for tag functions you may encounter is:</p> <pre><code>var someObj = {\ntagFn() { /* .. */ }\n};\nsomeObj.tagFn`also a function invocation!`;\n</code></pre> <p>Here's the easy explanation: <code>tagFn`..`</code> and <code>someObj.tagFn`..`</code> will each have <code>this</code>-assignment behavior corresponding to call-sites as <code>tagFn(..)</code> and <code>someObj.tagFn(..)</code>, respectively. In other words, <code>tagFn`..`</code> behaves by the default context assignment rule (#4), and <code>someObj.tagFn`..`</code> behaves by the implicit context assignment rule (#3).</p> <p>Luckily for us, we don't need to worry about the <code>new</code> or <code>call(..)</code> / <code>apply(..)</code> assignment rules, as those forms aren't possible with tag functions.</p> <p>It should be pointed out that it's pretty rare for a tagged template literal function to be defined as <code>this</code>-aware, so it's fairly unlikely you'll need to apply these rules. But just in case, now you're in the know.</p>"},{"location":"objects-classes/ch4/#stay-aware","title":"Stay Aware","text":"<p>So, that's <code>this</code>. I'm willing to bet for many of you, it was a bit more... shall we say, involved... than you might have been expecting.</p> <p>The good news, perhaps, is that in practice you don't often trip over all these different complexities. But the more you use <code>this</code>, the more it requires you, and the readers of your code, to understand how it actually works.</p> <p>The lesson here is that you should be intentional and aware of all aspects of <code>this</code> before you go sprinkling it about your code. Make sure you're using it most effectively and taking full advantage of this important pillar of JS.</p> <ol> <li> <p>\"A horrifying globalThis polyfill in universal JavaScript\"; Mathias Bynens; April 18 2019; https://mathiasbynens.be/notes/globalthis#robust-polyfill ; Accessed July 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"objects-classes/ch5/","title":"Chapter 5: Delegation","text":"NOTE: Work in progress <p>We've thoroughly explored objects, prototypes, classes, and now the <code>this</code> keyword. But we're now going to revisit what we've learned so far from a bit of a different perspective.</p> <p>What if you could leverage all the power of the objects, prototypes, and dynamic <code>this</code> mechanisms together, without ever using <code>class</code> or any of its descendants?</p> <p>In fact, I would argue JS is inherently less class-oriented than the <code>class</code> keyword might appear. Because JS is a dynamic, prototypal language, its strong suit is actually... delegation.</p>"},{"location":"objects-classes/ch5/#preamble","title":"Preamble","text":"<p>Before we begin looking at delegation, I want to offer a word of caution. This perspective on JS's object <code>[[Prototype]]</code> and <code>this</code> function context mechanisms is not mainstream. It's not how framework authors and libraries utilize JS. You won't, to my knowledge, find any big apps out there using this pattern.</p> <p>So why on earth would I devote a chapter to such a pattern, if it's so unpopular?</p> <p>Good question. The cheeky answer is: because it's my book and I can do what I feel like!</p> <p>But the deeper answer is, because I think developing this understanding of one of the language's core pillars helps you even if all you ever do is use <code>class</code>-style JS patterns.</p> <p>To be clear, delegation is not my invention. It's been around as a design pattern for decades. And for a long time, developers argued that prototypal delegation was just the dynamic form of inheritance.1 But I think that was a mistake to conflate the two.2</p> <p>For the purposes of this chapter, I'm going to present delegation, as implemented via JS mechanics, as an alternative design pattern, positioned somewhere between class-orientation and object-closure/module patterns.</p> <p>The first step is to de-construct the <code>class</code> mechanism down to its individual parts. Then we'll cherry-pick and mix the parts a bit differently.</p>"},{"location":"objects-classes/ch5/#whats-a-constructor-anyway","title":"What's A Constructor, Anyway?","text":"<p>In Chapter 3, we saw <code>constructor(..)</code> as the main entry point for construction of a <code>class</code> instance. But the <code>constructor(..)</code> doesn't actually do any creation work, it's only initialization work. In other words, the instance is already created by the time the <code>constructor(..)</code> runs and initializes it -- e.g., <code>this.whatever</code> types of assignments.</p> <p>So where does the creation work actually happen? In the <code>new</code> operator. As the section \"New Context Invocation\" in Chapter 4 explains, there are four steps the <code>new</code> keyword performs; the first of those is the creation of a new empty object (the instance). The <code>constructor(..)</code> isn't even invoked until step 3 of <code>new</code>'s efforts.</p> <p>But <code>new</code> is not the only -- or perhaps even, best -- way to create an object \"instance\". Consider:</p> <pre><code>// a non-class \"constructor\"\nfunction Point2d(x,y) {\n// create an object (1)\nvar instance = {};\n// initialize the instance (3)\ninstance.x = x;\ninstance.y = y;\n// return the instance (4)\nreturn instance;\n}\nvar point = Point2d(3,4);\npoint.x;                    // 3\npoint.y;                    // 4\n</code></pre> <p>There's no <code>class</code>, just a regular function definition (<code>Point2d(..)</code>). There's no <code>new</code> invocation, just a regular function call (<code>Point2d(3,4)</code>). And there's no <code>this</code> references, just regular object property assignments (<code>instance.x = ..</code>).</p> <p>The term that's most often used to refer to this pattern of code is that <code>Point2d(..)</code> here is a factory function. Invoking it causes the construction (creation and initialization) of an object, and returns that back to us. That's an extremely common pattern, at least as common as class-oriented code.</p> <p>I comment-annotated <code>(1)</code>, <code>(3)</code>, and <code>(4)</code> in that snippet, which roughly correspond to steps 1, 3, and 4 of the <code>new</code> operation. But where's step 2?</p> <p>If you recall, step 2 of <code>new</code> is about linking the object (created in step 1) to another object, via its <code>[[Prototype]]</code> slot (see Chapter 2). So what object might we want to link our <code>instance</code> object to? We could link it to an object that holds functions we'd like to associate/use with our instance.</p> <p>Let's amend the previous snippet:</p> <pre><code>var prototypeObj = {\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n}\n// a non-class \"constructor\"\nfunction Point2d(x,y) {\n// create an object (1)\nvar instance = {\n// link the instance's [[Prototype]] (2)\n__proto__: prototypeObj,\n};\n// initialize the instance (3)\ninstance.x = x;\ninstance.y = y;\n// return the instance (4)\nreturn instance;\n}\nvar point = Point2d(3,4);\npoint.toString();           // (3,4)\n</code></pre> <p>Now you see the <code>__proto__</code> assignment that's setting up the internal <code>[[Prototype]]</code> linkage, which was the missing step 2. I used the <code>__proto__</code> here merely for illustration purposes; using <code>setPrototypeOf(..)</code> as shown in Chapter 4 would have accomplished the same task.</p>"},{"location":"objects-classes/ch5/#new-factory-instance","title":"New Factory Instance","text":"<p>What do you think would happen if we used <code>new</code> to invoke the <code>Point2d(..)</code> function as shown here?</p> <pre><code>var anotherPoint = new Point2d(5,6);\nanotherPoint.toString(5,6);         // (5,6)\n</code></pre> <p>Wait! What's going on here? A regular, non-<code>class</code> factory function in invoked with the <code>new</code> keyword, as if it was a <code>class</code>. Does that change anything about the outcome of the code?</p> <p>No... and yes. <code>anotherPoint</code> here is exactly the same object as it would have been had I not used <code>new</code>. But! The object that <code>new</code> creates, links, and assigns as <code>this</code> context? That object was completely ignored and thrown away, ultimately to be garbage collected by JS. Unfortunately, the JS engine cannot predict that you're not going to use the object that you asked <code>new</code> to create, so it always still gets cteated even if it goes unused.</p> <p>That's right! Using a <code>new</code> keyword against a factory function might feel more ergonomic or familiar, but it's quite wasteful, in that it creates two objects, and wastefully throws one of them away.</p>"},{"location":"objects-classes/ch5/#factory-initialization","title":"Factory Initialization","text":"<p>In the current code example, the <code>Point2d(..)</code> function still looks an awful lot like a normal <code>constructor(..)</code> of a <code>class</code> definition. But what if we moved the initialization code to a separate function, say named <code>init(..)</code>:</p> <pre><code>var prototypeObj = {\ninit(x,y) {\n// initialize the instance (3)\nthis.x = x;\nthis.y = y;\n},\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n}\n// a non-class \"constructor\"\nfunction Point2d(x,y) {\n// create an object (1)\nvar instance = {\n// link the instance's [[Prototype]] (2)\n__proto__: prototypeObj,\n};\n// initialize the instance (3)\ninstance.init(x,y);\n// return the instance (4)\nreturn instance;\n}\nvar point = Point2d(3,4);\npoint.toString();           // (3,4)\n</code></pre> <p>The <code>instance.init(..)</code> call makes use of the <code>[[Prototype]]</code> linkage set up via <code>__proto__</code> assignment. Thus, it delegates up the prototype chain to <code>prototypeObj.init(..)</code>, and invokes it with a <code>this</code> context of <code>instance</code> -- via implicit context assignment (see Chapter 4).</p> <p>Let's continue the deconstruction. Get ready for a switcheroo!</p> <pre><code>var Point2d = {\ninit(x,y) {\n// initialize the instance (3)\nthis.x = x;\nthis.y = y;\n},\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n};\n</code></pre> <p>Whoa, what!? I discarded the <code>Point2d(..)</code> function, and instead renamed the <code>prototypeObj</code> as <code>Point2d</code>. Weird.</p> <p>But let's look at the rest of the code now:</p> <pre><code>// steps 1, 2, and 4\nvar point = { __proto__: Point2d, };\n// step 3\npoint.init(3,4);\npoint.toString();           // (3,4)\n</code></pre> <p>And one last refinement: let's use a built-in utility JS provides us, called <code>Object.create(..)</code>:</p> <pre><code>// steps 1, 2, and 4\nvar point = Object.create(Point2d);\n// step 3\npoint.init(3,4);\npoint.toString();           // (3,4)\n</code></pre> <p>What operations does <code>Object.create(..)</code> perform?</p> <ol> <li> <p>create a brand new empty object, out of thin air.</p> </li> <li> <p>link the <code>[[Prototype]]</code> of that new empty object to the function's <code>.prototype</code> object.</p> </li> </ol> <p>If those look familiar, it's because those are exactly the same first two steps of the <code>new</code> keyword (see Chapter 4).</p> <p>Let's put this back together now:</p> <pre><code>var Point2d = {\ninit(x,y) {\nthis.x = x;\nthis.y = y;\n},\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n};\nvar point = Object.create(Point2d);\npoint.init(3,4);\npoint.toString();           // (3,4)\n</code></pre> <p>Hmmm. Take a few moments to ponder what's been derived here. How does it compare to the <code>class</code> approach?</p> <p>This pattern ditches the <code>class</code> and <code>new</code> keywords, but accomplishes the exact same outcome. The cost? The single <code>new</code> operation was broken up into two statements: <code>Object.create(Point2d)</code> and <code>point.init(3,4)</code>.</p>"},{"location":"objects-classes/ch5/#help-me-reconstruct","title":"Help Me Reconstruct!","text":"<p>If having those two operations separate bothers you -- is it too deconstructed!? -- they can always be recombined in a little factory helper:</p> <pre><code>function make(objType,...args) {\nvar instance = Object.create(objType);\ninstance.init(...args);\nreturn instance;\n}\nvar point = make(Point2d,3,4);\npoint.toString();           // (3,4)\n</code></pre> TIP: Such a <code>make(..)</code> factory function helper works generally for any object-type, as long as you follow the implied convention that each <code>objType</code> you link to has a function named <code>init(..)</code> on it. <p>And of course, you can still create as many instances as you'd like:</p> <pre><code>var point = make(Point2d,3,4);\nvar anotherPoint = make(Point2d,5,6);\n</code></pre>"},{"location":"objects-classes/ch5/#ditching-class-thinking","title":"Ditching Class Thinking","text":"<p>Quite frankly, the deconstruction we just went through only ends up in slightly different, and maybe slightly better or slightly worse, code as compared to the <code>class</code> style. If that's all delegation was about, it probably wouldn't even be useful enough for more than a footnote, much less a whole chapter.</p> <p>But here's where we're going to really start pushing the class-oriented thinking itself, not just the syntax, aside.</p> <p>Class-oriented design inherently creates a hierarchy of classification, meaning how we divide up and group characteristics, and then stack them vertically in an inheritance chain. Moreover, defining a subclass is a specialization of the generalized base class. Instantiating is a specialization of the generalized class.</p> <p>Behavior in a traditional class hierarchy is a veritcal composition through the layers of the inheritance chain. Attempts have been made over the decades, and even become rather popular at times, to flatten out deep hierarchies of inheritance, and favor a more horizontal composition through mixins and related ideas.</p> <p>I'm not asserting there's anything wrong with those ways of approaching code. But I am saying that they aren't naturally how JS works, so adopting them in JS has been a long, winding, complicated road, and has variously accreted lots of nuanced syntax to retrofit on top of JS's core <code>[[Prototype]]</code> and <code>this</code> pillar.</p> <p>For the rest of this chapter, I intend to discard both the syntax of <code>class</code> and the thinking of class.</p>"},{"location":"objects-classes/ch5/#delegation-illustrated","title":"Delegation Illustrated","text":"<p>So what is delegation about? At its core, it's about two or more things sharing the effort of completing a task.</p> <p>Instead of defining a <code>Point2d</code> general parent thing that represents shared behavior that a set of one or more child <code>point</code> / <code>anotherPoint</code> things inherit from, delegation moves us to building our program with discrete peer things that cooperate with each other.</p> <p>I'll sketch that out in some code:</p> <pre><code>var Coordinates = {\nsetX(x) {\nthis.x = x;\n},\nsetY(y) {\nthis.y = y;\n},\nsetXY(x,y) {\nthis.setX(x);\nthis.setY(y);\n},\n};\nvar Inspect = {\ntoString() {\nreturn `(${this.x},${this.y})`;\n},\n};\nvar point = {};\nCoordinates.setXY.call(point,3,4);\nInspect.toString.call(point);         // (3,4)\nvar anotherPoint = Object.create(Coordinates);\nanotherPoint.setXY(5,6);\nInspect.toString.call(anotherPoint);  // (5,6)\n</code></pre> <p>Let's break down what's happening here.</p> <p>I've defined <code>Coordinates</code> as a concrete object that holds some behaviors I associate with setting point coordinates (<code>x</code> and <code>y</code>). I've also defined <code>Inspect</code> as a concrete object that holds some debug inspection logic, such as <code>toString()</code>.</p> <p>I then create two more concrete objects, <code>point</code> and <code>anotherPoint</code>.</p> <p><code>point</code> has no specific <code>[[Prototype]]</code> (default: <code>Object.prototype</code>). Using explicit context assignment (see Chapter 4), I invoke the <code>Coordinates.setXY(..)</code> and <code>Inspect.toString()</code> utilities in the context of <code>point</code>. That is what I call explicit delegation.</p> <p><code>anotherPoint</code> is <code>[[Prototype]]</code> linked to <code>Coordinates</code>, mostly for a bit of convenience. That lets me use implicit context assignment with <code>anotherPoint.setXY(..)</code>. But I can still explicitly share <code>anotherPoint</code> as context for the <code>Inspect.toString()</code> call. That's what I call implicit delegation.</p> <p>Don't miss this: We still accomplished composition: we composed the behaviors from <code>Coordinates</code> and <code>Inspect</code>, during runtime function invocations with <code>this</code> context sharing. We didn't have to author-combine those behaviors into a single <code>class</code> (or base-subclass <code>class</code> hierarchy) for <code>point</code> / <code>anotherPoint</code> to inherit from. I like to call this runtime composition, virtual composition.</p> <p>The point here is: none of these four objects is a parent or child. They're all peers of each other, and they all have different purposes. We can organize our behavior in logical chunks (on each respective object), and share the context via <code>this</code> (and, optionally <code>[[Prototype]]</code> linkage), which ends up with the same composition outcomes as the other patterns we've examined thus far in the book.</p> <p>That is the heart of the delegation pattern, as JS embodies it.</p> TIP: In the first edition of this book series, this book (\"this &amp; Object Prototypes\") coined a term, \"OLOO\", which stands for \"Objects Linked to Other Objects\" -- to stand in contrast to \"OO\" (\"Object Oriented\"). In this preceding example, you can see the essence of OLOO: all we have are objects, linked to and cooperating with, other objects. I find this beautiful in its simplicity."},{"location":"objects-classes/ch5/#composing-peer-objects","title":"Composing Peer Objects","text":"<p>Let's take this delegation even further.</p> <p>In the preceding snippet, <code>point</code> and <code>anotherPoint</code> merely held data, and the behaviors they delegated to were on other objects (<code>Coordinates</code> and <code>Inspect</code>). But we can add behaviors directly to any of the objects in a delegation chain, and those behaviors can even interact with each other, all through the magic of virtual composition (<code>this</code> context sharing).</p> <p>To illustrate, we'll evolve our current point example a fair bit. And as a bonus we'll actually draw our points on a <code>&lt;canvas&gt;</code> element in the DOM. Let's take a look:</p> <pre><code>var Canvas = {\nsetOrigin(x,y) {\nthis.ctx.translate(x,y);\n// flip the canvas context vertically,\n// so coordinates work like on a normal\n// 2d (x,y) graph\nthis.ctx.scale(1,-1);\n},\npixel(x,y) {\nthis.ctx.fillRect(x,y,1,1);\n},\nrenderScene() {\n// clear the canvas\nvar matrix = this.ctx.getTransform();\nthis.ctx.resetTransform();\nthis.ctx.clearRect(\n0, 0,\nthis.ctx.canvas.width,\nthis.ctx.canvas.height\n);\nthis.ctx.setTransform(matrix);\nthis.draw();  // &lt;-- where is draw()?\n},\n};\nvar Coordinates = {\nsetX(x) {\nthis.x = Math.round(x);\n},\nsetY(y) {\nthis.y = Math.round(y);\n},\nsetXY(x,y) {\nthis.setX(x);\nthis.setY(y);\nthis.render();   // &lt;-- where is render()?\n},\n};\nvar ControlPoint = {\n// delegate to Coordinates\n__proto__: Coordinates,\n// NOTE: must have a &lt;canvas id=\"my-canvas\"&gt;\n// element in the DOM\nctx: document.getElementById(\"my-canvas\")\n.getContext(\"2d\"),\nrotate(angleRadians) {\nvar rotatedX = this.x * Math.cos(angleRadians) -\nthis.y * Math.sin(angleRadians);\nvar rotatedY = this.x * Math.sin(angleRadians) +\nthis.y * Math.cos(angleRadians);\nthis.setXY(rotatedX,rotatedY);\n},\ndraw() {\n// plot the point\nCanvas.pixel.call(this,this.x,this.y);\n},\nrender() {\n// clear the canvas, and re-render\n// our control-point\nCanvas.renderScene.call(this);\n},\n};\n// set the logical (0,0) origin at this\n// physical location on the canvas\nCanvas.setOrigin.call(ControlPoint,100,100);\nControlPoint.setXY(30,40);\n// [renders point (30,40) on the canvas]\n// ..\n// later:\n// rotate the point about the (0,0) origin\n// 90 degrees counter-clockwise\nControlPoint.rotate(Math.PI / 2);\n// [renders point (-40,30) on the canvas]\n</code></pre> <p>OK, that's a lot of code to digest. Take your time and re-read the snippet several times. I added a couple of new concrete objects (<code>Canvas</code> and <code>ControlPoint</code>) alongside the previous <code>Coordinates</code> object.</p> <p>Make sure you see and understand the interactions between these three concrete objects.</p> <p><code>ControlPoint</code> is linked (via <code>__proto__</code>) to implicitly delegate (<code>[[Prototype]]</code> chain) to <code>Coordinates</code>.</p> <p>Here's an explicit delegation: <code>Canvas.setOrigin.call(ControlPoint,100,100);</code>; I'm invoking the <code>Canvas.setOrigin(..)</code> call in the context of <code>ControlPoint</code>. That has the effect of sharing <code>ctx</code> with <code>setOrigin(..)</code>, via <code>this</code>.</p> <p><code>ControlPoint.setXY(..)</code> delegates implicitly to <code>Coordinates.setXY(..)</code>, but still in the context of <code>ControlPoint</code>. Here's a key detail that's easy to miss: see the <code>this.render()</code> inside of <code>Coordinates.setXY(..)</code>? Where does that come from? Since the <code>this</code> context is <code>ControlPoint</code> (not <code>Coordinates</code>), it's invoking <code>ControlPoint.render()</code>.</p> <p><code>ControlPoint.render()</code> explicitly delegates to <code>Canvas.renderScene()</code>, again still in the <code>ControlPoint</code> context. <code>renderScene()</code> calls <code>this.draw()</code>, but where does that come from? Yep, still from <code>ControlPoint</code> (via <code>this</code> context).</p> <p>And <code>ControlPoint.draw()</code>? It explicitly delegates to <code>Canvas.pixel(..)</code>, yet again still in the <code>ControlPoint</code> context.</p> <p>All three objects have methods that end up invoking each other. But these calls aren't particularly hard-wired. <code>Canvas.renderScene()</code> doesn't call <code>ControlPoint.draw()</code>, it calls <code>this.draw()</code>. That's important, because it means that <code>Canvas.renderScene()</code> is more flexible to use in a different <code>this</code> context -- e.g., against another kind of point object besides <code>ControlPoint</code>.</p> <p>It's through the <code>this</code> context, and the <code>[[Prototype]]</code> chain, that these three objects basically are mixed (composed) virtually together, as needed at each step, so that they work together as if they're one object rather than three sepearate objects.</p> <p>That's the beauty of virtual composition as realized by the delegation pattern in JS.</p>"},{"location":"objects-classes/ch5/#flexible-context","title":"Flexible Context","text":"<p>I mentioned above that we can pretty easily add other concrete objects into the mix. Here's an example:</p> <pre><code>var Coordinates = { /* .. */ };\nvar Canvas = {\n/* .. */\nline(start,end) {\nthis.ctx.beginPath();\nthis.ctx.moveTo(start.x,start.y);\nthis.ctx.lineTo(end.x,end.y);\nthis.ctx.stroke();\n},\n};\nfunction lineAnchor(x,y) {\nvar anchor = {\n__proto__: Coordinates,\nrender() {},\n};\nanchor.setXY(x,y);\nreturn anchor;\n}\nvar GuideLine = {\n// NOTE: must have a &lt;canvas id=\"my-canvas\"&gt;\n// element in the DOM\nctx: document.getElementById(\"my-canvas\")\n.getContext(\"2d\"),\nsetAnchors(sx,sy,ex,ey) {\nthis.start = lineAnchor(sx,sy);\nthis.end = lineAnchor(ex,ey);\nthis.render();\n},\ndraw() {\n// plot the point\nCanvas.line.call(this,this.start,this.end);\n},\nrender() {\n// clear the canvas, and re-render\n// our line\nCanvas.renderScene.call(this);\n},\n};\n// set the logical (0,0) origin at this\n// physical location on the canvas\nCanvas.setOrigin.call(GuideLine,100,100);\nGuideLine.setAnchors(-30,65,45,-17);\n// [renders line from (-30,65) to (45,-17)\n//   on the canvas]\n</code></pre> <p>That's pretty nice, I think!</p> <p>But I think another less-obvious benefit is that having objects linked dynamically via <code>this</code> context tends to make testing different parts of the program independently, somewhat easier.</p> <p>For example, <code>Object.setPrototypeOf(..)</code> can be used to dynamically change the <code>[[Prototype]]</code> linkage of an object, delegating it to a different object such as a mock object. Or you could dynamically redefine <code>GuideLine.draw()</code> and <code>GuideLine.render()</code> to explicitly delegate to a <code>MockCanvas</code> instead of <code>Canvas</code>.</p> <p>The <code>this</code> keyword, and the <code>[[Prototype]]</code> link, are a tremendously flexible mechanism when you understand and leverage them fully.</p>"},{"location":"objects-classes/ch5/#why-this","title":"Why This?","text":"<p>OK, so it's hopefully clear that the delegation pattern leans heavily on implicit input, sharing context via <code>this</code> rather than through an explicit parameter.</p> <p>You might rightly ask, why not just always pass around that context explicitly? We can certainly do so, but... to manually pass along the necessary context, we'll have to change pretty much every single function signature, and any corresponding call-sites.</p> <p>Let's revisit the earlier <code>ControlPoint</code> delegation example, and implement it without any delegation-oriented <code>this</code> context sharing. Pay careful attention to the differences:</p> <pre><code>var Canvas = {\nsetOrigin(ctx,x,y) {\nctx.translate(x,y);\nctx.scale(1,-1);\n},\npixel(ctx,x,y) {\nctx.fillRect(x,y,1,1);\n},\nrenderScene(ctx,entity) {\n// clear the canvas\nvar matrix = ctx.getTransform();\nctx.resetTransform();\nctx.clearRect(\n0, 0,\nctx.canvas.width,\nctx.canvas.height\n);\nctx.setTransform(matrix);\nentity.draw();\n},\n};\nvar Coordinates = {\nsetX(entity,x) {\nentity.x = Math.round(x);\n},\nsetY(entity,y) {\nentity.y = Math.round(y);\n},\nsetXY(entity,x,y) {\nthis.setX(entity,x);\nthis.setY(entity,y);\nentity.render();\n},\n};\nvar ControlPoint = {\n// NOTE: must have a &lt;canvas id=\"my-canvas\"&gt;\n// element in the DOM\nctx: document.getElementById(\"my-canvas\")\n.getContext(\"2d\"),\nsetXY(x,y) {\nCoordinates.setXY(this,x,y);\n},\nrotate(angleRadians) {\nvar rotatedX = this.x * Math.cos(angleRadians) -\nthis.y * Math.sin(angleRadians);\nvar rotatedY = this.x * Math.sin(angleRadians) +\nthis.y * Math.cos(angleRadians);\nthis.setXY(rotatedX,rotatedY);\n},\ndraw() {\n// plot the point\nCanvas.pixel(this.ctx,this.x,this.y);\n},\nrender() {\n// clear the canvas, and re-render\n// our control-point\nCanvas.renderScene(this.ctx,this);\n},\n};\n// set the logical (0,0) origin at this\n// physical location on the canvas\nCanvas.setOrigin(ControlPoint.ctx,100,100);\n// ..\n</code></pre> <p>To be honest, some of you may prefer that style of code. And that's OK if you're in that camp. This snippet avoids <code>[[Prototype]]</code> entirely, and only relies on far fewer basic <code>this.</code>-style references to properties and methods.</p> <p>By contrast, the delegation style I'm advocating for in this chapter is unfamiliar and uses <code>[[Prototype]]</code> and <code>this</code> sharing in ways you're not likely familiar with. To use such a style effectively, you'll have to invest the time and practice to build a deeper familiarity.</p> <p>But in my opinion, the \"cost\" of avoiding virtual composition through delegation can be felt across all the function signatures and call-sites; I find them way more cluttered. That explicit context passing is quite a tax.</p> <p>In fact, I'd never advocate that style of code at all. If you want to avoid delegation, it's probably best to just stick to <code>class</code> style code, as seen in Chapter 3. As an exercise left to the reader, try to convert the earlier <code>ControlPoint</code> / <code>GuideLine</code> code snippets to use <code>class</code>.</p> <ol> <li> <p>\"Treaty of Orlando\"; Henry Lieberman, Lynn Andrea Stein, David Ungar; Oct 6, 1987; https://web.media.mit.edu/~lieber/Publications/Treaty-of-Orlando-Treaty-Text.pdf ; PDF; Accessed July 2022\u00a0\u21a9</p> </li> <li> <p>\"Classes vs. Prototypes, Some Philosophical and Historical Observations\"; Antero Taivalsaari; Apr 22, 1996; https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.4713&amp;rep=rep1&amp;type=pdf ; PDF; Accessed July 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"objects-classes/toc/","title":"You Don't Know JS Yet: Objects &amp; Classes - 2nd Edition","text":"NOTE: Work in progress"},{"location":"objects-classes/toc/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: Object Foundations<ul> <li>About This Book</li> <li>Objects As Containers</li> <li>Defining Properties</li> <li>Accessing Properties</li> <li>Assigning Properties</li> <li>Deleting Properties</li> <li>Determining Container Contents</li> <li>Temporary Containers</li> <li>Containers Are Collections Of Properties</li> </ul> </li> <li>Chapter 2: How Objects Work<ul> <li>Property Descriptors</li> <li>Object Sub-Types</li> <li>Object Characteristics</li> <li>Extending the MOP</li> <li><code>[[Prototype]]</code> Chain</li> <li>Objects Behavior</li> </ul> </li> <li>Chapter 3: Classy Objects<ul> <li>When Should I Class-Orient My Code?</li> <li>Keep It <code>class</code>y</li> <li>Class Instance <code>this</code></li> <li>Class Extension</li> <li>Static Class Behavior</li> <li>Private Class Behavior</li> <li>Class Example</li> </ul> </li> <li>Chapter 4: This Works<ul> <li>This Aware</li> <li>This Is It!</li> <li>An Arrow Points Somewhere</li> <li>Variations</li> <li>Stay Aware</li> </ul> </li> <li>Chapter 5: Delegation<ul> <li>Preamble</li> <li>What's A Constructor, Anyway?</li> <li>Ditching Class Thinking</li> <li>Delegation Illustrated</li> <li>Composing Peer Objects</li> <li>Why This?</li> </ul> </li> <li>Thank You!</li> <li>TODO:<ul> <li>object wrappers (String, Boolean, etc)</li> <li>object coercions (valueof, tostring, boxing)</li> <li>well-known symbols extension points on objects</li> <li>proxies</li> <li>old \"prototypal class\" style</li> <li>\"inheritance\" objections</li> <li>protected visibility</li> </ul> </li> </ul>"},{"location":"scope-closures/apA/","title":"Appendix A: Exploring Further","text":"<p>We will now explore a number of nuances and edges around many of the topics covered in the main text of this book. This appendix is optional, supporting material.</p> <p>Some people find diving too deeply into the nuanced corner cases and varying opinions creates nothing but noise and distraction\u2014supposedly, developers are better served by sticking to the commonly-tread paths. My approach has been criticized as being impractical and counterproductive. I understand and appreciate that perspective, even if I don't necessarily share it.</p> <p>I believe it's better to be empowered by knowledge of how things work than to just gloss over details with assumptions and lack of curiosity. Ultimately, you will encounter situations where something bubbles up from a piece you hadn't explored. In other words, you won't get to spend all your time riding on the smooth happy path. Wouldn't you rather be prepared for the inevitable bumps of off-roading?</p> <p>These discussions will also be more heavily influenced by my opinions than the main text was, so keep that in mind as you consume and consider what is presented. This appendix is a bit like a collection of mini-blog posts that elaborate on various book topics. It's long and deep in the weeds, so take your time and don't rush through everything here.</p>"},{"location":"scope-closures/apA/#implied-scopes","title":"Implied Scopes","text":"<p>Scopes are sometimes created in non-obvious places. In practice, these implied scopes don't often impact your program behavior, but it's still useful to know they're happening. Keep an eye out for the following surprising scopes:</p> <ul> <li>Parameter scope</li> <li>Function name scope</li> </ul>"},{"location":"scope-closures/apA/#parameter-scope","title":"Parameter Scope","text":"<p>The conversation metaphor in Chapter 2 implies that function parameters are basically the same as locally declared variables in the function scope. But that's not always true.</p> <p>Consider:</p> <pre><code>// outer/global scope: RED(1)\nfunction getStudentName(studentID) {\n// function scope: BLUE(2)\n// ..\n}\n</code></pre> <p>Here, <code>studentID</code> is a considered a \"simple\" parameter, so it does behave as a member of the BLUE(2) function scope. But if we change it to be a non-simple parameter, that's no longer technically the case. Parameter forms considered non-simple include parameters with default values, rest parameters (using <code>...</code>), and destructured parameters.</p> <p>Consider:</p> <pre><code>// outer/global scope: RED(1)\nfunction getStudentName(/*BLUE(2)*/ studentID = 0) {\n// function scope: GREEN(3)\n// ..\n}\n</code></pre> <p>Here, the parameter list essentially becomes its own scope, and the function's scope is then nested inside that scope.</p> <p>Why? What difference does it make? The non-simple parameter forms introduce various corner cases, so the parameter list becomes its own scope to more effectively deal with them.</p> <p>Consider:</p> <pre><code>function getStudentName(studentID = maxID, maxID) {\n// ..\n}\n</code></pre> <p>Assuming left-to-right operations, the default <code>= maxID</code> for the <code>studentID</code> parameter requires a <code>maxID</code> to already exist (and to have been initialized). This code produces a TDZ error (Chapter 5). The reason is that <code>maxID</code> is declared in the parameter scope, but it's not yet been initialized because of the order of parameters. If the parameter order is flipped, no TDZ error occurs:</p> <pre><code>function getStudentName(maxID,studentID = maxID) {\n// ..\n}\n</code></pre> <p>The complication gets even more in the weeds if we introduce a function expression into the default parameter position, which then can create its own closure (Chapter 7) over parameters in this implied parameter scope:</p> <pre><code>function whatsTheDealHere(id,defaultID = () =&gt; id) {\nid = 5;\nconsole.log( defaultID() );\n}\nwhatsTheDealHere(3);\n// 5\n</code></pre> <p>That snippet probably makes sense, because the <code>defaultID()</code> arrow function closes over the <code>id</code> parameter/variable, which we then re-assign to <code>5</code>. But now let's introduce a shadowing definition of <code>id</code> in the function scope:</p> <pre><code>function whatsTheDealHere(id,defaultID = () =&gt; id) {\nvar id = 5;\nconsole.log( defaultID() );\n}\nwhatsTheDealHere(3);\n// 3\n</code></pre> <p>Uh oh! The <code>var id = 5</code> is shadowing the <code>id</code> parameter, but the closure of the <code>defaultID()</code> function is over the parameter, not the shadowing variable in the function body. This proves there's a scope bubble around the parameter list.</p> <p>But it gets even crazier than that!</p> <pre><code>function whatsTheDealHere(id,defaultID = () =&gt; id) {\nvar id;\nconsole.log(`local variable 'id': ${ id }`);\nconsole.log(\n`parameter 'id' (closure): ${ defaultID() }`\n);\nconsole.log(\"reassigning 'id' to 5\");\nid = 5;\nconsole.log(`local variable 'id': ${ id }`);\nconsole.log(\n`parameter 'id' (closure): ${ defaultID() }`\n);\n}\nwhatsTheDealHere(3);\n// local variable 'id': 3   &lt;--- Huh!? Weird!\n// parameter 'id' (closure): 3\n// reassigning 'id' to 5\n// local variable 'id': 5\n// parameter 'id' (closure): 3\n</code></pre> <p>The strange bit here is the first console message. At that moment, the shadowing <code>id</code> local variable has just been <code>var id</code> declared, which Chapter 5 asserts is typically auto-initialized to <code>undefined</code> at the top of its scope. Why doesn't it print <code>undefined</code>?</p> <p>In this specific corner case (for legacy compat reasons), JS doesn't auto-initialize <code>id</code> to <code>undefined</code>, but rather to the value of the <code>id</code> parameter (<code>3</code>)!</p> <p>Though the two <code>id</code>s look at that moment like they're one variable, they're actually still separate (and in separate scopes). The <code>id = 5</code> assignment makes the divergence observable, where the <code>id</code> parameter stays <code>3</code> and the local variable becomes <code>5</code>.</p> <p>My advice to avoid getting bitten by these weird nuances:</p> <ul> <li> <p>Never shadow parameters with local variables</p> </li> <li> <p>Avoid using a default parameter function that closes over any of the parameters</p> </li> </ul> <p>At least now you're aware and can be careful about the fact that the parameter list is its own scope if any of the parameters are non-simple.</p>"},{"location":"scope-closures/apA/#function-name-scope","title":"Function Name Scope","text":"<p>In the \"Function Name Scope\" section in Chapter 3, I asserted that the name of a function expression is added to the function's own scope. Recall:</p> <pre><code>var askQuestion = function ofTheTeacher(){\n// ..\n};\n</code></pre> <p>It's true that <code>ofTheTeacher</code> is not added to the enclosing scope (where <code>askQuestion</code> is declared), but it's also not just added to the scope of the function, the way you're likely assuming. It's another strange corner case of implied scope.</p> <p>The name identifier of a function expression is in its own implied scope, nested between the outer enclosing scope and the main inner function scope.</p> <p>If <code>ofTheTeacher</code> was in the function's scope, we'd expect an error here:</p> <pre><code>var askQuestion = function ofTheTeacher(){\n// why is this not a duplicate declaration error?\nlet ofTheTeacher = \"Confused, yet?\";\n};\n</code></pre> <p>The <code>let</code> declaration form does not allow re-declaration (see Chapter 5). But this is perfectly legal shadowing, not re-declaration, because the two <code>ofTheTeacher</code> identifiers are in separate scopes.</p> <p>You'll rarely run into any case where the scope of a function's name identifier matters. But again, it's good to know how these mechanisms actually work. To avoid being bitten, never shadow function name identifiers.</p>"},{"location":"scope-closures/apA/#anonymous-vs-named-functions","title":"Anonymous vs. Named Functions","text":"<p>As discussed in Chapter 3, functions can be expressed either in named or anonymous form. It's vastly more common to use the anonymous form, but is that a good idea?</p> <p>As you contemplate naming your functions, consider:</p> <ul> <li>Name inference is incomplete</li> <li>Lexical names allow self-reference</li> <li>Names are useful descriptions</li> <li>Arrow functions have no LEXICAL names</li> <li>IIFEs also need names</li> </ul>"},{"location":"scope-closures/apA/#explicit-or-inferred-names","title":"Explicit or Inferred Names?","text":"<p>Every function in your program has a purpose. If it doesn't have a purpose, take it out, because you're just wasting space. If it does have a purpose, there is a name for that purpose.</p> <p>So far many readers likely agree with me. But does that mean we should always put that name into the code? Here's where I'll raise more than a few eyebrows. I say, unequivocally, yes!</p> <p>First of all, \"anonymous\" showing up in stack traces is just not all that helpful to debugging:</p> <pre><code>btn.addEventListener(\"click\",function(){\nsetTimeout(function(){\n[\"a\",42].map(function(v){\nconsole.log(v.toUpperCase());\n});\n},100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at myProgram.js:4\n//     at Array.map (&lt;anonymous&gt;)\n//     at myProgram.js:3\n</code></pre> <p>Ugh. Compare to what is reported if I give the functions names:</p> <pre><code>btn.addEventListener(\"click\",function onClick(){\nsetTimeout(function waitAMoment(){\n[\"a\",42].map(function allUpper(v){\nconsole.log(v.toUpperCase());\n});\n},100);\n});\n// Uncaught TypeError: v.toUpperCase is not a function\n//     at allUpper (myProgram.js:4)\n//     at Array.map (&lt;anonymous&gt;)\n//     at waitAMoment (myProgram.js:3)\n</code></pre> <p>See how <code>waitAMoment</code> and <code>allUpper</code> names appear and give the stack trace more useful information/context for debugging? The program is more debuggable if we use reasonable names for all our functions.</p> NOTE: The unfortunate \"&lt;anonymous&gt;\" that still shows up refers to the fact that the implementation of <code>Array.map(..)</code> isn't present in our program, but is built into the JS engine. It's not from any confusion our program introduces with readability shortcuts. <p>By the way, let's make sure we're on the same page about what a named function is:</p> <pre><code>function thisIsNamed() {\n// ..\n}\najax(\"some.url\",function thisIsAlsoNamed(){\n// ..\n});\nvar notNamed = function(){\n// ..\n};\nmakeRequest({\ndata: 42,\ncb /* also not a name */: function(){\n// ..\n}\n});\nvar stillNotNamed = function butThisIs(){\n// ..\n};\n</code></pre> <p>\"But wait!\", you say. Some of those are named, right!?</p> <pre><code>var notNamed = function(){\n// ..\n};\nvar config = {\ncb: function(){\n// ..\n}\n};\nnotNamed.name;\n// notNamed\nconfig.cb.name;\n// cb\n</code></pre> <p>These are referred to as inferred names. Inferred names are fine, but they don't really address the full concern I'm discussing.</p>"},{"location":"scope-closures/apA/#missing-names","title":"Missing Names?","text":"<p>Yes, these inferred names might show up in stack traces, which is definitely better than \"anonymous\" showing up. But...</p> <pre><code>function ajax(url,cb) {\nconsole.log(cb.name);\n}\najax(\"some.url\",function(){\n// ..\n});\n// \"\"\n</code></pre> <p>Oops. Anonymous <code>function</code> expressions passed as callbacks are incapable of receiving an inferred name, so <code>cb.name</code> holds just the empty string <code>\"\"</code>. The vast majority of all <code>function</code> expressions, especially anonymous ones, are used as callback arguments; none of these get a name. So relying on name inference is incomplete, at best.</p> <p>And it's not just callbacks that fall short with inference:</p> <pre><code>var config = {};\nconfig.cb = function(){\n// ..\n};\nconfig.cb.name;\n// \"\"\nvar [ noName ] = [ function(){} ];\nnoName.name\n// \"\"\n</code></pre> <p>Any assignment of a <code>function</code> expression that's not a simple assignment will also fail name inferencing. So, in other words, unless you're careful and intentional about it, essentially almost all anonymous <code>function</code> expressions in your program will in fact have no name at all.</p> <p>Name inference is just... not enough.</p> <p>And even if a <code>function</code> expression does get an inferred name, that still doesn't count as being a full named function.</p>"},{"location":"scope-closures/apA/#who-am-i","title":"Who am I?","text":"<p>Without a LEXICAL name identifier, the function has no internal way to refer to itself. Self-reference is important for things like recursion and event handling:</p> <pre><code>// broken\nrunOperation(function(num){\nif (num &lt;= 1) return 1;\nreturn num * oopsNoNameToCall(num - 1);\n});\n// also broken\nbtn.addEventListener(\"click\",function(){\nconsole.log(\"should only respond to one click!\");\nbtn.removeEventListener(\"click\",oopsNoNameHere);\n});\n</code></pre> <p>Leaving off the LEXICAL name from your callback makes it harder to reliably self-reference the function. You could declare a variable in an enclosing scope that references the function, but this variable is controlled by that enclosing scope\u2014it could be re-assigned, etc.\u2014so it's not as reliable as the function having its own internal self-reference.</p>"},{"location":"scope-closures/apA/#names-are-descriptors","title":"Names are Descriptors","text":"<p>Lastly, and I think most importantly of all, leaving off a name from a function makes it harder for the reader to tell what the function's purpose is, at a quick glance. They have to read more of the code, including the code inside the function, and the surrounding code outside the function, to figure it out.</p> <p>Consider:</p> <pre><code>[ 1, 2, 3, 4, 5 ].filter(function(v){\nreturn v % 2 == 1;\n});\n// [ 1, 3, 5 ]\n[ 1, 2, 3, 4, 5 ].filter(function keepOnlyOdds(v){\nreturn v % 2 == 1;\n});\n// [ 1, 3, 5 ]\n</code></pre> <p>There's just no reasonable argument to be made that omitting the name <code>keepOnlyOdds</code> from the first callback more effectively communicates to the reader the purpose of this callback. You saved 13 characters, but lost important readability information. The name <code>keepOnlyOdds</code> very clearly tells the reader, at a quick first glance, what's happening.</p> <p>The JS engine doesn't care about the name. But human readers of your code absolutely do.</p> <p>Can the reader look at <code>v % 2 == 1</code> and figure out what it's doing? Sure. But they have to infer the purpose (and name) by mentally executing the code. Even a brief pause to do so slows down reading of the code. A good descriptive name makes this process almost effortless and instant.</p> <p>Think of it this way: how many times does the author of this code need to figure out the purpose of a function before adding the name to the code? About once. Maybe two or three times if they need to adjust the name. But how many times will readers of this code have to figure out the name/purpose? Every single time this line is ever read. Hundreds of times? Thousands? More?</p> <p>No matter the length or complexity of the function, my assertion is, the author should figure out a good descriptive name and add it to the code. Even the one-liner functions in <code>map(..)</code> and <code>then(..)</code> statements should be named:</p> <pre><code>lookupTheRecords(someData)\n.then(function extractSalesRecords(resp){\nreturn resp.allSales;\n})\n.then(storeRecords);\n</code></pre> <p>The name <code>extractSalesRecords</code> tells the reader the purpose of this <code>then(..)</code> handler better than just inferring that purpose from mentally executing <code>return resp.allSales</code>.</p> <p>The only excuse for not including a name on a function is either laziness (don't want to type a few extra characters) or uncreativity (can't come up with a good name). If you can't figure out a good name, you likely don't understand the function and its purpose yet. The function is perhaps poorly designed, or it does too many things, and should be re-worked. Once you have a well-designed, single-purpose function, its proper name should become evident.</p> <p>Here's a trick I use: while first writing a function, if I don't fully understand its purpose and can't think of a good name to use, I just use <code>TODO</code> as the name. That way, later when reviewing my code, I'm likely to find those name placeholders, and I'm more inclined (and more prepared!) to go back and figure out a better name, rather than just leave it as <code>TODO</code>.</p> <p>All functions need names. Every single one. No exceptions. Any name you omit is making the program harder to read, harder to debug, harder to extend and maintain later.</p>"},{"location":"scope-closures/apA/#arrow-functions","title":"Arrow Functions","text":"<p>Arrow functions are always anonymous, even if (rarely) they're used in a way that gives them an inferred name. I just spent several pages explaining why anonymous functions are a bad idea, so you can probably guess what I think about arrow functions.</p> <p>Don't use them as a general replacement for regular functions. They're more concise, yes, but that brevity comes at the cost of omitting key visual delimiters that help our brains quickly parse out what we're reading. And, to the point of this discussion, they're anonymous, which makes them worse for readability from that angle as well.</p> <p>Arrow functions have a purpose, but that purpose is not to save keystrokes. Arrow functions have LEXICAL this behavior, which is somewhat beyond the bounds of our discussion in this book.</p> <p>Briefly: arrow functions don't define a <code>this</code> identifier keyword at all. If you use a <code>this</code> inside an arrow function, it behaves exactly as any other variable reference, which is that the scope chain is consulted to find a function scope (non-arrow function) where it is defined, and to use that one.</p> <p>In other words, arrow functions treat <code>this</code> like any other LEXICAL variable.</p> <p>If you're used to hacks like <code>var self = this</code>, or if you prefer to call <code>.bind(this)</code> on inner <code>function</code> expressions, just to force them to inherit a <code>this</code> from an outer function like it was a LEXICAL variable, then <code>=&gt;</code> arrow functions are absolutely the better option. They're designed specifically to fix that problem.</p> <p>So, in the rare cases you need LEXICAL this, use an arrow function. It's the best tool for that job. But just be aware that in doing so, you're accepting the downsides of an anonymous function. You should expend additional effort to mitigate the readability cost, such as more descriptive variable names and code comments.</p>"},{"location":"scope-closures/apA/#iife-variations","title":"IIFE Variations","text":"<p>All functions should have names. I said that a few times, right!? That includes IIFEs.</p> <pre><code>(function(){\n// don't do this!\n})();\n(function doThisInstead(){\n// ..\n})();\n</code></pre> <p>How do we come up with a name for an IIFE? Identify what the IIFE is there for. Why do you need a scope in that spot? Are you hiding a cache variable for student records?</p> <pre><code>var getStudents = (function StoreStudentRecords(){\nvar studentRecords = [];\nreturn function getStudents() {\n// ..\n}\n})();\n</code></pre> <p>I named the IIFE <code>StoreStudentRecords</code> because that's what it's doing: storing student records. Every IIFE should have a name. No exceptions.</p> <p>IIFEs are typically defined by placing <code>( .. )</code> around the <code>function</code> expression, as shown in those previous snippets. But that's not the only way to define an IIFE. Technically, the only reason we're using that first surrounding set of <code>( .. )</code> is just so the <code>function</code> keyword isn't in a position to qualify as a <code>function</code> declaration to the JS parser. But there are other syntactic ways to avoid being parsed as a declaration:</p> <pre><code>!function thisIsAnIIFE(){\n// ..\n}();\n+function soIsThisOne(){\n// ..\n}();\n~function andThisOneToo(){\n// ..\n}();\n</code></pre> <p>The <code>!</code>, <code>+</code>, <code>~</code>, and several other unary operators (operators with one operand) can all be placed in front of <code>function</code> to turn it into an expression. Then the final <code>()</code> call is valid, which makes it an IIFE.</p> <p>I actually kind of like using the <code>void</code> unary operator when defining a standalone IIFE:</p> <pre><code>void function yepItsAnIIFE() {\n// ..\n}();\n</code></pre> <p>The benefit of <code>void</code> is, it clearly communicates at the beginning of the function that this IIFE won't be returning any value.</p> <p>However you define your IIFEs, show them some love by giving them names.</p>"},{"location":"scope-closures/apA/#hoisting-functions-and-variables","title":"Hoisting: Functions and Variables","text":"<p>Chapter 5 articulated both function hoisting and variable hoisting. Since hoisting is often cited as mistake in the design of JS, I wanted to briefly explore why both these forms of hoisting can be beneficial and should still be considered.</p> <p>Give hoisting a deeper level of consideration by considering the merits of:</p> <ul> <li>Executable code first, function declarations last</li> <li>Semantic placement of variable declarations</li> </ul>"},{"location":"scope-closures/apA/#function-hoisting","title":"Function Hoisting","text":"<p>To review, this program works because of function hoisting:</p> <pre><code>getStudents();\n// ..\nfunction getStudents() {\n// ..\n}\n</code></pre> <p>The <code>function</code> declaration is hoisted during compilation, which means that <code>getStudents</code> is an identifier declared for the entire scope. Additionally, the <code>getStudents</code> identifier is auto-initialized with the function reference, again at the beginning of the scope.</p> <p>Why is this useful? The reason I prefer to take advantage of function hoisting is that it puts the executable code in any scope at the top, and any further declarations (functions) below. This means it's easier to find the code that will run in any given area, rather than having to scroll and scroll, hoping to find a trailing <code>}</code> marking the end of a scope/function somewhere.</p> <p>I take advantage of this inverse positioning in all levels of scope:</p> <pre><code>getStudents();\n// *************\nfunction getStudents() {\nvar whatever = doSomething();\n// other stuff\nreturn whatever;\n// *************\nfunction doSomething() {\n// ..\n}\n}\n</code></pre> <p>When I first open a file like that, the very first line is executable code that kicks off its behavior. That's very easy to spot! Then, if I ever need to go find and inspect <code>getStudents()</code>, I like that its first line is also executable code. Only if I need to see the details of <code>doSomething()</code> do I go and find its definition down below.</p> <p>In other words, I think function hoisting makes code more readable through a flowing, progressive reading order, from top to bottom.</p>"},{"location":"scope-closures/apA/#variable-hoisting","title":"Variable Hoisting","text":"<p>What about variable hoisting?</p> <p>Even though <code>let</code> and <code>const</code> hoist, you cannot use those variables in their TDZ (see Chapter 5). So, the following discussion only applies to <code>var</code> declarations. Before I continue, I'll admit: in almost all cases, I completely agree that variable hoisting is a bad idea:</p> <pre><code>pleaseDontDoThis = \"bad idea\";\n// much later\nvar pleaseDontDoThis;\n</code></pre> <p>While that kind of inverted ordering was helpful for function hoisting, here I think it usually makes code harder to reason about.</p> <p>But there's one exception that I've found, somewhat rarely, in my own coding. It has to do with where I place my <code>var</code> declarations inside a CommonJS module definition.</p> <p>Here's how I typically structure my module definitions in Node:</p> <pre><code>// dependencies\nvar aModuleINeed = require(\"very-helpful\");\nvar anotherModule = require(\"kinda-helpful\");\n// public API\nvar publicAPI = Object.assign(module.exports,{\ngetStudents,\naddStudents,\n// ..\n});\n// ********************************\n// private implementation\nvar cache = { };\nvar otherData = [ ];\nfunction getStudents() {\n// ..\n}\nfunction addStudents() {\n// ..\n}\n</code></pre> <p>Notice how the <code>cache</code> and <code>otherData</code> variables are in the \"private\" section of the module layout? That's because I don't plan to expose them publicly. So I organize the module so they're located alongside the other hidden implementation details of the module.</p> <p>But I've had a few rare cases where I needed the assignments of those values to happen above, before I declare the exported public API of the module. For instance:</p> <pre><code>// public API\nvar publicAPI = Object.assign(module.exports,{\ngetStudents,\naddStudents,\nrefreshData: refreshData.bind(null,cache)\n});\n</code></pre> <p>I need the <code>cache</code> variable to have already been assigned a value, because that value is used in the initialization of the public API (the <code>.bind(..)</code> partial-application).</p> <p>Should I just move the <code>var cache = { .. }</code> up to the top, above this public API initialization? Well, perhaps. But now it's less obvious that <code>var cache</code> is a private implementation detail. Here's the compromise I've (somewhat rarely) used:</p> <pre><code>cache = {};   // used here, but declared below\n// public API\nvar publicAPI = Object.assign(module.exports,{\ngetStudents,\naddStudents,\nrefreshData: refreshData.bind(null,cache)\n});\n// ********************************\n// private implementation\nvar cache /* = {}*/;\n</code></pre> <p>See the variable hoisting? I've declared the <code>cache</code> down where it belongs, logically, but in this rare case I've used it earlier up above, in the area where its initialization is needed. I even left a hint at the value that's assigned to <code>cache</code> in a code comment.</p> <p>That's literally the only case I've ever found for leveraging variable hoisting to assign a variable earlier in a scope than its declaration. But I think it's a reasonable exception to employ with caution.</p>"},{"location":"scope-closures/apA/#the-case-for-var","title":"The Case for <code>var</code>","text":"<p>Speaking of variable hoisting, let's have some real talk for a bit about <code>var</code>, a favorite villain devs love to blame for many of the woes of JS development. In Chapter 5, we explored <code>let</code>/<code>const</code> and promised we'd revisit where <code>var</code> falls in the whole mix.</p> <p>As I lay out the case, don't miss:</p> <ul> <li><code>var</code> was never broken</li> <li><code>let</code> is your friend</li> <li><code>const</code> has limited utility</li> <li>The best of both worlds: <code>var</code> and <code>let</code></li> </ul>"},{"location":"scope-closures/apA/#dont-throw-out-var","title":"Don't Throw Out <code>var</code>","text":"<p><code>var</code> is fine, and works just fine. It's been around for 25 years, and it'll be around and useful and functional for another 25 years or more. Claims that <code>var</code> is broken, deprecated, outdated, dangerous, or ill-designed are bogus bandwagoning.</p> <p>Does that mean <code>var</code> is the right declarator for every single declaration in your program? Certainly not. But it still has its place in your programs. Refusing to use it because someone on the team chose an aggressive linter opinion that chokes on <code>var</code> is cutting off your nose to spite your face.</p> <p>OK, now that I've got you really riled up, let me try to explain my position.</p> <p>For the record, I'm a fan of <code>let</code>, for block-scoped declarations. I really dislike TDZ and I think that was a mistake. But <code>let</code> itself is great. I use it often. In fact, I probably use it as much or more than I use <code>var</code>.</p>"},{"location":"scope-closures/apA/#const-antly-confused","title":"<code>const</code>-antly Confused","text":"<p><code>const</code> on the other hand, I don't use as often. I'm not going to dig into all the reasons why, but it comes down to <code>const</code> not carrying its own weight. That is, while there's a tiny bit of benefit of <code>const</code> in some cases, that benefit is outweighed by the long history of troubles around <code>const</code> confusion in a variety of languages, long before it ever showed up in JS.</p> <p><code>const</code> pretends to create values that can't be mutated\u2014a misconception that's extremely common in developer communities across many languages\u2014whereas what it really does is prevent re-assignment.</p> <pre><code>const studentIDs = [ 14, 73, 112 ];\n// later\nstudentIDs.push(6);   // whoa, wait... what!?\n</code></pre> <p>Using a <code>const</code> with a mutable value (like an array or object) is asking for a future developer (or reader of your code) to fall into the trap you set, which was that they either didn't know, or sorta forgot, that value immutability isn't at all the same thing as assignment immutability.</p> <p>I just don't think we should set those traps. The only time I ever use <code>const</code> is when I'm assigning an already-immutable value (like <code>42</code> or <code>\"Hello, friends!\"</code>), and when it's clearly a \"constant\" in the sense of being a named placeholder for a literal value, for semantic purposes. That's what <code>const</code> is best used for. That's pretty rare in my code, though.</p> <p>If variable re-assignment were a big deal, then <code>const</code> would be more useful. But variable re-assignment just isn't that big of a deal in terms of causing bugs. There's a long list of things that lead to bugs in programs, but \"accidental re-assignment\" is way, way down that list.</p> <p>Combine that with the fact that <code>const</code> (and <code>let</code>) are supposed to be used in blocks, and blocks are supposed to be short, and you have a really small area of your code where a <code>const</code> declaration is even applicable. A <code>const</code> on line 1 of your ten-line block only tells you something about the next nine lines. And the thing it tells you is already obvious by glancing down at those nine lines: the variable is never on the left-hand side of an <code>=</code>; it's not re-assigned.</p> <p>That's it, that's all <code>const</code> really does. Other than that, it's not very useful. Stacked up against the significant confusion of value vs. assignment immutability, <code>const</code> loses a lot of its luster.</p> <p>A <code>let</code> (or <code>var</code>!) that's never re-assigned is already behaviorally a \"constant\", even though it doesn't have the compiler guarantee. That's good enough in most cases.</p>"},{"location":"scope-closures/apA/#var-and-let","title":"<code>var</code> and <code>let</code>","text":"<p>In my mind, <code>const</code> is pretty rarely useful, so this is only two-horse race between <code>let</code> and <code>var</code>. But it's not really a race either, because there doesn't have to be just one winner. They can both win... different races.</p> <p>The fact is, you should be using both <code>var</code> and <code>let</code> in your programs. They are not interchangeable: you shouldn't use <code>var</code> where a <code>let</code> is called for, but you also shouldn't use <code>let</code> where a <code>var</code> is most appropriate.</p> <p>So where should we still use <code>var</code>? Under what circumstances is it a better choice than <code>let</code>?</p> <p>For one, I always use <code>var</code> in the top-level scope of any function, regardless of whether that's at the beginning, middle, or end of the function. I also use <code>var</code> in the global scope, though I try to minimize usage of the global scope.</p> <p>Why use <code>var</code> for function scoping? Because that's exactly what <code>var</code> does. There literally is no better tool for the job of function scoping a declaration than a declarator that has, for 25 years, done exactly that.</p> <p>You could use <code>let</code> in this top-level scope, but it's not the best tool for that job. I also find that if you use <code>let</code> everywhere, then it's less obvious which declarations are designed to be localized and which ones are intended to be used throughout the function.</p> <p>By contrast, I rarely use a <code>var</code> inside a block. That's what <code>let</code> is for. Use the best tool for the job. If you see a <code>let</code>, it tells you that you're dealing with a localized declaration. If you see <code>var</code>, it tells you that you're dealing with a function-wide declaration. Simple as that.</p> <pre><code>function getStudents(data) {\nvar studentRecords = [];\nfor (let record of data.records) {\nlet id = `student-${ record.id }`;\nstudentRecords.push({\nid,\nrecord.name\n});\n}\nreturn studentRecords;\n}\n</code></pre> <p>The <code>studentRecords</code> variable is intended for use across the whole function. <code>var</code> is the best declarator to tell the reader that. By contrast, <code>record</code> and <code>id</code> are intended for use only in the narrower scope of the loop iteration, so <code>let</code> is the best tool for that job.</p> <p>In addition to this best tool semantic argument, <code>var</code> has a few other characteristics that, in certain limited circumstances, make it more powerful.</p> <p>One example is when a loop is exclusively using a variable, but its conditional clause cannot see block-scoped declarations inside the iteration:</p> <pre><code>function commitAction() {\ndo {\nlet result = commit();\nvar done = result &amp;&amp; result.code == 1;\n} while (!done);\n}\n</code></pre> <p>Here, <code>result</code> is clearly only used inside the block, so we use <code>let</code>. But <code>done</code> is a bit different. It's only useful for the loop, but the <code>while</code> clause cannot see <code>let</code> declarations that appear inside the loop. So we compromise and use <code>var</code>, so that <code>done</code> is hoisted to the outer scope where it can be seen.</p> <p>The alternative\u2014declaring <code>done</code> outside the loop\u2014separates it from where it's first used, and either necessitates picking a default value to assign, or worse, leaving it unassigned and thus looking ambiguous to the reader. I think <code>var</code> inside the loop is preferable here.</p> <p>Another helpful characteristic of <code>var</code> is seen with declarations inside unintended blocks. Unintended blocks are blocks that are created because the syntax requires a block, but where the intent of the developer is not really to create a localized scope. The best illustration of unintended scope is the <code>try..catch</code> statement:</p> <pre><code>function getStudents() {\ntry {\n// not really a block scope\nvar records = fromCache(\"students\");\n}\ncatch (err) {\n// oops, fall back to a default\nvar records = [];\n}\n// ..\n}\n</code></pre> <p>There are other ways to structure this code, yes. But I think this is the best way, given various trade-offs.</p> <p>I don't want to declare <code>records</code> (with <code>var</code> or <code>let</code>) outside of the <code>try</code> block, and then assign to it in one or both blocks. I prefer initial declarations to always be as close as possible (ideally, same line) to the first usage of the variable. In this simple example, that would only be a couple of lines distance, but in real code it can grow to many more lines. The bigger the gap, the harder it is to figure out what variable from what scope you're assigning to. <code>var</code> used at the actual assignment makes it less ambiguous.</p> <p>Also notice I used <code>var</code> in both the <code>try</code> and <code>catch</code> blocks. That's because I want to signal to the reader that no matter which path is taken, <code>records</code> always gets declared. Technically, that works because <code>var</code> is hoisted once to the function scope. But it's still a nice semantic signal to remind the reader what either <code>var</code> ensures. If <code>var</code> were only used in one of the blocks, and you were only reading the other block, you wouldn't as easily discover where <code>records</code> was coming from.</p> <p>This is, in my opinion, a little superpower of <code>var</code>. Not only can it escape the unintentional <code>try..catch</code> blocks, but it's allowed to appear multiple times in a function's scope. You can't do that with <code>let</code>. It's not bad, it's actually a little helpful feature. Think of <code>var</code> more like a declarative annotation that's reminding you, each usage, where the variable comes from. \"Ah ha, right, it belongs to the whole function.\"</p> <p>This repeated-annotation superpower is useful in other cases:</p> <pre><code>function getStudents() {\nvar data = [];\n// do something with data\n// .. 50 more lines of code ..\n// purely an annotation to remind us\nvar data;\n// use data again\n// ..\n}\n</code></pre> <p>The second <code>var data</code> is not re-declaring <code>data</code>, it's just annotating for the readers' benefit that <code>data</code> is a function-wide declaration. That way, the reader doesn't need to scroll up 50+ lines of code to find the initial declaration.</p> <p>I'm perfectly fine with re-using variables for multiple purposes throughout a function scope. I'm also perfectly fine with having two usages of a variable be separated by quite a few lines of code. In both cases, the ability to safely \"re-declare\" (annotate) with <code>var</code> helps make sure I can tell where my <code>data</code> is coming from, no matter where I am in the function.</p> <p>Again, sadly, <code>let</code> cannot do this.</p> <p>There are other nuances and scenarios when <code>var</code> turns out to offer some assistance, but I'm not going to belabor the point any further. The takeaway is that <code>var</code> can be useful in our programs alongside <code>let</code> (and the occasional <code>const</code>). Are you willing to creatively use the tools the JS language provides to tell a richer story to your readers?</p> <p>Don't just throw away a useful tool like <code>var</code> because someone shamed you into thinking it wasn't cool anymore. Don't avoid <code>var</code> because you got confused once years ago. Learn these tools and use them each for what they're best at.</p>"},{"location":"scope-closures/apA/#whats-the-deal-with-tdz","title":"What's the Deal with TDZ?","text":"<p>The TDZ (temporal dead zone) was explained in Chapter 5. We illustrated how it occurs, but we skimmed over any explanation of why it was necessary to introduce in the first place. Let's look briefly at the motivations of TDZ.</p> <p>Some breadcrumbs in the TDZ origin story:</p> <ul> <li><code>const</code>s should never change</li> <li>It's all about time</li> <li>Should <code>let</code> behave more like <code>const</code> or <code>var</code>?</li> </ul>"},{"location":"scope-closures/apA/#where-it-all-started","title":"Where It All Started","text":"<p>TDZ comes from <code>const</code>, actually.</p> <p>During early ES6 development work, TC39 had to decide whether <code>const</code> (and <code>let</code>) were going to hoist to the top of their blocks. They decided these declarations would hoist, similar to how <code>var</code> does. Had that not been the case, I think some of the fear was confusion with mid-scope shadowing, such as:</p> <pre><code>let greeting = \"Hi!\";\n{\n// what should print here?\nconsole.log(greeting);\n// .. a bunch of lines of code ..\n// now shadowing the `greeting` variable\nlet greeting = \"Hello, friends!\";\n// ..\n}\n</code></pre> <p>What should we do with that <code>console.log(..)</code> statement? Would it make any sense to JS devs for it to print \"Hi!\"? Seems like that could be a gotcha, to have shadowing kick in only for the second half of the block, but not the first half. That's not very intuitive, JS-like behavior. So <code>let</code> and <code>const</code> have to hoist to the top of the block, visible throughout.</p> <p>But if <code>let</code> and <code>const</code> hoist to the top of the block (like <code>var</code> hoists to the top of a function), why don't <code>let</code> and <code>const</code> auto-initialize (to <code>undefined</code>) the way <code>var</code> does? Here was the main concern:</p> <pre><code>{\n// what should print here?\nconsole.log(studentName);\n// later\nconst studentName = \"Frank\";\n// ..\n}\n</code></pre> <p>Let's imagine that <code>studentName</code> not only hoisted to the top of this block, but was also auto-initialized to <code>undefined</code>. For the first half of the block, <code>studentName</code> could be observed to have the <code>undefined</code> value, such as with our <code>console.log(..)</code> statement. Once the <code>const studentName = ..</code> statement is reached, now <code>studentName</code> is assigned <code>\"Frank\"</code>. From that point forward, <code>studentName</code> can't ever be re-assigned.</p> <p>But, is it strange or surprising that a constant observably has two different values, first <code>undefined</code>, then <code>\"Frank\"</code>? That does seem to go against what we think a <code>const</code>ant means; it should only ever be observable with one value.</p> <p>So... now we have a problem. We can't auto-initialize <code>studentName</code> to <code>undefined</code> (or any other value for that matter). But the variable has to exist throughout the whole scope. What do we do with the period of time from when it first exists (beginning of scope) and when it's assigned its value?</p> <p>We call this period of time the \"dead zone,\" as in the \"temporal dead zone\" (TDZ). To prevent confusion, it was determined that any sort of access of a variable while in its TDZ is illegal and must result in the TDZ error.</p> <p>OK, that line of reasoning does make some sense, I must admit.</p>"},{"location":"scope-closures/apA/#who-let-the-tdz-out","title":"Who <code>let</code> the TDZ Out?","text":"<p>But that's just <code>const</code>. What about <code>let</code>?</p> <p>Well, TC39 made the decision: since we need a TDZ for <code>const</code>, we might as well have a TDZ for <code>let</code> as well. In fact, if we make let have a TDZ, then we discourage all that ugly variable hoisting people do. So there was a consistency perspective and, perhaps, a bit of social engineering to shift developers' behavior.</p> <p>My counter-argument would be: if you're favoring consistency, be consistent with <code>var</code> instead of <code>const</code>; <code>let</code> is definitely more like <code>var</code> than <code>const</code>. That's especially true since they had already chosen consistency with <code>var</code> for the whole hoisting-to-the-top-of-the-scope thing. Let <code>const</code> be its own unique deal with a TDZ, and let the answer to TDZ purely be: just avoid the TDZ by always declaring your constants at the top of the scope. I think this would have been more reasonable.</p> <p>But alas, that's not how it landed. <code>let</code> has a TDZ because <code>const</code> needs a TDZ, because <code>let</code> and <code>const</code> mimic <code>var</code> in their hoisting to the top of the (block) scope. There ya go. Too circular? Read it again a few times.</p>"},{"location":"scope-closures/apA/#are-synchronous-callbacks-still-closures","title":"Are Synchronous Callbacks Still Closures?","text":"<p>Chapter 7 presented two different models for tackling closure:</p> <ul> <li> <p>Closure is a function instance remembering its outer variables even as that function is passed around and invoked in other scopes.</p> </li> <li> <p>Closure is a function instance and its scope environment being preserved in-place while any references to it are passed around and invoked from other scopes.</p> </li> </ul> <p>These models are not wildly divergent, but they do approach from a different perspective. And that different perspective changes what we identify as a closure.</p> <p>Don't get lost following this rabbit trail through closures and callbacks:</p> <ul> <li>Calling back to what (or where)?</li> <li>Maybe \"synchronous callback\" isn't the best label</li> <li>IIF functions don't move around, why would they need closure?</li> <li>Deferring over time is key to closure</li> </ul>"},{"location":"scope-closures/apA/#what-is-a-callback","title":"What is a Callback?","text":"<p>Before we revisit closure, let me spend a brief moment addressing the word \"callback.\" It's a generally accepted norm that saying \"callback\" is synonymous with both asynchronous callbacks and synchronous callbacks. I don't think I agree that this is a good idea, so I want to explain why and propose we move away from that to another term.</p> <p>Let's first consider an asynchronous callback, a function reference that will be invoked at some future later point. What does \"callback\" mean, in this case?</p> <p>It means that the current code has finished or paused, suspended itself, and that when the function in question is invoked later, execution is entering back into the suspended program, resuming it. Specifically, the point of re-entry is the code that was wrapped in the function reference:</p> <pre><code>setTimeout(function waitForASecond(){\n// this is where JS should call back into\n// the program when the timer has elapsed\n},1000);\n// this is where the current program finishes\n// or suspends\n</code></pre> <p>In this context, \"calling back\" makes a lot of sense. The JS engine is resuming our suspended program by calling back in at a specific location. OK, so a callback is asynchronous.</p>"},{"location":"scope-closures/apA/#synchronous-callback","title":"Synchronous Callback?","text":"<p>But what about synchronous callbacks? Consider:</p> <pre><code>function getLabels(studentIDs) {\nreturn studentIDs.map(\nfunction formatIDLabel(id){\nreturn `Student ID: ${\nString(id).padStart(6)\n}`;\n}\n);\n}\ngetLabels([ 14, 73, 112, 6 ]);\n// [\n//    \"Student ID: 000014\",\n//    \"Student ID: 000073\",\n//    \"Student ID: 000112\",\n//    \"Student ID: 000006\"\n// ]\n</code></pre> <p>Should we refer to <code>formatIDLabel(..)</code> as a callback? Is the <code>map(..)</code> utility really calling back into our program by invoking the function we provided?</p> <p>There's nothing to call back into per se, because the program hasn't paused or exited. We're passing a function (reference) from one part of the program to another part of the program, and then it's immediately invoked.</p> <p>There's other established terms that might match what we're doing\u2014passing in a function (reference) so that another part of the program can invoke it on our behalf. You might think of this as Dependency Injection (DI) or Inversion of Control (IoC).</p> <p>DI can be summarized as passing in necessary part(s) of functionality to another part of the program so that it can invoke them to complete its work. That's a decent description for the <code>map(..)</code> call above, isn't it? The <code>map(..)</code> utility knows to iterate over the list's values, but it doesn't know what to do with those values. That's why we pass it the <code>formatIDLabel(..)</code> function. We pass in the dependency.</p> <p>IoC is a pretty similar, related concept. Inversion of control means that instead of the current area of your program controlling what's happening, you hand control off to another part of the program. We wrapped the logic for computing a label string in the function <code>formatIDLabel(..)</code>, then handed invocation control to the <code>map(..)</code> utility.</p> <p>Notably, Martin Fowler cites IoC as the difference between a framework and a library: with a library, you call its functions; with a framework, it calls your functions. 1</p> <p>In the context of our discussion, either DI or IoC could work as an alternative label for a synchronous callback.</p> <p>But I have a different suggestion. Let's refer to (the functions formerly known as) synchronous callbacks, as inter-invoked functions (IIFs). Yes, exactly, I'm playing off IIFEs. These kinds of functions are inter-invoked, meaning: another entity invokes them, as opposed to IIFEs, which invoke themselves immediately.</p> <p>What's the relationship between an asynchronous callback and an IIF? An asynchronous callback is an IIF that's invoked asynchronously instead of synchronously.</p>"},{"location":"scope-closures/apA/#synchronous-closure","title":"Synchronous Closure?","text":"<p>Now that we've re-labeled synchronous callbacks as IIFs, we can return to our main question: are IIFs an example of closure? Obviously, the IIF would have to reference variable(s) from an outer scope for it to have any chance of being a closure. The <code>formatIDLabel(..)</code> IIF from earlier does not reference any variables outside its own scope, so it's definitely not a closure.</p> <p>What about an IIF that does have external references, is that closure?</p> <pre><code>function printLabels(labels) {\nvar list = document.getElementById(\"labelsList\");\nlabels.forEach(\nfunction renderLabel(label){\nvar li = document.createElement(\"li\");\nli.innerText = label;\nlist.appendChild(li);\n}\n);\n}\n</code></pre> <p>The inner <code>renderLabel(..)</code> IIF references <code>list</code> from the enclosing scope, so it's an IIF that could have closure. But here's where the definition/model we choose for closure matters:</p> <ul> <li> <p>If <code>renderLabel(..)</code> is a function that gets passed somewhere else, and that function is then invoked, then yes, <code>renderLabel(..)</code> is exercising a closure, because closure is what preserved its access to its original scope chain.</p> </li> <li> <p>But if, as in the alternative conceptual model from Chapter 7, <code>renderLabel(..)</code> stays in place, and only a reference to it is passed to <code>forEach(..)</code>, is there any need for closure to preserve the scope chain of <code>renderLabel(..)</code>, while it executes synchronously right inside its own scope?</p> </li> </ul> <p>No. That's just normal LEXICAL scope.</p> <p>To understand why, consider this alternative form of <code>printLabels(..)</code>:</p> <pre><code>function printLabels(labels) {\nvar list = document.getElementById(\"labelsList\");\nfor (let label of labels) {\n// just a normal function call in its own\n// scope, right? That's not really closure!\nrenderLabel(label);\n}\n// **************\nfunction renderLabel(label) {\nvar li = document.createElement(\"li\");\nli.innerText = label;\nlist.appendChild(li);\n}\n}\n</code></pre> <p>These two versions of <code>printLabels(..)</code> are essentially the same.</p> <p>The latter one is definitely not an example of closure, at least not in any useful or observable sense. It's just LEXICAL scope. The former version, with <code>forEach(..)</code> calling our function reference, is essentially the same thing. It's also not closure, but rather just a plain ol' LEXICAL scope function call.</p>"},{"location":"scope-closures/apA/#defer-to-closure","title":"Defer to Closure","text":"<p>By the way, Chapter 7 briefly mentioned partial application and currying (which do rely on closure!). This is an interesting scenario where manual currying can be used:</p> <pre><code>function printLabels(labels) {\nvar list = document.getElementById(\"labelsList\");\nvar renderLabel = renderTo(list);\n// definitely closure this time!\nlabels.forEach( renderLabel );\n// **************\nfunction renderTo(list) {\nreturn function createLabel(label){\nvar li = document.createElement(\"li\");\nli.innerText = label;\nlist.appendChild(li);\n};\n}\n}\n</code></pre> <p>The inner function <code>createLabel(..)</code>, which we assign to <code>renderLabel</code>, is closed over <code>list</code>, so closure is definitely being utilized.</p> <p>Closure allows us to remember <code>list</code> for later, while we defer execution of the actual label-creation logic from the <code>renderTo(..)</code> call to the subsequent <code>forEach(..)</code> invocations of the <code>createLabel(..)</code> IIF. That may only be a brief moment here, but any amount of time could pass, as closure bridges from call to call.</p>"},{"location":"scope-closures/apA/#classic-module-variations","title":"Classic Module Variations","text":"<p>Chapter 8 explained the classic module pattern, which can look like this:</p> <pre><code>var StudentList = (function defineModule(Student){\nvar elems = [];\nvar publicAPI = {\nrenderList() {\n// ..\n}\n};\nreturn publicAPI;\n})(Student);\n</code></pre> <p>Notice that we're passing <code>Student</code> (another module instance) in as a dependency. But there's lots of useful variations on this module form you may encounter. Some hints for recognizing these variations:</p> <ul> <li>Does the module know about its own API?</li> <li>Even if we use a fancy module loader, it's just a classic module</li> <li>Some modules need to work universally</li> </ul>"},{"location":"scope-closures/apA/#wheres-my-api","title":"Where's My API?","text":"<p>First, most classic modules don't define and use a <code>publicAPI</code> the way I have shown in this code. Instead, they typically look like:</p> <pre><code>var StudentList = (function defineModule(Student){\nvar elems = [];\nreturn {\nrenderList() {\n// ..\n}\n};\n})(Student);\n</code></pre> <p>The only difference here is directly returning the object that serves as the public API for the module, as opposed to first saving it to an inner <code>publicAPI</code> variable. This is by far how most classic modules are defined.</p> <p>But I strongly prefer, and always use myself, the former <code>publicAPI</code> form. Two reasons:</p> <ul> <li> <p><code>publicAPI</code> is a semantic descriptor that aids readability by making it more obvious what the purpose of the object is.</p> </li> <li> <p>Storing an inner <code>publicAPI</code> variable that references the same external public API object returned, can be useful if you need to access or modify the API during the lifetime of the module.</p> <p>For example, you may want to call one of the publicly exposed functions, from inside the module. Or, you may want to add or remove methods depending on certain conditions, or update the value of an exposed property.</p> <p>Whatever the case may be, it just seems rather silly to me that we wouldn't maintain a reference to access our own API. Right?</p> </li> </ul>"},{"location":"scope-closures/apA/#asynchronous-module-definition-amd","title":"Asynchronous Module Definition (AMD)","text":"<p>Another variation on the classic module form is AMD-style modules (popular several years back), such as those supported by the RequireJS utility:</p> <pre><code>define([ \"./Student\" ],function StudentList(Student){\nvar elems = [];\nreturn {\nrenderList() {\n// ..\n}\n};\n});\n</code></pre> <p>If you look closely at <code>StudentList(..)</code>, it's a classic module factory function. Inside the machinery of <code>define(..)</code> (provided by RequireJS), the <code>StudentList(..)</code> function is executed, passing to it any other module instances declared as dependencies. The return value is an object representing the public API for the module.</p> <p>This is based on exactly the same principles (including how the closure works!) as we explored with classic modules.</p>"},{"location":"scope-closures/apA/#universal-modules-umd","title":"Universal Modules (UMD)","text":"<p>The final variation we'll look at is UMD, which is less a specific, exact format and more a collection of very similar formats. It was designed to create better interop (without any build-tool conversion) for modules that may be loaded in browsers, by AMD-style loaders, or in Node. I personally still publish many of my utility libraries using a form of UMD.</p> <p>Here's the typical structure of a UMD:</p> <pre><code>(function UMD(name,context,definition){\n// loaded by an AMD-style loader?\nif (\ntypeof define === \"function\" &amp;&amp;\ndefine.amd\n) {\ndefine(definition);\n}\n// in Node?\nelse if (\ntypeof module !== \"undefined\" &amp;&amp;\nmodule.exports\n) {\nmodule.exports = definition(name,context);\n}\n// assume standalone browser script\nelse {\ncontext[name] = definition(name,context);\n}\n})(\"StudentList\",this,function DEF(name,context){\nvar elems = [];\nreturn {\nrenderList() {\n// ..\n}\n};\n});\n</code></pre> <p>Though it may look a bit unusual, UMD is really just an IIFE.</p> <p>What's different is that the main <code>function</code> expression part (at the top) of the IIFE contains a series of <code>if..else if</code> statements to detect which of the three supported environments the module is being loaded in.</p> <p>The final <code>()</code> that normally invokes an IIFE is being passed three arguments: <code>\"StudentsList\"</code>, <code>this</code>, and another <code>function</code> expression. If you match those arguments to their parameters, you'll see they are: <code>name</code>, <code>context</code>, and <code>definition</code>, respectively. <code>\"StudentList\"</code> (<code>name</code>) is the name label for the module, primarily in case it's defined as a global variable. <code>this</code> (<code>context</code>) is generally the <code>window</code> (aka, global object; see Chapter 4) for defining the module by its name.</p> <p><code>definition(..)</code> is invoked to actually retrieve the definition of the module, and you'll notice that, sure enough, that's just a classic module form!</p> <p>There's no question that as of the time of this writing, ESM (ES Modules) are becoming popular and widespread rapidly. But with millions and millions of modules written over the last 20 years, all using some pre-ESM variation of classic modules, they're still very important to be able to read and understand when you come across them.</p> <ol> <li> <p>Inversion of Control, Martin Fowler, https://martinfowler.com/bliki/InversionOfControl.html, 26 June 2005.\u00a0\u21a9</p> </li> </ol>"},{"location":"scope-closures/apB/","title":"Appendix B: Practice","text":"<p>This appendix aims to give you some challenging and interesting exercises to test and solidify your understanding of the main topics from this book. It's a good idea to try out the exercises yourself\u2014in an actual code editor!\u2014instead of skipping straight to the solutions at the end. No cheating!</p> <p>These exercises don't have a specific right answer that you have to get exactly. Your approach may differ some (or a lot!) from the solutions presented, and that's OK.</p> <p>There's no judging you on how you write your code. My hope is that you come away from this book feeling confident that you can tackle these sorts of coding tasks built on a strong foundation of knowledge. That's the only objective, here. If you're happy with your code, I am, too!</p>"},{"location":"scope-closures/apB/#buckets-of-marbles","title":"Buckets of Marbles","text":"<p>Remember Figure 2 from back in Chapter 2?</p> Fig. 2 (Ch. 2): Colored Scope Bubbles <p>This exercise asks you to write a program\u2014any program!\u2014that contains nested functions and block scopes, which satisfies these constraints:</p> <ul> <li> <p>If you color all the scopes (including the global scope!) different colors, you need at least six colors. Make sure to add a code comment labeling each scope with its color.</p> <p>BONUS: identify any implied scopes your code may have.</p> </li> <li> <p>Each scope has at least one identifier.</p> </li> <li> <p>Contains at least two function scopes and at least two block scopes.</p> </li> <li> <p>At least one variable from an outer scope must be shadowed by a nested scope variable (see Chapter 3).</p> </li> <li> <p>At least one variable reference must resolve to a variable declaration at least two levels higher in the scope chain.</p> </li> </ul> TIP: You can just write junk foo/bar/baz-type code for this exercise, but I suggest you try to come up with some sort of non-trivial real'ish code that at least does something kind of reasonable. <p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>"},{"location":"scope-closures/apB/#closure-part-1","title":"Closure (PART 1)","text":"<p>Let's first practice closure with some common computer-math operations: determining if a value is prime (has no divisors other than 1 and itself), and generating a list of prime factors (divisors) for a given number.</p> <p>For example:</p> <pre><code>isPrime(11);        // true\nisPrime(12);        // false\nfactorize(11);      // [ 11 ]\nfactorize(12);      // [ 3, 2, 2 ] --&gt; 3*2*2=12\n</code></pre> <p>Here's an implementation of <code>isPrime(..)</code>, adapted from the Math.js library: 1</p> <pre><code>function isPrime(v) {\nif (v &lt;= 3) {\nreturn v &gt; 1;\n}\nif (v % 2 == 0 || v % 3 == 0) {\nreturn false;\n}\nvar vSqrt = Math.sqrt(v);\nfor (let i = 5; i &lt;= vSqrt; i += 6) {\nif (v % i == 0 || v % (i + 2) == 0) {\nreturn false;\n}\n}\nreturn true;\n}\n</code></pre> <p>And here's a somewhat basic implementation of <code>factorize(..)</code> (not to be confused with <code>factorial(..)</code> from Chapter 6):</p> <pre><code>function factorize(v) {\nif (!isPrime(v)) {\nlet i = Math.floor(Math.sqrt(v));\nwhile (v % i != 0) {\ni--;\n}\nreturn [\n...factorize(i),\n...factorize(v / i)\n];\n}\nreturn [v];\n}\n</code></pre> NOTE: I call this basic because it's not optimized for performance. It's binary-recursive (which isn't tail-call optimizable), and it creates a lot of intermediate array copies. It also doesn't order the discovered factors in any way. There are many, many other algorithms for this task, but I wanted to use something short and roughly understandable for our exercise. <p>If you were to call <code>isPrime(4327)</code> multiple times in a program, you can see that it would go through all its dozens of comparison/computation steps every time. If you consider <code>factorize(..)</code>, it's calling <code>isPrime(..)</code> many times as it computes the list of factors. And there's a good chance most of those calls are repeats. That's a lot of wasted work!</p> <p>The first part of this exercise is to use closure to implement a cache to remember the results of <code>isPrime(..)</code>, so that the primality (<code>true</code> or <code>false</code>) of a given number is only ever computed once. Hint: we already showed this sort of caching in Chapter 6 with <code>factorial(..)</code>.</p> <p>If you look at <code>factorize(..)</code>, it's implemented with recursion, meaning it calls itself repeatedly. That again means we may likely see a lot of wasted calls to compute prime factors for the same number. So the second part of the exercise is to use the same closure cache technique for <code>factorize(..)</code>.</p> <p>Use separate closures for caching of <code>isPrime(..)</code> and <code>factorize(..)</code>, rather than putting them inside a single scope.</p> <p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>"},{"location":"scope-closures/apB/#a-word-about-memory","title":"A Word About Memory","text":"<p>I want to share a little quick note about this closure cache technique and the impacts it has on your application's performance.</p> <p>We can see that in saving the repeated calls, we improve computation speed (in some cases, by a dramatic amount). But this usage of closure is making an explicit trade-off that you should be very aware of.</p> <p>The trade-off is memory. We're essentially growing our cache (in memory) unboundedly. If the functions in question were called many millions of times with mostly unique inputs, we'd be chewing up a lot of memory. This can definitely be worth the expense, but only if we think it's likely we see repetition of common inputs so that we're taking advantage of the cache.</p> <p>If most every call will have a unique input, and the cache is essentially never used to any benefit, this is an inappropriate technique to employ.</p> <p>It also might be a good idea to have a more sophisticated caching approach, such as an LRU (least recently used) cache, that limits its size; as it runs up to the limit, an LRU evicts the values that are... well, least recently used!</p> <p>The downside here is that LRU is quite non-trivial in its own right. You'll want to use a highly optimized implementation of LRU, and be keenly aware of all the trade-offs at play.</p>"},{"location":"scope-closures/apB/#closure-part-2","title":"Closure (PART 2)","text":"<p>In this exercise, we're going to again practive closure by defining a <code>toggle(..)</code> utility that gives us a value toggler.</p> <p>You will pass one or more values (as arguments) into <code>toggle(..)</code>, and get back a function. That returned function will alternate/rotate between all the passed-in values in order, one at a time, as it's called repeatedly.</p> <pre><code>function toggle(/* .. */) {\n// ..\n}\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\nhello();      // \"hello\"\nhello();      // \"hello\"\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"\n</code></pre> <p>The corner case of passing in no values to <code>toggle(..)</code> is not very important; such a toggler instance could just always return <code>undefined</code>.</p> <p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>"},{"location":"scope-closures/apB/#closure-part-3","title":"Closure (PART 3)","text":"<p>In this third and final exercise on closure, we're going to implement a basic calculator. The <code>calculator()</code> function will produce an instance of a calculator that maintains its own state, in the form of a function (<code>calc(..)</code>, below):</p> <pre><code>function calculator() {\n// ..\n}\nvar calc = calculator();\n</code></pre> <p>Each time <code>calc(..)</code> is called, you'll pass in a single character that represents a keypress of a calculator button. To keep things more straightforward, we'll restrict our calculator to supporting entering only digits (0-9), arithmetic operations (+, -, *, /), and \"=\" to compute the operation. Operations are processed strictly in the order entered; there's no \"( )\" grouping or operator precedence.</p> <p>We don't support entering decimals, but the divide operation can result in them. We don't support entering negative numbers, but the \"-\" operation can result in them. So, you should be able to produce any negative or decimal number by first entering an operation to compute it. You can then keep computing with that value.</p> <p>The return of <code>calc(..)</code> calls should mimic what would be shown on a real calculator, like reflecting what was just pressed, or computing the total when pressing \"=\".</p> <p>For example:</p> <pre><code>calc(\"4\");     // 4\ncalc(\"+\");     // +\ncalc(\"7\");     // 7\ncalc(\"3\");     // 3\ncalc(\"-\");     // -\ncalc(\"2\");     // 2\ncalc(\"=\");     // 75\ncalc(\"*\");     // *\ncalc(\"4\");     // 4\ncalc(\"=\");     // 300\ncalc(\"5\");     // 5\ncalc(\"-\");     // -\ncalc(\"5\");     // 5\ncalc(\"=\");     // 0\n</code></pre> <p>Since this usage is a bit clumsy, here's a <code>useCalc(..)</code> helper, that runs the calculator with characters one at a time from a string, and computes the display each time:</p> <pre><code>function useCalc(calc,keys) {\nreturn [...keys].reduce(\nfunction showDisplay(display,key){\nvar ret = String( calc(key) );\nreturn (\ndisplay +\n(\n(ret != \"\" &amp;&amp; key == \"=\") ?\n\"=\" :\n\"\"\n) +\nret\n);\n},\n\"\"\n);\n}\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n</code></pre> <p>The most sensible usage of this <code>useCalc(..)</code> helper is to always have \"=\" be the last character entered.</p> <p>Some of the formatting of the totals displayed by the calculator require special handling. I'm providing this <code>formatTotal(..)</code> function, which your calculator should use whenever it's going to return a current computed total (after an <code>\"=\"</code> is entered):</p> <pre><code>function formatTotal(display) {\nif (Number.isFinite(display)) {\n// constrain display to max 11 chars\nlet maxDigits = 11;\n// reserve space for \"e+\" notation?\nif (Math.abs(display) &gt; 99999999999) {\nmaxDigits -= 6;\n}\n// reserve space for \"-\"?\nif (display &lt; 0) {\nmaxDigits--;\n}\n// whole number?\nif (Number.isInteger(display)) {\ndisplay = display\n.toPrecision(maxDigits)\n.replace(/\\.0+$/,\"\");\n}\n// decimal\nelse {\n// reserve space for \".\"\nmaxDigits--;\n// reserve space for leading \"0\"?\nif (\nMath.abs(display) &gt;= 0 &amp;&amp;\nMath.abs(display) &lt; 1\n) {\nmaxDigits--;\n}\ndisplay = display\n.toPrecision(maxDigits)\n.replace(/0+$/,\"\");\n}\n}\nelse {\ndisplay = \"ERR\";\n}\nreturn display;\n}\n</code></pre> <p>Don't worry too much about how <code>formatTotal(..)</code> works. Most of its logic is a bunch of handling to limit the calculator display to 11 characters max, even if negatives, repeating decimals, or even \"e+\" exponential notation is required.</p> <p>Again, don't get too mired in the mud around calculator-specific behavior. Focus on the memory of closure.</p> <p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p>"},{"location":"scope-closures/apB/#modules","title":"Modules","text":"<p>This exercise is to convert the calculator from Closure (PART 3) into a module.</p> <p>We're not adding any additional functionality to the calculator, only changing its interface. Instead of calling a single function <code>calc(..)</code>, we'll be calling specific methods on the public API for each \"keypress\" of our calculator. The outputs stay the same.</p> <p>This module should be expressed as a classic module factory function called <code>calculator()</code>, instead of a singleton IIFE, so that multiple calculators can be created if desired.</p> <p>The public API should include the following methods:</p> <ul> <li><code>number(..)</code> (input: the character/number \"pressed\")</li> <li><code>plus()</code></li> <li><code>minus()</code></li> <li><code>mult()</code></li> <li><code>div()</code></li> <li><code>eq()</code></li> </ul> <p>Usage would look like:</p> <pre><code>var calc = calculator();\ncalc.number(\"4\");     // 4\ncalc.plus();          // +\ncalc.number(\"7\");     // 7\ncalc.number(\"3\");     // 3\ncalc.minus();         // -\ncalc.number(\"2\");     // 2\ncalc.eq();            // 75\n</code></pre> <p><code>formatTotal(..)</code> remains the same from that previous exercise. But the <code>useCalc(..)</code> helper needs to be adjusted to work with the module API:</p> <pre><code>function useCalc(calc,keys) {\nvar keyMappings = {\n\"+\": \"plus\",\n\"-\": \"minus\",\n\"*\": \"mult\",\n\"/\": \"div\",\n\"=\": \"eq\"\n};\nreturn [...keys].reduce(\nfunction showDisplay(display,key){\nvar fn = keyMappings[key] || \"number\";\nvar ret = String( calc[fn](key) );\nreturn (\ndisplay +\n(\n(ret != \"\" &amp;&amp; key == \"=\") ?\n\"=\" :\n\"\"\n) +\nret\n);\n},\n\"\"\n);\n}\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n</code></pre> <p>Try the exercise for yourself, then check out the suggested solution at the end of this appendix.</p> <p>As you work on this exercise, also spend some time considering the pros/cons of representing the calculator as a module as opposed to the closure-function approach from the previous exercise.</p> <p>BONUS: write out a few sentences explaining your thoughts.</p> <p>BONUS #2: try converting your module to other module formats, including: UMD, CommonJS, and ESM (ES Modules).</p>"},{"location":"scope-closures/apB/#suggested-solutions","title":"Suggested Solutions","text":"<p>Hopefully you've tried out the exercises before you're reading this far. No cheating!</p> <p>Remember, each suggested solution is just one of a bunch of different ways to approach the problems. They're not \"the right answer,\" but they do illustrate a reasonable way to approach each exercise.</p> <p>The most important benefit you can get from reading these suggested solutions is to compare them to your code and analyze why we each made similar or different choices. Don't get into too much bikeshedding; try to stay focused on the main topic rather than the small details.</p>"},{"location":"scope-closures/apB/#suggested-buckets-of-marbles","title":"Suggested: Buckets of Marbles","text":"<p>The Buckets of Marbles Exercise can be solved like this:</p> <pre><code>// RED(1)\nconst howMany = 100;\n// Sieve of Eratosthenes\nfunction findPrimes(howMany) {\n// BLUE(2)\nvar sieve = Array(howMany).fill(true);\nvar max = Math.sqrt(howMany);\nfor (let i = 2; i &lt; max; i++) {\n// GREEN(3)\nif (sieve[i]) {\n// ORANGE(4)\nlet j = Math.pow(i,2);\nfor (let k = j; k &lt; howMany; k += i) {\n// PURPLE(5)\nsieve[k] = false;\n}\n}\n}\nreturn sieve\n.map(function getPrime(flag,prime){\n// PINK(6)\nif (flag) return prime;\nreturn flag;\n})\n.filter(function onlyPrimes(v){\n// YELLOW(7)\nreturn !!v;\n})\n.slice(1);\n}\nfindPrimes(howMany);\n// [\n//    2, 3, 5, 7, 11, 13, 17,\n//    19, 23, 29, 31, 37, 41,\n//    43, 47, 53, 59, 61, 67,\n//    71, 73, 79, 83, 89, 97\n// ]\n</code></pre>"},{"location":"scope-closures/apB/#suggested-closure-part-1","title":"Suggested: Closure (PART 1)","text":"<p>The Closure Exercise (PART 1) for <code>isPrime(..)</code> and <code>factorize(..)</code>, can be solved like this:</p> <pre><code>var isPrime = (function isPrime(v){\nvar primes = {};\nreturn function isPrime(v) {\nif (v in primes) {\nreturn primes[v];\n}\nif (v &lt;= 3) {\nreturn (primes[v] = v &gt; 1);\n}\nif (v % 2 == 0 || v % 3 == 0) {\nreturn (primes[v] = false);\n}\nlet vSqrt = Math.sqrt(v);\nfor (let i = 5; i &lt;= vSqrt; i += 6) {\nif (v % i == 0 || v % (i + 2) == 0) {\nreturn (primes[v] = false);\n}\n}\nreturn (primes[v] = true);\n};\n})();\nvar factorize = (function factorize(v){\nvar factors = {};\nreturn function findFactors(v) {\nif (v in factors) {\nreturn factors[v];\n}\nif (!isPrime(v)) {\nlet i = Math.floor(Math.sqrt(v));\nwhile (v % i != 0) {\ni--;\n}\nreturn (factors[v] = [\n...findFactors(i),\n...findFactors(v / i)\n]);\n}\nreturn (factors[v] = [v]);\n};\n})();\n</code></pre> <p>The general steps I used for each utility:</p> <ol> <li> <p>Wrap an IIFE to define the scope for the cache variable to reside.</p> </li> <li> <p>In the underlying call, first check the cache, and if a result is already known, return.</p> </li> <li> <p>At each place where a <code>return</code> was happening originally, assign to the cache and just return the results of that assignment operation\u2014this is a space savings trick mostly just for brevity in the book.</p> </li> </ol> <p>I also renamed the inner function from <code>factorize(..)</code> to <code>findFactors(..)</code>. That's not technically necessary, but it helps it make clearer which function the recursive calls invoke.</p>"},{"location":"scope-closures/apB/#suggested-closure-part-2","title":"Suggested: Closure (PART 2)","text":"<p>The Closure Exercise (PART 2) <code>toggle(..)</code> can be solved like this:</p> <pre><code>function toggle(...vals) {\nvar unset = {};\nvar cur = unset;\nreturn function next(){\n// save previous value back at\n// the end of the list\nif (cur != unset) {\nvals.push(cur);\n}\ncur = vals.shift();\nreturn cur;\n};\n}\nvar hello = toggle(\"hello\");\nvar onOff = toggle(\"on\",\"off\");\nvar speed = toggle(\"slow\",\"medium\",\"fast\");\nhello();      // \"hello\"\nhello();      // \"hello\"\nonOff();      // \"on\"\nonOff();      // \"off\"\nonOff();      // \"on\"\nspeed();      // \"slow\"\nspeed();      // \"medium\"\nspeed();      // \"fast\"\nspeed();      // \"slow\"\n</code></pre>"},{"location":"scope-closures/apB/#suggested-closure-part-3","title":"Suggested: Closure (PART 3)","text":"<p>The Closure Exercise (PART 3) <code>calculator()</code> can be solved like this:</p> <pre><code>// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\nfunction calculator() {\nvar currentTotal = 0;\nvar currentVal = \"\";\nvar currentOper = \"=\";\nreturn pressKey;\n// ********************\nfunction pressKey(key){\n// number key?\nif (/\\d/.test(key)) {\ncurrentVal += key;\nreturn key;\n}\n// operator key?\nelse if (/[+*/-]/.test(key)) {\n// multiple operations in a series?\nif (\ncurrentOper != \"=\" &amp;&amp;\ncurrentVal != \"\"\n) {\n// implied '=' keypress\npressKey(\"=\");\n}\nelse if (currentVal != \"\") {\ncurrentTotal = Number(currentVal);\n}\ncurrentOper = key;\ncurrentVal = \"\";\nreturn key;\n}\n// = key?\nelse if (\nkey == \"=\" &amp;&amp;\ncurrentOper != \"=\"\n) {\ncurrentTotal = op(\ncurrentTotal,\ncurrentOper,\nNumber(currentVal)\n);\ncurrentOper = \"=\";\ncurrentVal = \"\";\nreturn formatTotal(currentTotal);\n}\nreturn \"\";\n};\nfunction op(val1,oper,val2) {\nvar ops = {\n// NOTE: using arrow functions\n// only for brevity in the book\n\"+\": (v1,v2) =&gt; v1 + v2,\n\"-\": (v1,v2) =&gt; v1 - v2,\n\"*\": (v1,v2) =&gt; v1 * v2,\n\"/\": (v1,v2) =&gt; v1 / v2\n};\nreturn ops[oper](val1,val2);\n}\n}\nvar calc = calculator();\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n</code></pre> NOTE: Remember: this exercise is about closure. Don't focus too much on the actual mechanics of a calculator, but rather on whether you are properly remembering the calculator state across function calls."},{"location":"scope-closures/apB/#suggested-modules","title":"Suggested: Modules","text":"<p>The Modules Exercise <code>calculator()</code> can be solved like this:</p> <pre><code>// from earlier:\n//\n// function useCalc(..) { .. }\n// function formatTotal(..) { .. }\nfunction calculator() {\nvar currentTotal = 0;\nvar currentVal = \"\";\nvar currentOper = \"=\";\nvar publicAPI = {\nnumber,\neq,\nplus() { return operator(\"+\"); },\nminus() { return operator(\"-\"); },\nmult() { return operator(\"*\"); },\ndiv() { return operator(\"/\"); }\n};\nreturn publicAPI;\n// ********************\nfunction number(key) {\n// number key?\nif (/\\d/.test(key)) {\ncurrentVal += key;\nreturn key;\n}\n}\nfunction eq() {\n// = key?\nif (currentOper != \"=\") {\ncurrentTotal = op(\ncurrentTotal,\ncurrentOper,\nNumber(currentVal)\n);\ncurrentOper = \"=\";\ncurrentVal = \"\";\nreturn formatTotal(currentTotal);\n}\nreturn \"\";\n}\nfunction operator(key) {\n// multiple operations in a series?\nif (\ncurrentOper != \"=\" &amp;&amp;\ncurrentVal != \"\"\n) {\n// implied '=' keypress\neq();\n}\nelse if (currentVal != \"\") {\ncurrentTotal = Number(currentVal);\n}\ncurrentOper = key;\ncurrentVal = \"\";\nreturn key;\n}\nfunction op(val1,oper,val2) {\nvar ops = {\n// NOTE: using arrow functions\n// only for brevity in the book\n\"+\": (v1,v2) =&gt; v1 + v2,\n\"-\": (v1,v2) =&gt; v1 - v2,\n\"*\": (v1,v2) =&gt; v1 * v2,\n\"/\": (v1,v2) =&gt; v1 / v2\n};\nreturn ops[oper](val1,val2);\n}\n}\nvar calc = calculator();\nuseCalc(calc,\"4+3=\");           // 4+3=7\nuseCalc(calc,\"+9=\");            // +9=16\nuseCalc(calc,\"*8=\");            // *5=128\nuseCalc(calc,\"7*2*3=\");         // 7*2*3=42\nuseCalc(calc,\"1/0=\");           // 1/0=ERR\nuseCalc(calc,\"+3=\");            // +3=ERR\nuseCalc(calc,\"51=\");            // 51\n</code></pre> <p>That's it for this book, congratulations on your achievement! When you're ready, move on to Book 3, Objects &amp; Classes.</p> <ol> <li> <p>Math.js: isPrime(..), https://github.com/josdejong/mathjs/blob/develop/src/function/utils/isPrime.js, 3 March 2020.\u00a0\u21a9</p> </li> </ol>"},{"location":"scope-closures/ch1/","title":"Chapter 1: What's the Scope?","text":"<p>scope_bard.md</p> <p>By the time you've written your first few programs, you're likely getting somewhat comfortable with creating variables and storing values in them. Working with variables is one of the most foundational things we do in programming!</p> <p>But you may not have considered very closely the underlying mechanisms used by the engine to organize and manage these variables. I don't mean how the memory is allocated on the computer, but rather: how does JS know which variables are accessible by any given statement, and how does it handle two variables of the same name?</p> <p>The answers to questions like these take the form of well-defined rules called scope. This book will dig through all aspects of scope\u2014how it works, what it's useful for, gotchas to avoid\u2014and then point toward common scope patterns that guide the structure of programs.</p> <p>Our first step is to uncover how the JS engine processes our program before it runs.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#about-this-book","title":"About This Book","text":"<p>Welcome to book 2 in the You Don't Know JS Yet series! If you already finished Get Started (the first book), you're in the right spot! If not, before you proceed I encourage you to start there for the best foundation.</p> <p>Our focus will be the first of three pillars in the JS language: the scope system and its function closures, as well as the power of the module design pattern.</p> <p>JS is typically classified as an interpreted scripting language, so it's assumed by most that JS programs are processed in a single, top-down pass. But JS is in fact parsed/compiled in a separate phase before execution begins. The code author's decisions on where to place variables, functions, and blocks with respect to each other are analyzed according to the rules of scope, during the initial parsing/compilation phase. The resulting scope structure is generally unaffected by runtime conditions.</p> <p>JS functions are themselves first-class values; they can be assigned and passed around just like numbers or strings. But since these functions hold and access variables, they maintain their original scope no matter where in the program the functions are eventually executed. This is called closure.</p> <p>Modules are a code organization pattern characterized by public methods that have privileged access (via closure) to hidden variables and functions in the internal scope of the module.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#compiled-vs-interpreted","title":"Compiled vs. Interpreted","text":"<p>You may have heard of code compilation before, but perhaps it seems like a mysterious black box where source code slides in one end and executable programs pop out the other.</p> <p>It's not mysterious or magical, though. Code compilation is a set of steps that process the text of your code and turn it into a list of instructions the computer can understand. Typically, the whole source code is transformed at once, and those resulting instructions are saved as output (usually in a file) that can later be executed.</p> <p>You also may have heard that code can be interpreted, so how is that different from being compiled?</p> <p>Interpretation performs a similar task to compilation, in that it transforms your program into machine-understandable instructions. But the processing model is different. Unlike a program being compiled all at once, with interpretation the source code is transformed line by line; each line or statement is executed before immediately proceeding to processing the next line of the source code.</p> Fig. 1: Compiled vs. Interpreted Code <p>Figure 1 illustrates compilation vs. interpretation of programs.</p> <p>Are these two processing models mutually exclusive? Generally, yes. However, the issue is more nuanced, because interpretation can actually take other forms than just operating line by line on source code text. Modern JS engines actually employ numerous variations of both compilation and interpretation in the handling of JS programs.</p> <p>Recall that we surveyed this topic in Chapter 1 of the Get Started book. Our conclusion there is that JS is most accurately portrayed as a compiled language. For the benefit of readers here, the following sections will revisit and expand on that assertion.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#compiling-code","title":"Compiling Code","text":"<p>But first, why does it even matter whether JS is compiled or not?</p> <p>Scope is primarily determined during compilation, so understanding how compilation and execution relate is key in mastering scope.</p> <p>In classic compiler theory, a program is processed by a compiler in three basic stages:</p> <ol> <li> <p>Tokenizing/Lexing: breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: <code>var a = 2;</code>. This program would likely be broken up into the following tokens: <code>var</code>, <code>a</code>, <code>=</code>, <code>2</code>, and <code>;</code>. Whitespace may or may not be persisted as a token, depending on whether it's meaningful or not.</p> <p>(The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a stateless or stateful way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether <code>a</code> should be considered a distinct token or just part of another token, that would be lexing.)</p> </li> <li> <p>Parsing: taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This is called an Abstract Syntax Tree (AST).</p> <p>For example, the tree for <code>var a = 2;</code> might start with a top-level node called <code>VariableDeclaration</code>, with a child node called <code>Identifier</code> (whose value is <code>a</code>), and another child called <code>AssignmentExpression</code> which itself has a child called <code>NumericLiteral</code> (whose value is <code>2</code>).</p> </li> <li> <p>Code Generation: taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it's targeting, and other factors.</p> <p>The JS engine takes the just described AST for <code>var a = 2;</code> and turns it into a set of machine instructions to actually create a variable called <code>a</code> (including reserving memory, etc.), and then store a value into <code>a</code>.</p> </li> </ol> NOTE: The implementation details of a JS engine (utilizing system memory resources, etc.) is much deeper than we will dig here. We'll keep our focus on the observable behavior of our programs and let the JS engine manage those deeper system-level abstractions. <p>The JS engine is vastly more complex than just these three stages. In the process of parsing and code generation, there are steps to optimize the performance of the execution (i.e., collapsing redundant elements). In fact, code can even be re-compiled and re-optimized during the progression of execution.</p> <p>So, I'm painting only with broad strokes here. But you'll see shortly why these details we do cover, even at a high level, are relevant.</p> <p>JS engines don't have the luxury of an abundance of time to perform their work and optimizations, because JS compilation doesn't happen in a build step ahead of time, as with other languages. It usually must happen in mere microseconds (or less!) right before the code is executed. To ensure the fastest performance under these constraints, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile); these are well beyond the \"scope\" of our discussion here.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#required-two-phases","title":"Required: Two Phases","text":"<p>To state it as simply as possible, the most important observation we can make about processing of JS programs is that it occurs in (at least) two phases: parsing/compilation first, then execution.</p> <p>The separation of a parsing/compilation phase from the subsequent execution phase is observable fact, not theory or opinion. While the JS specification does not require \"compilation\" explicitly, it requires behavior that is essentially only practical with a compile-then-execute approach.</p> <p>There are three program characteristics you can observe to prove this to yourself: syntax errors, early errors, and hoisting.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#syntax-errors-from-the-start","title":"Syntax Errors from the Start","text":"<p>Consider this program:</p> <pre><code>var greeting = \"Hello\";\nconsole.log(greeting);\ngreeting = .\"Hi\";\n// SyntaxError: unexpected token .\n</code></pre> <p>This program produces no output (<code>\"Hello\"</code> is not printed), but instead throws a <code>SyntaxError</code> about the unexpected <code>.</code> token right before the <code>\"Hi\"</code> string. Since the syntax error happens after the well-formed <code>console.log(..)</code> statement, if JS was executing top-down line by line, one would expect the <code>\"Hello\"</code> message being printed before the syntax error being thrown. That doesn't happen.</p> <p>In fact, the only way the JS engine could know about the syntax error on the third line, before executing the first and second lines, is by the JS engine first parsing the entire program before any of it is executed.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#early-errors","title":"Early Errors","text":"<p>Next, consider:</p> <pre><code>console.log(\"Howdy\");\nsaySomething(\"Hello\",\"Hi\");\n// Uncaught SyntaxError: Duplicate parameter name not\n// allowed in this context\nfunction saySomething(greeting,greeting) {\n\"use strict\";\nconsole.log(greeting);\n}\n</code></pre> <p>The <code>\"Howdy\"</code> message is not printed, despite being a well-formed statement.</p> <p>Instead, just like the snippet in the previous section, the <code>SyntaxError</code> here is thrown before the program is executed. In this case, it's because strict-mode (opted in for only the <code>saySomething(..)</code> function here) forbids, among many other things, functions to have duplicate parameter names; this has always been allowed in non-strict-mode.</p> <p>The error thrown is not a syntax error in the sense of being a malformed string of tokens (like <code>.\"Hi\"</code> prior), but in strict-mode is nonetheless required by the specification to be thrown as an \"early error\" before any execution begins.</p> <p>But how does the JS engine know that the <code>greeting</code> parameter has been duplicated? How does it know that the <code>saySomething(..)</code> function is even in strict-mode while processing the parameter list (the <code>\"use strict\"</code> pragma appears only later, in the function body)?</p> <p>Again, the only reasonable explanation is that the code must first be fully parsed before any execution occurs.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#hoisting","title":"Hoisting","text":"<p>Finally, consider:</p> <pre><code>function saySomething() {\nvar greeting = \"Hello\";\n{\ngreeting = \"Howdy\";  // error comes from here\nlet greeting = \"Hi\";\nconsole.log(greeting);\n}\n}\nsaySomething();\n// ReferenceError: Cannot access 'greeting' before\n// initialization\n</code></pre> <p>The noted <code>ReferenceError</code> occurs from the line with the statement <code>greeting = \"Howdy\"</code>. What's happening is that the <code>greeting</code> variable for that statement belongs to the declaration on the next line, <code>let greeting = \"Hi\"</code>, rather than to the previous <code>var greeting = \"Hello\"</code> statement.</p> <p>The only way the JS engine could know, at the line where the error is thrown, that the next statement would declare a block-scoped variable of the same name (<code>greeting</code>) is if the JS engine had already processed this code in an earlier pass, and already set up all the scopes and their variable associations. This processing of scopes and declarations can only accurately be accomplished by parsing the program before execution.</p> <p>The <code>ReferenceError</code> here technically comes from <code>greeting = \"Howdy\"</code> accessing the <code>greeting</code> variable too early, a conflict referred to as the Temporal Dead Zone (TDZ). Chapter 5 will cover this in more detail.</p> WARNING: It's often asserted that <code>let</code> and <code>const</code> declarations are not hoisted, as an explanation of the TDZ behavior just illustrated. But this is not accurate. We'll come back and explain both the hoisting and TDZ of <code>let</code>/<code>const</code> in Chapter 5. <p>Hopefully you're now convinced that JS programs are parsed before any execution begins. But does it prove they are compiled?</p> <p>This is an interesting question to ponder. Could JS parse a program, but then execute that program by interpreting operations represented in the AST without first compiling the program? Yes, that is possible. But it's extremely unlikely, mostly because it would be extremely inefficient performance wise.</p> <p>It's hard to imagine a production-quality JS engine going to all the trouble of parsing a program into an AST, but not then converting (aka, \"compiling\") that AST into the most efficient (binary) representation for the engine to then execute.</p> <p>Many have endeavored to split hairs with this terminology, as there's plenty of nuance and \"well, actually...\" interjections floating around. But in spirit and in practice, what the engine is doing in processing JS programs is much more alike compilation than not.</p> <p>Classifying JS as a compiled language is not concerned with the distribution model for its binary (or byte-code) executable representations, but rather in keeping a clear distinction in our minds about the phase where JS code is processed and analyzed; this phase observably and indisputedly happens before the code starts to be executed.</p> <p>We need proper mental models of how the JS engine treats our code if we want to understand JS and scope effectively.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#compiler-speak","title":"Compiler Speak","text":"<p>With awareness of the two-phase processing of a JS program (compile, then execute), let's turn our attention to how the JS engine identifies variables and determines the scopes of a program as it is compiled.</p> <p>First, let's examine a simple JS program to use for analysis over the next several chapters:</p> <pre><code>var students = [\n{ id: 14, name: \"Kyle\" },\n{ id: 73, name: \"Suzy\" },\n{ id: 112, name: \"Frank\" },\n{ id: 6, name: \"Sarah\" }\n];\nfunction getStudentName(studentID) {\nfor (let student of students) {\nif (student.id == studentID) {\nreturn student.name;\n}\n}\n}\nvar nextStudent = getStudentName(73);\nconsole.log(nextStudent);\n// Suzy\n</code></pre> <p>Other than declarations, all occurrences of variables/identifiers in a program serve in one of two \"roles\": either they're the target of an assignment or they're the source of a value.</p> <p>(When I first learned compiler theory while earning my computer science degree, we were taught the terms \"LHS\" (aka, target) and \"RHS\" (aka, source) for these roles, respectively. As you might guess from the \"L\" and the \"R\", the acronyms mean \"Left-Hand Side\" and \"Right-Hand Side\", as in left and right sides of an <code>=</code> assignment operator. However, assignment targets and sources don't always literally appear on the left or right of an <code>=</code>, so it's probably clearer to think in terms of target / source rather than left / right.)</p> <p>How do you know if a variable is a target? Check if there is a value that is being assigned to it; if so, it's a target. If not, then the variable is a source.</p> <p>For the JS engine to properly handle a program's variables, it must first label each occurrence of a variable as target or source. We'll dig in now to how each role is determined.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#targets","title":"Targets","text":"<p>What makes a variable a target? Consider:</p> <pre><code>students = [ // ..\n</code></pre> <p>This statement is clearly an assignment operation; remember, the <code>var students</code> part is handled entirely as a declaration at compile time, and is thus irrelevant during execution; we left it out for clarity and focus. Same with the <code>nextStudent = getStudentName(73)</code> statement.</p> <p>But there are three other target assignment operations in the code that are perhaps less obvious. One of them:</p> <pre><code>for (let student of students) {\n</code></pre> <p>That statement assigns a value to <code>student</code> for each iteration of the loop. Another target reference:</p> <pre><code>getStudentName(73)\n</code></pre> <p>But how is that an assignment to a target? Look closely: the argument <code>73</code> is assigned to the parameter <code>studentID</code>.</p> <p>And there's one last (subtle) target reference in our program. Can you spot it?</p> <p>..</p> <p>..</p> <p>..</p> <p>Did you identify this one?</p> <pre><code>function getStudentName(studentID) {\n</code></pre> <p>A <code>function</code> declaration is a special case of a target reference. You can think of it sort of like <code>var getStudentName = function(studentID)</code>, but that's not exactly accurate. An identifier <code>getStudentName</code> is declared (at compile time), but the <code>= function(studentID)</code> part is also handled at compilation; the association between <code>getStudentName</code> and the function is automatically set up at the beginning of the scope rather than waiting for an <code>=</code> assignment statement to be executed.</p> NOTE: This automatic association of function and variable is referred to as \"function hoisting\", and is covered in detail in Chapter 5.","tags":["bard","scope"]},{"location":"scope-closures/ch1/#sources","title":"Sources","text":"<p>So we've identified all five target references in the program. The other variable references must then be source references (because that's the only other option!).</p> <p>In <code>for (let student of students)</code>, we said that <code>student</code> is a target, but <code>students</code> is a source reference. In the statement <code>if (student.id == studentID)</code>, both <code>student</code> and <code>studentID</code> are source references. <code>student</code> is also a source reference in <code>return student.name</code>.</p> <p>In <code>getStudentName(73)</code>, <code>getStudentName</code> is a source reference (which we hope resolves to a function reference value). In <code>console.log(nextStudent)</code>, <code>console</code> is a source reference, as is <code>nextStudent</code>.</p> NOTE: In case you were wondering, <code>id</code>, <code>name</code>, and <code>log</code> are all properties, not variable references. <p>What's the practical importance of understanding targets vs. sources? In Chapter 2, we'll revisit this topic and cover how a variable's role impacts its lookup (specifically, if the lookup fails).</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#cheating-runtime-scope-modifications","title":"Cheating: Runtime Scope Modifications","text":"<p>It should be clear by now that scope is determined as the program is compiled, and should not generally be affected by runtime conditions. However, in non-strict-mode, there are technically still two ways to cheat this rule, modifying a program's scopes during runtime.</p> <p>Neither of these techniques should be used\u2014they're both dangerous and confusing, and you should be using strict-mode (where they're disallowed) anyway. But it's important to be aware of them in case you run across them in some programs.</p> <p>The <code>eval(..)</code> function receives a string of code to compile and execute on the fly during the program runtime. If that string of code has a <code>var</code> or <code>function</code> declaration in it, those declarations will modify the current scope that the <code>eval(..)</code> is currently executing in:</p> <pre><code>function badIdea() {\neval(\"var oops = 'Ugh!';\");\nconsole.log(oops);\n}\nbadIdea();   // Ugh!\n</code></pre> <p>If the <code>eval(..)</code> had not been present, the <code>oops</code> variable in <code>console.log(oops)</code> would not exist, and would throw a <code>ReferenceError</code>. But <code>eval(..)</code> modifies the scope of the <code>badIdea()</code> function at runtime. This is bad for many reasons, including the performance hit of modifying the already compiled and optimized scope, every time <code>badIdea()</code> runs.</p> <p>The second cheat is the <code>with</code> keyword, which essentially dynamically turns an object into a local scope\u2014its properties are treated as identifiers in that new scope's block:</p> <pre><code>var badIdea = { oops: \"Ugh!\" };\nwith (badIdea) {\nconsole.log(oops);   // Ugh!\n}\n</code></pre> <p>The global scope was not modified here, but <code>badIdea</code> was turned into a scope at runtime rather than compile time, and its property <code>oops</code> becomes a variable in that scope. Again, this is a terrible idea, for performance and readability reasons.</p> <p>At all costs, avoid <code>eval(..)</code> (at least, <code>eval(..)</code> creating declarations) and <code>with</code>. Again, neither of these cheats is available in strict-mode, so if you just use strict-mode (you should!) then the temptation goes away!</p>","tags":["bard","scope"]},{"location":"scope-closures/ch1/#lexical-scope","title":"Lexical Scope","text":"<p>We've demonstrated that JS's scope is determined at compile time; the term for this kind of scope is \"LEXICAL scope\". \"Lexical\" is associated with the \"lexing\" stage of compilation, as discussed earlier in this chapter.</p> <p>To narrow this chapter down to a useful conclusion, the key idea of \"LEXICAL scope\" is that it's controlled entirely by the placement of functions, blocks, and variable declarations, in relation to one another.</p> <p>If you place a variable declaration inside a function, the compiler handles this declaration as it's parsing the function, and associates that declaration with the function's scope. If a variable is block-scope declared (<code>let</code> / <code>const</code>), then it's associated with the nearest enclosing <code>{ .. }</code> block, rather than its enclosing function (as with <code>var</code>).</p> <p>Furthermore, a reference (target or source role) for a variable must be resolved as coming from one of the scopes that are lexically available to it; otherwise the variable is said to be \"undeclared\" (which usually results in an error!). If the variable is not declared in the current scope, the next outer/enclosing scope will be consulted. This process of stepping out one level of scope nesting continues until either a matching variable declaration can be found, or the global scope is reached and there's nowhere else to go.</p> <p>It's important to note that compilation doesn't actually do anything in terms of reserving memory for scopes and variables. None of the program has been executed yet.</p> <p>Instead, compilation creates a map of all the LEXICAL scopes that lays out what the program will need while it executes. You can think of this plan as inserted code for use at runtime, which defines all the scopes (aka, \"LEXICAL environments\") and registers all the identifiers (variables) for each scope.</p> <p>In other words, while scopes are identified during compilation, they're not actually created until runtime, each time a scope needs to run. In the next chapter, we'll sketch out the conceptual foundations for LEXICAL scope.</p>","tags":["bard","scope"]},{"location":"scope-closures/ch2/","title":"Chapter 2: Illustrating Lexical Scope","text":"<p>In Chapter 1, we explored how scope is determined during code compilation, a model called \"LEXICAL scope.\" The term \"lexical\" refers to the first stage of compilation (lexing/parsing).</p> <p>To properly reason about our programs, it's important to have a solid conceptual foundation of how scope works. If we rely on guesses and intuition, we may accidentally get the right answers some of the time, but many other times we're far off. This isn't a recipe for success.</p> <p>Like way back in grade school math class, getting the right answer isn't enough if we don't show the correct steps to get there! We need to build accurate and helpful mental models as foundation moving forward.</p> <p>This chapter will illustrate scope with several metaphors. The goal here is to think about how your program is handled by the JS engine in ways that more closely align with how the JS engine actually works.</p>"},{"location":"scope-closures/ch2/#marbles-and-buckets-and-bubbles-oh-my","title":"Marbles, and Buckets, and Bubbles... Oh My!","text":"<p>One metaphor I've found effective in understanding scope is sorting colored marbles into buckets of their matching color.</p> <p>Imagine you come across a pile of marbles, and notice that all the marbles are colored red, blue, or green. Let's sort all the marbles, dropping the red ones into a red bucket, green into a green bucket, and blue into a blue bucket. After sorting, when you later need a green marble, you already know the green bucket is where to go to get it.</p> <p>In this metaphor, the marbles are the variables in our program. The buckets are scopes (functions and blocks), which we just conceptually assign individual colors for our discussion purposes. The color of each marble is thus determined by which color scope we find the marble originally created in.</p> <p>Let's annotate the running program example from Chapter 1 with scope color labels:</p> <pre><code>// outer/global scope: RED\nvar students = [\n{ id: 14, name: \"Kyle\" },\n{ id: 73, name: \"Suzy\" },\n{ id: 112, name: \"Frank\" },\n{ id: 6, name: \"Sarah\" }\n];\nfunction getStudentName(studentID) {\n// function scope: BLUE\nfor (let student of students) {\n// loop scope: GREEN\nif (student.id == studentID) {\nreturn student.name;\n}\n}\n}\nvar nextStudent = getStudentName(73);\nconsole.log(nextStudent);   // Suzy\n</code></pre> <p>We've designated three scope colors with code comments: RED (outermost global scope), BLUE (scope of function <code>getStudentName(..)</code>), and GREEN (scope of/inside the <code>for</code> loop). But it still may be difficult to recognize the boundaries of these scope buckets when looking at a code listing.</p> <p>Figure 2 helps visualize the boundaries of the scopes by drawing colored bubbles (aka, buckets) around each:</p> Fig. 2: Colored Scope Bubbles <ol> <li> <p>Bubble 1 (RED) encompasses the global scope, which holds three identifiers/variables: <code>students</code> (line 1), <code>getStudentName</code> (line 8), and <code>nextStudent</code> (line 16).</p> </li> <li> <p>Bubble 2 (BLUE) encompasses the scope of the function <code>getStudentName(..)</code> (line 8), which holds just one identifier/variable: the parameter <code>studentID</code> (line 8).</p> </li> <li> <p>Bubble 3 (GREEN) encompasses the scope of the <code>for</code>-loop (line 9), which holds just one identifier/variable: <code>student</code> (line 9).</p> </li> </ol> NOTE: Technically, the parameter <code>studentID</code> is not exactly in the BLUE(2) scope. We'll unwind that confusion in \"Implied Scopes\" in Appendix A. For now, it's close enough to label <code>studentID</code> a BLUE(2) marble. <p>Scope bubbles are determined during compilation based on where the functions/blocks of scope are written, the nesting inside each other, and so on. Each scope bubble is entirely contained within its parent scope bubble\u2014a scope is never partially in two different outer scopes.</p> <p>Each marble (variable/identifier) is colored based on which bubble (bucket) it's declared in, not the color of the scope it may be accessed from (e.g., <code>students</code> on line 9 and <code>studentID</code> on line 10).</p> NOTE: Remember we asserted in Chapter 1 that <code>id</code>, <code>name</code>, and <code>log</code> are all properties, not variables; in other words, they're not marbles in buckets, so they don't get colored based on any the rules we're discussing in this book. To understand how such property accesses are handled, see the third book in the series, Objects &amp; Classes. <p>As the JS engine processes a program (during compilation), and finds a declaration for a variable, it essentially asks, \"Which color scope (bubble or bucket) am I currently in?\" The variable is designated as that same color, meaning it belongs to that bucket/bubble.</p> <p>The GREEN(3) bucket is wholly nested inside of the BLUE(2) bucket, and similarly the BLUE(2) bucket is wholly nested inside the RED(1) bucket. Scopes can nest inside each other as shown, to any depth of nesting as your program needs.</p> <p>References (non-declarations) to variables/identifiers are allowed if there's a matching declaration either in the current scope, or any scope above/outside the current scope, but not with declarations from lower/nested scopes.</p> <p>An expression in the RED(1) bucket only has access to RED(1) marbles, not BLUE(2) or GREEN(3). An expression in the BLUE(2) bucket can reference either BLUE(2) or RED(1) marbles, not GREEN(3). And an expression in the GREEN(3) bucket has access to RED(1), BLUE(2), and GREEN(3) marbles.</p> <p>We can conceptualize the process of determining these non-declaration marble colors during runtime as a lookup. Since the <code>students</code> variable reference in the <code>for</code>-loop statement on line 9 is not a declaration, it has no color. So we ask the current BLUE(2) scope bucket if it has a marble matching that name. Since it doesn't, the lookup continues with the next outer/containing scope: RED(1). The RED(1) bucket has a marble of the name <code>students</code>, so the loop-statement's <code>students</code> variable reference is determined to be a RED(1) marble.</p> <p>The <code>if (student.id == studentID)</code> statement on line 10 is similarly determined to reference a GREEN(3) marble named <code>student</code> and a BLUE(2) marble <code>studentID</code>.</p> NOTE: The JS engine doesn't generally determine these marble colors during runtime; the \"lookup\" here is a rhetorical device to help you understand the concepts. During compilation, most or all variable references will match already-known scope buckets, so their color is already determined, and stored with each marble reference to avoid unnecessary lookups as the program runs. More on this nuance in Chapter 3. <p>The key take-aways from marbles &amp; buckets (and bubbles!):</p> <ul> <li> <p>Variables are declared in specific scopes, which can be thought of as colored marbles from matching-color buckets.</p> </li> <li> <p>Any variable reference that appears in the scope where it was declared, or appears in any deeper nested scopes, will be labeled a marble of that same color\u2014unless an intervening scope \"shadows\" the variable declaration; see \"Shadowing\" in Chapter 3.</p> </li> <li> <p>The determination of colored buckets, and the marbles they contain, happens during compilation. This information is used for variable (marble color) \"lookups\" during code execution.</p> </li> </ul>"},{"location":"scope-closures/ch2/#a-conversation-among-friends","title":"A Conversation Among Friends","text":"<p>Another useful metaphor for the process of analyzing variables and the scopes they come from is to imagine various conversations that occur inside the engine as code is processed and then executed. We can \"listen in\" on these conversations to get a better conceptual foundation for how scopes work.</p> <p>Let's now meet the members of the JS engine that will have conversations as they process our program:</p> <ul> <li> <p>Engine: responsible for start-to-finish compilation and execution of our JavaScript program.</p> </li> <li> <p>Compiler: one of Engine's friends; handles all the dirty work of parsing and code-generation (see previous section).</p> </li> <li> <p>Scope Manager: another friend of Engine; collects and maintains a lookup list of all the declared variables/identifiers, and enforces a set of rules as to how these are accessible to currently executing code.</p> </li> </ul> <p>For you to fully understand how JavaScript works, you need to begin to think like Engine (and friends) think, ask the questions they ask, and answer their questions likewise.</p> <p>To explore these conversations, recall again our running program example:</p> <pre><code>var students = [\n{ id: 14, name: \"Kyle\" },\n{ id: 73, name: \"Suzy\" },\n{ id: 112, name: \"Frank\" },\n{ id: 6, name: \"Sarah\" }\n];\nfunction getStudentName(studentID) {\nfor (let student of students) {\nif (student.id == studentID) {\nreturn student.name;\n}\n}\n}\nvar nextStudent = getStudentName(73);\nconsole.log(nextStudent);\n// Suzy\n</code></pre> <p>Let's examine how JS is going to process that program, specifically starting with the first statement. The array and its contents are just basic JS value literals (and thus unaffected by any scoping concerns), so our focus here will be on the <code>var students = [ .. ]</code> declaration and initialization-assignment parts.</p> <p>We typically think of that as a single statement, but that's not how our friend Engine sees it. In fact, JS treats these as two distinct operations, one which Compiler will handle during compilation, and the other which Engine will handle during execution.</p> <p>The first thing Compiler will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree (AST).</p> <p>Once Compiler gets to code generation, there's more detail to consider than may be obvious. A reasonable assumption would be that Compiler will produce code for the first statement such as: \"Allocate memory for a variable, label it <code>students</code>, then stick a reference to the array into that variable.\" But that's not the whole story.</p> <p>Here's the steps Compiler will follow to handle that statement:</p> <ol> <li> <p>Encountering <code>var students</code>, Compiler will ask Scope Manager to see if a variable named <code>students</code> already exists for that particular scope bucket. If so, Compiler would ignore this declaration and move on. Otherwise, Compiler will produce code that (at execution time) asks Scope Manager to create a new variable called <code>students</code> in that scope bucket.</p> </li> <li> <p>Compiler then produces code for Engine to later execute, to handle the <code>students = []</code> assignment. The code Engine runs will first ask Scope Manager if there is a variable called <code>students</code> accessible in the current scope bucket. If not, Engine keeps looking elsewhere (see \"Nested Scope\" below). Once Engine finds a variable, it assigns the reference of the <code>[ .. ]</code> array to it.</p> </li> </ol> <p>In conversational form, the first phase of compilation for the program might play out between Compiler and Scope Manager like this:</p> <p>Compiler: Hey, Scope Manager (of the global scope), I found a formal declaration for an identifier called <code>students</code>, ever heard of it?</p> <p>(Global) Scope Manager: Nope, never heard of it, so I just created it for you.</p> <p>Compiler: Hey, Scope Manager, I found a formal declaration for an identifier called <code>getStudentName</code>, ever heard of it?</p> <p>(Global) Scope Manager: Nope, but I just created it for you.</p> <p>Compiler: Hey, Scope Manager, <code>getStudentName</code> points to a function, so we need a new scope bucket.</p> <p>(Function) Scope Manager: Got it, here's the scope bucket.</p> <p>Compiler: Hey, Scope Manager (of the function), I found a formal parameter declaration for <code>studentID</code>, ever heard of it?</p> <p>(Function) Scope Manager: Nope, but now it's created in this scope.</p> <p>Compiler: Hey, Scope Manager (of the function), I found a <code>for</code>-loop that will need its own scope bucket.</p> <p>...</p> <p>The conversation is a question-and-answer exchange, where Compiler asks the current Scope Manager if an encountered identifier declaration has already been encountered. If \"no,\" Scope Manager creates that variable in that scope. If the answer is \"yes,\" then it's effectively skipped over since there's nothing more for that Scope Manager to do.</p> <p>Compiler also signals when it runs across functions or block scopes, so that a new scope bucket and Scope Manager can be instantiated.</p> <p>Later, when it comes to execution of the program, the conversation will shift to Engine and Scope Manager, and might play out like this:</p> <p>Engine: Hey, Scope Manager (of the global scope), before we begin, can you look up the identifier <code>getStudentName</code> so I can assign this function to it?</p> <p>(Global) Scope Manager: Yep, here's the variable.</p> <p>Engine: Hey, Scope Manager, I found a target reference for <code>students</code>, ever heard of it?</p> <p>(Global) Scope Manager: Yes, it was formally declared for this scope, so here it is.</p> <p>Engine: Thanks, I'm initializing <code>students</code> to <code>undefined</code>, so it's ready to use.</p> <p>Hey, Scope Manager (of the global scope), I found a target reference for <code>nextStudent</code>, ever heard of it?</p> <p>(Global) Scope Manager: Yes, it was formally declared for this scope, so here it is.</p> <p>Engine: Thanks, I'm initializing <code>nextStudent</code> to <code>undefined</code>, so it's ready to use.</p> <p>Hey, Scope Manager (of the global scope), I found a source reference for <code>getStudentName</code>, ever heard of it?</p> <p>(Global) Scope Manager: Yes, it was formally declared for this scope. Here it is.</p> <p>Engine: Great, the value in <code>getStudentName</code> is a function, so I'm going to execute it.</p> <p>Engine: Hey, Scope Manager, now we need to instantiate the function's scope.</p> <p>...</p> <p>This conversation is another question-and-answer exchange, where Engine first asks the current Scope Manager to look up the hoisted <code>getStudentName</code> identifier, so as to associate the function with it. Engine then proceeds to ask Scope Manager about the target reference for <code>students</code>, and so on.</p> <p>To review and summarize how a statement like <code>var students = [ .. ]</code> is processed, in two distinct steps:</p> <ol> <li> <p>Compiler sets up the declaration of the scope variable (since it wasn't previously declared in the current scope).</p> </li> <li> <p>While Engine is executing, to process the assignment part of the statement, Engine asks Scope Manager to look up the variable, initializes it to <code>undefined</code> so it's ready to use, and then assigns the array value to it.</p> </li> </ol>"},{"location":"scope-closures/ch2/#nested-scope","title":"Nested Scope","text":"<p>When it comes time to execute the <code>getStudentName()</code> function, Engine asks for a Scope Manager instance for that function's scope, and it will then proceed to look up the parameter (<code>studentID</code>) to assign the <code>73</code> argument value to, and so on.</p> <p>The function scope for <code>getStudentName(..)</code> is nested inside the global scope. The block scope of the <code>for</code>-loop is similarly nested inside that function scope. Scopes can be lexically nested to any arbitrary depth as the program defines.</p> <p>Each scope gets its own Scope Manager instance each time that scope is executed (one or more times). Each scope automatically has all its identifiers registered at the start of the scope being executed (this is called \"variable hoisting\"; see Chapter 5).</p> <p>At the beginning of a scope, if any identifier came from a <code>function</code> declaration, that variable is automatically initialized to its associated function reference. And if any identifier came from a <code>var</code> declaration (as opposed to <code>let</code>/<code>const</code>), that variable is automatically initialized to <code>undefined</code> so that it can be used; otherwise, the variable remains uninitialized (aka, in its \"TDZ,\" see Chapter 5) and cannot be used until its full declaration-and-initialization are executed.</p> <p>In the <code>for (let student of students) {</code> statement, <code>students</code> is a source reference that must be looked up. But how will that lookup be handled, since the scope of the function will not find such an identifier?</p> <p>To explain, let's imagine that bit of conversation playing out like this:</p> <p>Engine: Hey, Scope Manager (for the function), I have a source reference for <code>students</code>, ever heard of it?</p> <p>(Function) Scope Manager: Nope, never heard of it. Try the next outer scope.</p> <p>Engine: Hey, Scope Manager (for the global scope), I have a source reference for <code>students</code>, ever heard of it?</p> <p>(Global) Scope Manager: Yep, it was formally declared, here it is.</p> <p>...</p> <p>One of the key aspects of LEXICAL scope is that any time an identifier reference cannot be found in the current scope, the next outer scope in the nesting is consulted; that process is repeated until an answer is found or there are no more scopes to consult.</p>"},{"location":"scope-closures/ch2/#lookup-failures","title":"Lookup Failures","text":"<p>When Engine exhausts all lexically available scopes (moving outward) and still cannot resolve the lookup of an identifier, an error condition then exists. However, depending on the mode of the program (strict-mode or not) and the role of the variable (i.e., target vs. source; see Chapter 1), this error condition will be handled differently.</p>"},{"location":"scope-closures/ch2/#undefined-mess","title":"Undefined Mess","text":"<p>If the variable is a source, an unresolved identifier lookup is considered an undeclared (unknown, missing) variable, which always results in a <code>ReferenceError</code> being thrown. Also, if the variable is a target, and the code at that moment is running in strict-mode, the variable is considered undeclared and similarly throws a <code>ReferenceError</code>.</p> <p>The error message for an undeclared variable condition, in most JS environments, will look like, \"Reference Error: XYZ is not defined.\" The phrase \"not defined\" seems almost identical to the word \"undefined,\" as far as the English language goes. But these two are very different in JS, and this error message unfortunately creates a persistent confusion.</p> <p>\"Not defined\" really means \"not declared\"\u2014or, rather, \"undeclared,\" as in a variable that has no matching formal declaration in any lexically available scope. By contrast, \"undefined\" really means a variable was found (declared), but the variable otherwise has no other value in it at the moment, so it defaults to the <code>undefined</code> value.</p> <p>To perpetuate the confusion even further, JS's <code>typeof</code> operator returns the string <code>\"undefined\"</code> for variable references in either state:</p> <pre><code>var studentName;\ntypeof studentName;     // \"undefined\"\ntypeof doesntExist;     // \"undefined\"\n</code></pre> <p>These two variable references are in very different conditions, but JS sure does muddy the waters. The terminology mess is confusing and terribly unfortunate. Unfortunately, JS developers just have to pay close attention to not mix up which kind of \"undefined\" they're dealing with!</p>"},{"location":"scope-closures/ch2/#global-what","title":"Global... What!?","text":"<p>If the variable is a target and strict-mode is not in effect, a confusing and surprising legacy behavior kicks in. The troublesome outcome is that the global scope's Scope Manager will just create an accidental global variable to fulfill that target assignment!</p> <p>Consider:</p> <pre><code>function getStudentName() {\n// assignment to an undeclared variable :(\nnextStudent = \"Suzy\";\n}\ngetStudentName();\nconsole.log(nextStudent);\n// \"Suzy\" -- oops, an accidental-global variable!\n</code></pre> <p>Here's how that conversation will proceed:</p> <p>Engine: Hey, Scope Manager (for the function), I have a target reference for <code>nextStudent</code>, ever heard of it?</p> <p>(Function) Scope Manager: Nope, never heard of it. Try the next outer scope.</p> <p>Engine: Hey, Scope Manager (for the global scope), I have a target reference for <code>nextStudent</code>, ever heard of it?</p> <p>(Global) Scope Manager: Nope, but since we're in non-strict-mode, I helped you out and just created a global variable for you, here it is!</p> <p>Yuck.</p> <p>This sort of accident (almost certain to lead to bugs eventually) is a great example of the beneficial protections offered by strict-mode, and why it's such a bad idea not to be using strict-mode. In strict-mode, the Global Scope Manager would instead have responded:</p> <p>(Global) Scope Manager: Nope, never heard of it. Sorry, I've got to throw a <code>ReferenceError</code>.</p> <p>Assigning to a never-declared variable is an error, so it's right that we would receive a <code>ReferenceError</code> here.</p> <p>Never rely on accidental global variables. Always use strict-mode, and always formally declare your variables. You'll then get a helpful <code>ReferenceError</code> if you ever mistakenly try to assign to a not-declared variable.</p>"},{"location":"scope-closures/ch2/#building-on-metaphors","title":"Building On Metaphors","text":"<p>To visualize nested scope resolution, I prefer yet another metaphor, an office building, as in Figure 3:</p> Fig. 3: Scope \"Building\" <p>The building represents our program's nested scope collection. The first floor of the building represents the currently executing scope. The top level of the building is the global scope.</p> <p>You resolve a target or source variable reference by first looking on the current floor, and if you don't find it, taking the elevator to the next floor (i.e., an outer scope), looking there, then the next, and so on. Once you get to the top floor (the global scope), you either find what you're looking for, or you don't. But you have to stop regardless.</p>"},{"location":"scope-closures/ch2/#continue-the-conversation","title":"Continue the Conversation","text":"<p>By this point, you should be developing richer mental models for what scope is and how the JS engine determines and uses it from your code.</p> <p>Before continuing, go find some code in one of your projects and run through these conversations. Seriously, actually speak out loud. Find a friend and practice each role with them. If either of you find yourself confused or tripped up, spend more time reviewing this material.</p> <p>As we move (up) to the next (outer) chapter, we'll explore how the LEXICAL scopes of a program are connected in a chain.</p>"},{"location":"scope-closures/ch3/","title":"Chapter 3: The Scope Chain","text":"<p>Chapters 1 and 2 laid down a concrete definition of LEXICAL scope (and its parts) and illustrated helpful metaphors for its conceptual foundation. Before proceeding with this chapter, find someone else to explain (written or aloud), in your own words, what LEXICAL scope is and why it's useful to understand.</p> <p>That seems like a step you might skip, but I've found it really does help to take the time to reformulate these ideas as explanations to others. That helps our brains digest what we're learning!</p> <p>Now it's time to dig into the nuts and bolts, so expect that things will get a lot more detailed from here forward. Stick with it, though, because these discussions really hammer home just how much we all don't know about scope, yet. Make sure to take your time with the text and all the code snippets provided.</p> <p>To refresh the context of our running example, let's recall the color-coded illustration of the nested scope bubbles, from Chapter 2, Figure 2:</p> Fig. 2 (Ch. 2): Colored Scope Bubbles <p>The connections between scopes that are nested within other scopes is called the scope chain, which determines the path along which variables can be accessed. The chain is directed, meaning the lookup moves upward/outward only.</p>"},{"location":"scope-closures/ch3/#lookup-is-mostly-conceptual","title":"\"Lookup\" Is (Mostly) Conceptual","text":"<p>In Figure 2, notice the color of the <code>students</code> variable reference in the <code>for</code>-loop. How exactly did we determine that it's a RED(1) marble?</p> <p>In Chapter 2, we described the runtime access of a variable as a \"lookup,\" where the Engine has to start by asking the current scope's Scope Manager if it knows about an identifier/variable, and proceeding upward/outward back through the chain of nested scopes (toward the global scope) until found, if ever. The lookup stops as soon as the first matching named declaration in a scope bucket is found.</p> <p>The lookup process thus determined that <code>students</code> is a RED(1) marble, because we had not yet found a matching variable name as we traversed the scope chain, until we arrived at the final RED(1) global scope.</p> <p>Similarly, <code>studentID</code> in the <code>if</code>-statement is determined to be a BLUE(2) marble.</p> <p>This suggestion of a runtime lookup process works well for conceptual understanding, but it's not actually how things usually work in practice.</p> <p>The color of a marble's bucket (aka, meta information of what scope a variable originates from) is usually determined during the initial compilation processing. Because LEXICAL scope is pretty much finalized at that point, a marble's color will not change based on anything that can happen later during runtime.</p> <p>Since the marble's color is known from compilation, and it's immutable, this information would likely be stored with (or at least accessible from) each variable's entry in the AST; that information is then used explicitly by the executable instructions that constitute the program's runtime.</p> <p>In other words, Engine (from Chapter 2) doesn't need to lookup through a bunch of scopes to figure out which scope bucket a variable comes from. That information is already known! Avoiding the need for a runtime lookup is a key optimization benefit of LEXICAL scope. The runtime operates more performantly without spending time on all these lookups.</p> <p>But I said \"...usually determined...\" just a moment ago, with respect to figuring out a marble's color during compilation. So in what case would it ever not be known during compilation?</p> <p>Consider a reference to a variable that isn't declared in any lexically available scopes in the current file\u2014see Get Started, Chapter 1, which asserts that each file is its own separate program from the perspective of JS compilation. If no declaration is found, that's not necessarily an error. Another file (program) in the runtime may indeed declare that variable in the shared global scope.</p> <p>So the ultimate determination of whether the variable was ever appropriately declared in some accessible bucket may need to be deferred to the runtime.</p> <p>Any reference to a variable that's initially undeclared is left as an uncolored marble during that file's compilation; this color cannot be determined until other relevant file(s) have been compiled and the application runtime commences. That deferred lookup will eventually resolve the color to whichever scope the variable is found in (likely the global scope).</p> <p>However, this lookup would only be needed once per variable at most, since nothing else during runtime could later change that marble's color.</p> <p>The \"Lookup Failures\" section in Chapter 2 covers what happens if a marble is ultimately still uncolored at the moment its reference is runtime executed.</p>"},{"location":"scope-closures/ch3/#shadowing","title":"Shadowing","text":"<p>\"Shadowing\" might sound mysterious and a little bit sketchy. But don't worry, it's completely legit!</p> <p>Our running example for these chapters uses different variable names across the scope boundaries. Since they all have unique names, in a way it wouldn't matter if all of them were just stored in one bucket (like RED(1)).</p> <p>Where having different LEXICAL scope buckets starts to matter more is when you have two or more variables, each in different scopes, with the same LEXICAL names. A single scope cannot have two or more variables with the same name; such multiple references would be assumed as just one variable.</p> <p>So if you need to maintain two or more variables of the same name, you must use separate (often nested) scopes. And in that case, it's very relevant how the different scope buckets are laid out.</p> <p>Consider:</p> <pre><code>var studentName = \"Suzy\";\nfunction printStudent(studentName) {\nstudentName = studentName.toUpperCase();\nconsole.log(studentName);\n}\nprintStudent(\"Frank\");\n// FRANK\nprintStudent(studentName);\n// SUZY\nconsole.log(studentName);\n// Suzy\n</code></pre> TIP: Before you move on, take some time to analyze this code using the various techniques/metaphors we've covered in the book. In particular, make sure to identify the marble/bubble colors in this snippet. It's good practice! <p>The <code>studentName</code> variable on line 1 (the <code>var studentName = ..</code> statement) creates a RED(1) marble. The same named variable is declared as a BLUE(2) marble on line 3, the parameter in the <code>printStudent(..)</code> function definition.</p> <p>What color marble will <code>studentName</code> be in the <code>studentName = studentName.toUpperCase()</code> assignment statement and the <code>console.log(studentName)</code> statement? All three <code>studentName</code> references will be BLUE(2).</p> <p>With the conceptual notion of the \"lookup,\" we asserted that it starts with the current scope and works its way outward/upward, stopping as soon as a matching variable is found. The BLUE(2) <code>studentName</code> is found right away. The RED(1) <code>studentName</code> is never even considered.</p> <p>This is a key aspect of LEXICAL scope behavior, called shadowing. The BLUE(2) <code>studentName</code> variable (parameter) shadows the RED(1) <code>studentName</code>. So, the parameter is shadowing the (shadowed) global variable. Repeat that sentence to yourself a few times to make sure you have the terminology straight!</p> <p>That's why the re-assignment of <code>studentName</code> affects only the inner (parameter) variable: the BLUE(2) <code>studentName</code>, not the global RED(1) <code>studentName</code>.</p> <p>When you choose to shadow a variable from an outer scope, one direct impact is that from that scope inward/downward (through any nested scopes) it's now impossible for any marble to be colored as the shadowed variable\u2014(RED(1), in this case). In other words, any <code>studentName</code> identifier reference will correspond to that parameter variable, never the global <code>studentName</code> variable. It's lexically impossible to reference the global <code>studentName</code> anywhere inside of the <code>printStudent(..)</code> function (or from any nested scopes).</p>"},{"location":"scope-closures/ch3/#global-unshadowing-trick","title":"Global Unshadowing Trick","text":"<p>Please beware: leveraging the technique I'm about to describe is not very good practice, as it's limited in utility, confusing for readers of your code, and likely to invite bugs to your program. I'm covering it only because you may run across this behavior in existing programs, and understanding what's happening is critical to not getting tripped up.</p> <p>It is possible to access a global variable from a scope where that variable has been shadowed, but not through a typical LEXICAL identifier reference.</p> <p>In the global scope (RED(1)), <code>var</code> declarations and <code>function</code> declarations also expose themselves as properties (of the same name as the identifier) on the global object\u2014essentially an object representation of the global scope. If you've written JS for a browser environment, you probably recognize the global object as <code>window</code>. That's not entirely accurate, but it's good enough for our discussion. In the next chapter, we'll explore the global scope/object topic more.</p> <p>Consider this program, specifically executed as a standalone .js file in a browser environment:</p> <pre><code>var studentName = \"Suzy\";\nfunction printStudent(studentName) {\nconsole.log(studentName);\nconsole.log(window.studentName);\n}\nprintStudent(\"Frank\");\n// \"Frank\"\n// \"Suzy\"\n</code></pre> <p>Notice the <code>window.studentName</code> reference? This expression is accessing the global variable <code>studentName</code> as a property on <code>window</code> (which we're pretending for now is synonymous with the global object). That's the only way to access a shadowed variable from inside a scope where the shadowing variable is present.</p> <p>The <code>window.studentName</code> is a mirror of the global <code>studentName</code> variable, not a separate snapshot copy. Changes to one are still seen from the other, in either direction. You can think of <code>window.studentName</code> as a getter/setter that accesses the actual <code>studentName</code> variable. As a matter of fact, you can even add a variable to the global scope by creating/setting a property on the global object.</p> WARNING: Remember: just because you can doesn't mean you should. Don't shadow a global variable that you need to access, and conversely, avoid using this trick to access a global variable that you've shadowed. And definitely don't confuse readers of your code by creating global variables as <code>window</code> properties instead of with formal declarations! <p>This little \"trick\" only works for accessing a global scope variable (not a shadowed variable from a nested scope), and even then, only one that was declared with <code>var</code> or <code>function</code>.</p> <p>Other forms of global scope declarations do not create mirrored global object properties:</p> <pre><code>var one = 1;\nlet notOne = 2;\nconst notTwo = 3;\nclass notThree {}\nconsole.log(window.one);       // 1\nconsole.log(window.notOne);    // undefined\nconsole.log(window.notTwo);    // undefined\nconsole.log(window.notThree);  // undefined\n</code></pre> <p>Variables (no matter how they're declared!) that exist in any other scope than the global scope are completely inaccessible from a scope where they've been shadowed:</p> <pre><code>var special = 42;\nfunction lookingFor(special) {\n// The identifier `special` (parameter) in this\n// scope is shadowed inside keepLooking(), and\n// is thus inaccessible from that scope.\nfunction keepLooking() {\nvar special = 3.141592;\nconsole.log(special);\nconsole.log(window.special);\n}\nkeepLooking();\n}\nlookingFor(112358132134);\n// 3.141592\n// 42\n</code></pre> <p>The global RED(1) <code>special</code> is shadowed by the BLUE(2) <code>special</code> (parameter), and the BLUE(2) <code>special</code> is itself shadowed by the GREEN(3) <code>special</code> inside <code>keepLooking()</code>. We can still access the RED(1) <code>special</code> using the indirect reference <code>window.special</code>. But there's no way for <code>keepLooking()</code> to access the BLUE(2) <code>special</code> that holds the number <code>112358132134</code>.</p>"},{"location":"scope-closures/ch3/#copying-is-not-accessing","title":"Copying Is Not Accessing","text":"<p>I've been asked the following \"But what about...?\" question dozens of times. Consider:</p> <pre><code>var special = 42;\nfunction lookingFor(special) {\nvar another = {\nspecial: special\n};\nfunction keepLooking() {\nvar special = 3.141592;\nconsole.log(special);\nconsole.log(another.special);  // Ooo, tricky!\nconsole.log(window.special);\n}\nkeepLooking();\n}\nlookingFor(112358132134);\n// 3.141592\n// 112358132134\n// 42\n</code></pre> <p>Oh! So does this <code>another</code> object technique disprove my claim that the <code>special</code> parameter is \"completely inaccessible\" from inside <code>keepLooking()</code>? No, the claim is still correct.</p> <p><code>special: special</code> is copying the value of the <code>special</code> parameter variable into another container (a property of the same name). Of course, if you put a value in another container, shadowing no longer applies (unless <code>another</code> was shadowed, too!). But that doesn't mean we're accessing the parameter <code>special</code>; it means we're accessing the copy of the value it had at that moment, by way of another container (object property). We cannot reassign the BLUE(2) <code>special</code> parameter to a different value from inside <code>keepLooking()</code>.</p> <p>Another \"But...!?\" you may be about to raise: what if I'd used objects or arrays as the values instead of the numbers (<code>112358132134</code>, etc.)? Would us having references to objects instead of copies of primitive values \"fix\" the inaccessibility?</p> <p>No. Mutating the contents of the object value via a reference copy is not the same thing as lexically accessing the variable itself. We still can't reassign the BLUE(2) <code>special</code> parameter.</p>"},{"location":"scope-closures/ch3/#illegal-shadowing","title":"Illegal Shadowing","text":"<p>Not all combinations of declaration shadowing are allowed. <code>let</code> can shadow <code>var</code>, but <code>var</code> cannot shadow <code>let</code>:</p> <pre><code>function something() {\nvar special = \"JavaScript\";\n{\nlet special = 42;   // totally fine shadowing\n// ..\n}\n}\nfunction another() {\n// ..\n{\nlet special = \"JavaScript\";\n{\nvar special = \"JavaScript\";\n// ^^^ Syntax Error\n// ..\n}\n}\n}\n</code></pre> <p>Notice in the <code>another()</code> function, the inner <code>var special</code> declaration is attempting to declare a function-wide <code>special</code>, which in and of itself is fine (as shown by the <code>something()</code> function).</p> <p>The syntax error description in this case indicates that <code>special</code> has already been defined, but that error message is a little misleading\u2014again, no such error happens in <code>something()</code>, as shadowing is generally allowed just fine.</p> <p>The real reason it's raised as a <code>SyntaxError</code> is because the <code>var</code> is basically trying to \"cross the boundary\" of (or hop over) the <code>let</code> declaration of the same name, which is not allowed.</p> <p>That boundary-crossing prohibition effectively stops at each function boundary, so this variant raises no exception:</p> <pre><code>function another() {\n// ..\n{\nlet special = \"JavaScript\";\najax(\"https://some.url\",function callback(){\n// totally fine shadowing\nvar special = \"JavaScript\";\n// ..\n});\n}\n}\n</code></pre> <p>Summary: <code>let</code> (in an inner scope) can always shadow an outer scope's <code>var</code>. <code>var</code> (in an inner scope) can only shadow an outer scope's <code>let</code> if there is a function boundary in between.</p>"},{"location":"scope-closures/ch3/#function-name-scope","title":"Function Name Scope","text":"<p>As you've seen by now, a <code>function</code> declaration looks like this:</p> <pre><code>function askQuestion() {\n// ..\n}\n</code></pre> <p>And as discussed in Chapters 1 and 2, such a <code>function</code> declaration will create an identifier in the enclosing scope (in this case, the global scope) named <code>askQuestion</code>.</p> <p>What about this program?</p> <pre><code>var askQuestion = function(){\n// ..\n};\n</code></pre> <p>The same is true for the variable <code>askQuestion</code> being created. But since it's a <code>function</code> expression\u2014a function definition used as value instead of a standalone declaration\u2014the function itself will not \"hoist\" (see Chapter 5).</p> <p>One major difference between <code>function</code> declarations and <code>function</code> expressions is what happens to the name identifier of the function. Consider a named <code>function</code> expression:</p> <pre><code>var askQuestion = function ofTheTeacher(){\n// ..\n};\n</code></pre> <p>We know <code>askQuestion</code> ends up in the outer scope. But what about the <code>ofTheTeacher</code> identifier? For formal <code>function</code> declarations, the name identifier ends up in the outer/enclosing scope, so it may be reasonable to assume that's the case here. But <code>ofTheTeacher</code> is declared as an identifier inside the function itself:</p> <pre><code>var askQuestion = function ofTheTeacher() {\nconsole.log(ofTheTeacher);\n};\naskQuestion();\n// function ofTheTeacher()...\nconsole.log(ofTheTeacher);\n// ReferenceError: ofTheTeacher is not defined\n</code></pre> NOTE: Actually, <code>ofTheTeacher</code> is not exactly in the scope of the function. Appendix A, \"Implied Scopes\" will explain further. <p>Not only is <code>ofTheTeacher</code> declared inside the function rather than outside, but it's also defined as read-only:</p> <pre><code>var askQuestion = function ofTheTeacher() {\n\"use strict\";\nofTheTeacher = 42;   // TypeError\n//..\n};\naskQuestion();\n// TypeError\n</code></pre> <p>Because we used strict-mode, the assignment failure is reported as a <code>TypeError</code>; in non-strict-mode, such an assignment fails silently with no exception.</p> <p>What about when a <code>function</code> expression has no name identifier?</p> <pre><code>var askQuestion = function(){\n// ..\n};\n</code></pre> <p>A <code>function</code> expression with a name identifier is referred to as a \"named function expression,\" but one without a name identifier is referred to as an \"anonymous function expression.\" Anonymous function expressions clearly have no name identifier that affects either scope.</p> NOTE: We'll discuss named vs. anonymous <code>function</code> expressions in much more detail, including what factors affect the decision to use one or the other, in Appendix A."},{"location":"scope-closures/ch3/#arrow-functions","title":"Arrow Functions","text":"<p>ES6 added an additional <code>function</code> expression form to the language, called \"arrow functions\":</p> <pre><code>var askQuestion = () =&gt; {\n// ..\n};\n</code></pre> <p>The <code>=&gt;</code> arrow function doesn't require the word <code>function</code> to define it. Also, the <code>( .. )</code> around the parameter list is optional in some simple cases. Likewise, the <code>{ .. }</code> around the function body is optional in some cases. And when the <code>{ .. }</code> are omitted, a return value is sent out without using a <code>return</code> keyword.</p> NOTE: The attractiveness of <code>=&gt;</code> arrow functions is often sold as \"shorter syntax,\" and that's claimed to equate to objectively more readable code. This claim is dubious at best, and I believe outright misguided. We'll dig into the \"readability\" of various function forms in Appendix A. <p>Arrow functions are lexically anonymous, meaning they have no directly related identifier that references the function. The assignment to <code>askQuestion</code> creates an inferred name of \"askQuestion\", but that's not the same thing as being non-anonymous:</p> <pre><code>var askQuestion = () =&gt; {\n// ..\n};\naskQuestion.name;   // askQuestion\n</code></pre> <p>Arrow functions achieve their syntactic brevity at the expense of having to mentally juggle a bunch of variations for different forms/conditions. Just a few, for example:</p> <pre><code>() =&gt; 42;\nid =&gt; id.toUpperCase();\n(id,name) =&gt; ({ id, name });\n(...args) =&gt; {\nreturn args[args.length - 1];\n};\n</code></pre> <p>The real reason I bring up arrow functions is because of the common but incorrect claim that arrow functions somehow behave differently with respect to LEXICAL scope from standard <code>function</code> functions.</p> <p>This is incorrect.</p> <p>Other than being anonymous (and having no declarative form), <code>=&gt;</code> arrow functions have the same LEXICAL scope rules as <code>function</code> functions do. An arrow function, with or without <code>{ .. }</code> around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a <code>function</code> scope.</p>"},{"location":"scope-closures/ch3/#backing-out","title":"Backing Out","text":"<p>When a function (declaration or expression) is defined, a new scope is created. The positioning of scopes nested inside one another creates a natural scope hierarchy throughout the program, called the scope chain. The scope chain controls variable access, directionally oriented upward and outward.</p> <p>Each new scope offers a clean slate, a space to hold its own set of variables. When a variable name is repeated at different levels of the scope chain, shadowing occurs, which prevents access to the outer variable from that point inward.</p> <p>As we step back out from these finer details, the next chapter shifts focus to the primary scope all JS programs include: the global scope.</p>"},{"location":"scope-closures/ch4/","title":"Chapter 4: Around the Global Scope","text":"<p>Chapter 3 mentioned the \"global scope\" several times, but you may still be wondering why a program's outermost scope is all that important in modern JS. The vast majority of work is now done inside of functions and modules rather than globally.</p> <p>Is it good enough to just assert, \"Avoid using the global scope,\" and be done with it?</p> <p>The global scope of a JS program is a rich topic, with much more utility and nuance than you would likely assume. This chapter first explores how the global scope is (still) useful and relevant to writing JS programs today, then looks at differences in where and how to access the global scope in different JS environments.</p> <p>Fully understanding the global scope is critical in your mastery of using LEXICAL scope to structure your programs.</p>"},{"location":"scope-closures/ch4/#why-global-scope","title":"Why Global Scope?","text":"<p>It's likely no surprise to readers that most applications are composed of multiple (sometimes many!) individual JS files. So how exactly do all those separate files get stitched together in a single runtime context by the JS engine?</p> <p>With respect to browser-executed applications, there are three main ways.</p> <p>First, if you're directly using ES modules (not transpiling them into some other module-bundle format), these files are loaded individually by the JS environment. Each module then <code>import</code>s references to whichever other modules it needs to access. The separate module files cooperate with each other exclusively through these shared imports, without needing any shared outer scope.</p> <p>Second, if you're using a bundler in your build process, all the files are typically concatenated together before delivery to the browser and JS engine, which then only processes one big file. Even with all the pieces of the application co-located in a single file, some mechanism is necessary for each piece to register a name to be referred to by other pieces, as well as some facility for that access to occur.</p> <p>In some build setups, the entire contents of the file are wrapped in a single enclosing scope, such as a wrapper function, universal module (UMD\u2014see Appendix A), etc. Each piece can register itself for access from other pieces by way of local variables in that shared scope. For example:</p> <pre><code>(function wrappingOuterScope(){\nvar moduleOne = (function one(){\n// ..\n})();\nvar moduleTwo = (function two(){\n// ..\nfunction callModuleOne() {\nmoduleOne.someMethod();\n}\n// ..\n})();\n})();\n</code></pre> <p>As shown, the <code>moduleOne</code> and <code>moduleTwo</code> local variables inside the <code>wrappingOuterScope()</code> function scope are declared so that these modules can access each other for their cooperation.</p> <p>While the scope of <code>wrappingOuterScope()</code> is a function and not the full environment global scope, it does act as a sort of \"application-wide scope,\" a bucket where all the top-level identifiers can be stored, though not in the real global scope. It's kind of like a stand-in for the global scope in that respect.</p> <p>And finally, the third way: whether a bundler tool is used for an application, or whether the (non-ES module) files are simply loaded in the browser individually (via <code>&lt;script&gt;</code> tags or other dynamic JS resource loading), if there is no single surrounding scope encompassing all these pieces, the global scope is the only way for them to cooperate with each other:</p> <p>A bundled file of this sort often looks something like this:</p> <pre><code>var moduleOne = (function one(){\n// ..\n})();\nvar moduleTwo = (function two(){\n// ..\nfunction callModuleOne() {\nmoduleOne.someMethod();\n}\n// ..\n})();\n</code></pre> <p>Here, since there is no surrounding function scope, these <code>moduleOne</code> and <code>moduleTwo</code> declarations are simply dropped into the global scope. This is effectively the same as if the files hadn't been concatenated, but loaded separately:</p> <p>module1.js:</p> <pre><code>var moduleOne = (function one(){\n// ..\n})();\n</code></pre> <p>module2.js:</p> <pre><code>var moduleTwo = (function two(){\n// ..\nfunction callModuleOne() {\nmoduleOne.someMethod();\n}\n// ..\n})();\n</code></pre> <p>If these files are loaded separately as normal standalone .js files in a browser environment, each top-level variable declaration will end up as a global variable, since the global scope is the only shared resource between these two separate files\u2014they're independent programs, from the perspective of the JS engine.</p> <p>In addition to (potentially) accounting for where an application's code resides during runtime, and how each piece is able to access the other pieces to cooperate, the global scope is also where:</p> <ul> <li> <p>JS exposes its built-ins:</p> <ul> <li>primitives: <code>undefined</code>, <code>null</code>, <code>Infinity</code>, <code>NaN</code></li> <li>natives: <code>Date()</code>, <code>Object()</code>, <code>String()</code>, etc.</li> <li>global functions: <code>eval()</code>, <code>parseInt()</code>, etc.</li> <li>namespaces: <code>Math</code>, <code>Atomics</code>, <code>JSON</code></li> <li>friends of JS: <code>Intl</code>, <code>WebAssembly</code></li> </ul> </li> <li> <p>The environment hosting the JS engine exposes its own built-ins:</p> <ul> <li><code>console</code> (and its methods)</li> <li>the DOM (<code>window</code>, <code>document</code>, etc)</li> <li>timers (<code>setTimeout(..)</code>, etc)</li> <li>web platform APIs: <code>navigator</code>, <code>history</code>, geolocation, WebRTC, etc.</li> </ul> </li> </ul> <p>These are just some of the many globals your programs will interact with.</p> NOTE: Node also exposes several elements \"globally,\" but they're technically not in the <code>global</code> scope: <code>require()</code>, <code>__dirname</code>, <code>module</code>, <code>URL</code>, and so on. <p>Most developers agree that the global scope shouldn't just be a dumping ground for every variable in your application. That's a mess of bugs just waiting to happen. But it's also undeniable that the global scope is an important glue for practically every JS application.</p>"},{"location":"scope-closures/ch4/#where-exactly-is-this-global-scope","title":"Where Exactly is this Global Scope?","text":"<p>It might seem obvious that the global scope is located in the outermost portion of a file; that is, not inside any function or other block. But it's not quite as simple as that.</p> <p>Different JS environments handle the scopes of your programs, especially the global scope, differently. It's quite common for JS developers to harbor misconceptions without even realizing it.</p>"},{"location":"scope-closures/ch4/#browser-window","title":"Browser \"Window\"","text":"<p>With respect to treatment of the global scope, the most pure environment JS can be run in is as a standalone .js file loaded in a web page environment in a browser. I don't mean \"pure\" as in nothing automatically added\u2014lots may be added!\u2014but rather in terms of minimal intrusion on the code or interference with its expected global scope behavior.</p> <p>Consider this .js file:</p> <pre><code>var studentName = \"Kyle\";\nfunction hello() {\nconsole.log(`Hello, ${ studentName }!`);\n}\nhello();\n// Hello, Kyle!\n</code></pre> <p>This code may be loaded in a web page environment using an inline <code>&lt;script&gt;</code> tag, a <code>&lt;script src=..&gt;</code> script tag in the markup, or even a dynamically created <code>&lt;script&gt;</code> DOM element. In all three cases, the <code>studentName</code> and <code>hello</code> identifiers are declared in the global scope.</p> <p>That means if you access the global object (commonly, <code>window</code> in the browser), you'll find properties of those same names there:</p> <pre><code>var studentName = \"Kyle\";\nfunction hello() {\nconsole.log(`Hello, ${ window.studentName }!`);\n}\nwindow.hello();\n// Hello, Kyle!\n</code></pre> <p>That's the default behavior one would expect from a reading of the JS specification: the outer scope is the global scope and <code>studentName</code> is legitimately created as global variable.</p> <p>That's what I mean by pure. But unfortunately, that won't always be true of all JS environments you encounter, and that's often surprising to JS developers.</p>"},{"location":"scope-closures/ch4/#globals-shadowing-globals","title":"Globals Shadowing Globals","text":"<p>Recall the discussion of shadowing (and global unshadowing) from Chapter 3, where one variable declaration can override and prevent access to a declaration of the same name from an outer scope.</p> <p>An unusual consequence of the difference between a global variable and a global property of the same name is that, within just the global scope itself, a global object property can be shadowed by a global variable:</p> <pre><code>window.something = 42;\nlet something = \"Kyle\";\nconsole.log(something);\n// Kyle\nconsole.log(window.something);\n// 42\n</code></pre> <p>The <code>let</code> declaration adds a <code>something</code> global variable but not a global object property (see Chapter 3). The effect then is that the <code>something</code> LEXICAL identifier shadows the <code>something</code> global object property.</p> <p>It's almost certainly a bad idea to create a divergence between the global object and the global scope. Readers of your code will almost certainly be tripped up.</p> <p>A simple way to avoid this gotcha with global declarations: always use <code>var</code> for globals. Reserve <code>let</code> and <code>const</code> for block scopes (see \"Scoping with Blocks\" in Chapter 6).</p>"},{"location":"scope-closures/ch4/#dom-globals","title":"DOM Globals","text":"<p>I asserted that a browser-hosted JS environment has the most pure global scope behavior we'll see. However, it's not entirely pure.</p> <p>One surprising behavior in the global scope you may encounter with browser-based JS applications: a DOM element with an <code>id</code> attribute automatically creates a global variable that references it.</p> <p>Consider this markup:</p> <pre><code>&lt;ul id=\"my-todo-list\"&gt;\n   &lt;li id=\"first\"&gt;Write a book&lt;/li&gt;\n   ..\n&lt;/ul&gt;\n</code></pre> <p>And the JS for that page could include:</p> <pre><code>first;\n// &lt;li id=\"first\"&gt;..&lt;/li&gt;\nwindow[\"my-todo-list\"];\n// &lt;ul id=\"my-todo-list\"&gt;..&lt;/ul&gt;\n</code></pre> <p>If the <code>id</code> value is a valid LEXICAL name (like <code>first</code>), the LEXICAL variable is created. If not, the only way to access that global is through the global object (<code>window[..]</code>).</p> <p>The auto-registration of all <code>id</code>-bearing DOM elements as global variables is an old legacy browser behavior that nevertheless must remain because so many old sites still rely on it. My advice is never to use these global variables, even though they will always be silently created.</p>"},{"location":"scope-closures/ch4/#whats-in-a-window-name","title":"What's in a (Window) Name?","text":"<p>Another global scope oddity in browser-based JS:</p> <pre><code>var name = 42;\nconsole.log(name, typeof name);\n// \"42\" string\n</code></pre> <p><code>window.name</code> is a pre-defined \"global\" in a browser context; it's a property on the global object, so it seems like a normal global variable (yet it's anything but \"normal\").</p> <p>We used <code>var</code> for our declaration, which does not shadow the pre-defined <code>name</code> global property. That means, effectively, the <code>var</code> declaration is ignored, since there's already a global scope object property of that name. As we discussed earlier, had we used <code>let name</code>, we would have shadowed <code>window.name</code> with a separate global <code>name</code> variable.</p> <p>But the truly surprising behavior is that even though we assigned the number <code>42</code> to <code>name</code> (and thus <code>window.name</code>), when we then retrieve its value, it's a string <code>\"42\"</code>! In this case, the weirdness is because <code>name</code> is actually a pre-defined getter/setter on the <code>window</code> object, which insists on its value being a string value. Yikes!</p> <p>With the exception of some rare corner cases like DOM element ID's and <code>window.name</code>, JS running as a standalone file in a browser page has some of the most pure global scope behavior we will encounter.</p>"},{"location":"scope-closures/ch4/#web-workers","title":"Web Workers","text":"<p>Web Workers are a web platform extension on top of browser-JS behavior, which allows a JS file to run in a completely separate thread (operating system wise) from the thread that's running the main JS program.</p> <p>Since these Web Worker programs run on a separate thread, they're restricted in their communications with the main application thread, to avoid/limit race conditions and other complications. Web Worker code does not have access to the DOM, for example. Some web APIs are, however, made available to the worker, such as <code>navigator</code>.</p> <p>Since a Web Worker is treated as a wholly separate program, it does not share the global scope with the main JS program. However, the browser's JS engine is still running the code, so we can expect similar purity of its global scope behavior. Since there is no DOM access, the <code>window</code> alias for the global scope doesn't exist.</p> <p>In a Web Worker, the global object reference is typically made using <code>self</code>:</p> <pre><code>var studentName = \"Kyle\";\nlet studentID = 42;\nfunction hello() {\nconsole.log(`Hello, ${ self.studentName }!`);\n}\nself.hello();\n// Hello, Kyle!\nself.studentID;\n// undefined\n</code></pre> <p>Just as with main JS programs, <code>var</code> and <code>function</code> declarations create mirrored properties on the global object (aka, <code>self</code>), where other declarations (<code>let</code>, etc) do not.</p> <p>So again, the global scope behavior we're seeing here is about as pure as it gets for running JS programs; perhaps it's even more pure since there's no DOM to muck things up!</p>"},{"location":"scope-closures/ch4/#developer-tools-consolerepl","title":"Developer Tools Console/REPL","text":"<p>Recall from Chapter 1 in Get Started that Developer Tools don't create a completely adherent JS environment. They do process JS code, but they also lean in favor of the UX interaction being most friendly to developers (aka, developer experience, or DX).</p> <p>In some cases, favoring DX when typing in short JS snippets, over the normal strict steps expected for processing a full JS program, produces observable differences in code behavior between programs and tools. For example, certain error conditions applicable to a JS program may be relaxed and not displayed when the code is entered into a developer tool.</p> <p>With respect to our discussions here about scope, such observable differences in behavior may include:</p> <ul> <li> <p>The behavior of the global scope</p> </li> <li> <p>Hoisting (see Chapter 5)</p> </li> <li> <p>Block-scoping declarators (<code>let</code> / <code>const</code>, see Chapter 6) when used in the outermost scope</p> </li> </ul> <p>Although it might seem, while using the console/REPL, that statements entered in the outermost scope are being processed in the real global scope, that's not quite accurate. Such tools typically emulate the global scope position to an extent; it's emulation, not strict adherence. These tool environments prioritize developer convenience, which means that at times (such as with our current discussions regarding scope), observed behavior may deviate from the JS specification.</p> <p>The take-away is that Developer Tools, while optimized to be convenient and useful for a variety of developer activities, are not suitable environments to determine or verify explicit and nuanced behaviors of an actual JS program context.</p>"},{"location":"scope-closures/ch4/#es-modules-esm","title":"ES Modules (ESM)","text":"<p>ES6 introduced first-class support for the module pattern (covered in Chapter 8). One of the most obvious impacts of using ESM is how it changes the behavior of the observably top-level scope in a file.</p> <p>Recall this code snippet from earlier (which we'll adjust to ESM format by using the <code>export</code> keyword):</p> <pre><code>var studentName = \"Kyle\";\nfunction hello() {\nconsole.log(`Hello, ${ studentName }!`);\n}\nhello();\n// Hello, Kyle!\nexport hello;\n</code></pre> <p>If that code is in a file that's loaded as an ES module, it will still run exactly the same. However, the observable effects, from the overall application perspective, will be different.</p> <p>Despite being declared at the top level of the (module) file, in the outermost obvious scope, <code>studentName</code> and <code>hello</code> are not global variables. Instead, they are module-wide, or if you prefer, \"module-global.\"</p> <p>However, in a module there's no implicit \"module-wide scope object\" for these top-level declarations to be added to as properties, as there is when declarations appear in the top-level of non-module JS files. This is not to say that global variables cannot exist or be accessed in such programs. It's just that global variables don't get created by declaring variables in the top-level scope of a module.</p> <p>The module's top-level scope is descended from the global scope, almost as if the entire contents of the module were wrapped in a function. Thus, all variables that exist in the global scope (whether they're on the global object or not!) are available as LEXICAL identifiers from inside the module's scope.</p> <p>ESM encourages a minimization of reliance on the global scope, where you import whatever modules you may need for the current module to operate. As such, you less often see usage of the global scope or its global object.</p> <p>However, as noted earlier, there are still plenty of JS and web globals that you will continue to access from the global scope, whether you realize it or not!</p>"},{"location":"scope-closures/ch4/#node","title":"Node","text":"<p>One aspect of Node that often catches JS developers off-guard is that Node treats every single .js file that it loads, including the main one you start the Node process with, as a module (ES module or CommonJS module, see Chapter 8). The practical effect is that the top level of your Node programs is never actually the global scope, the way it is when loading a non-module file in the browser.</p> <p>As of time of this writing, Node has recently added support for ES modules. But additionally, Node has from its beginning supported a module format referred to as \"CommonJS\", which looks like this:</p> <pre><code>var studentName = \"Kyle\";\nfunction hello() {\nconsole.log(`Hello, ${ studentName }!`);\n}\nhello();\n// Hello, Kyle!\nmodule.exports.hello = hello;\n</code></pre> <p>Before processing, Node effectively wraps such code in a function, so that the <code>var</code> and <code>function</code> declarations are contained in that wrapping function's scope, not treated as global variables.</p> <p>Envision the preceding code as being seen by Node as this (illustrative, not actual):</p> <pre><code>function Module(module,require,__dirname,...) {\nvar studentName = \"Kyle\";\nfunction hello() {\nconsole.log(`Hello, ${ studentName }!`);\n}\nhello();\n// Hello, Kyle!\nmodule.exports.hello = hello;\n}\n</code></pre> <p>Node then essentially invokes the added <code>Module(..)</code> function to run your module. You can clearly see here why <code>studentName</code> and <code>hello</code> identifiers are not global, but rather declared in the module scope.</p> <p>As noted earlier, Node defines a number of \"globals\" like <code>require()</code>, but they're not actually identifiers in the global scope (nor properties of the global object). They're injected in the scope of every module, essentially a bit like the parameters listed in the <code>Module(..)</code> function declaration.</p> <p>So how do you define actual global variables in Node? The only way to do so is to add properties to another of Node's automatically provided \"globals,\" which is ironically called <code>global</code>. <code>global</code> is a reference to the real global scope object, somewhat like using <code>window</code> in a browser JS environment.</p> <p>Consider:</p> <pre><code>global.studentName = \"Kyle\";\nfunction hello() {\nconsole.log(`Hello, ${ studentName }!`);\n}\nhello();\n// Hello, Kyle!\nmodule.exports.hello = hello;\n</code></pre> <p>Here we add <code>studentName</code> as a property on the <code>global</code> object, and then in the <code>console.log(..)</code> statement we're able to access <code>studentName</code> as a normal global variable.</p> <p>Remember, the identifier <code>global</code> is not defined by JS; it's specifically defined by Node.</p>"},{"location":"scope-closures/ch4/#global-this","title":"Global This","text":"<p>Reviewing the JS environments we've looked at so far, a program may or may not:</p> <ul> <li> <p>Declare a global variable in the top-level scope with <code>var</code> or <code>function</code> declarations\u2014or <code>let</code>, <code>const</code>, and <code>class</code>.</p> </li> <li> <p>Also add global variables declarations as properties of the global scope object if <code>var</code> or <code>function</code> are used for the declaration.</p> </li> <li> <p>Refer to the global scope object (for adding or retrieving global variables, as properties) with <code>window</code>, <code>self</code>, or <code>global</code>.</p> </li> </ul> <p>I think it's fair to say that global scope access and behavior is more complicated than most developers assume, as the preceding sections have illustrated. But the complexity is never more obvious than in trying to nail down a universally applicable reference to the global scope object.</p> <p>Yet another \"trick\" for obtaining a reference to the global scope object looks like:</p> <pre><code>const theGlobalScopeObject =\n(new Function(\"return this\"))();\n</code></pre> NOTE: A function can be dynamically constructed from code stored in a string value with the <code>Function()</code> constructor, similar to <code>eval(..)</code> (see \"Cheating: Runtime Scope Modifications\" in Chapter 1). Such a function will automatically be run in non-strict-mode (for legacy reasons) when invoked with the normal <code>()</code> function invocation as shown; its <code>this</code> will point at the global object. See the third book in the series, Objects &amp; Classes, for more information on determining <code>this</code> bindings. <p>So, we have <code>window</code>, <code>self</code>, <code>global</code>, and this ugly <code>new Function(..)</code> trick. That's a lot of different ways to try to get at this global object. Each has its pros and cons.</p> <p>Why not introduce yet another!?!?</p> <p>As of ES2020, JS has finally defined a standardized reference to the global scope object, called <code>globalThis</code>. So, subject to the recency of the JS engines your code runs in, you can use <code>globalThis</code> in place of any of those other approaches.</p> <p>We could even attempt to define a cross-environment polyfill that's safer across pre-<code>globalThis</code> JS environments, such as:</p> <pre><code>const theGlobalScopeObject =\n(typeof globalThis != \"undefined\") ? globalThis :\n(typeof global != \"undefined\") ? global :\n(typeof window != \"undefined\") ? window :\n(typeof self != \"undefined\") ? self :\n(new Function(\"return this\"))();\n</code></pre> <p>Phew! That's certainly not ideal, but it works if you find yourself needing a reliable global scope reference.</p> <p>(The proposed name <code>globalThis</code> was fairly controversial while the feature was being added to JS. Specifically, I and many others felt the \"this\" reference in its name was misleading, since the reason you reference this object is to access to the global scope, never to access some sort of global/default <code>this</code> binding. There were many other names considered, but for a variety of reasons ruled out. Unfortunately, the name chosen ended up as a last resort. If you plan to interact with the global scope object in your programs, to reduce confusion, I strongly recommend choosing a better name, such as (the laughably long but accurate!) <code>theGlobalScopeObject</code> used here.)</p>"},{"location":"scope-closures/ch4/#globally-aware","title":"Globally Aware","text":"<p>The global scope is present and relevant in every JS program, even though modern patterns for organizing code into modules de-emphasizes much of the reliance on storing identifiers in that namespace.</p> <p>Still, as our code proliferates more and more beyond the confines of the browser, it's especially important we have a solid grasp on the differences in how the global scope (and global scope object!) behave across different JS environments.</p> <p>With the big picture of global scope now sharper in focus, the next chapter again descends into the deeper details of LEXICAL scope, examining how and when variables can be used.</p>"},{"location":"scope-closures/ch5/","title":"Chapter 5: The (Not So) Secret Lifecycle of Variables","text":"<p>By now you should have a decent grasp of the nesting of scopes, from the global scope downward\u2014called a program's scope chain.</p> <p>But just knowing which scope a variable comes from is only part of the story. If a variable declaration appears past the first statement of a scope, how will any references to that identifier before the declaration behave? What happens if you try to declare the same variable twice in a scope?</p> <p>JS's particular flavor of LEXICAL scope is rich with nuance in how and when variables come into existence and become available to the program.</p>"},{"location":"scope-closures/ch5/#when-can-i-use-a-variable","title":"When Can I Use a Variable?","text":"<p>At what point does a variable become available to use within its scope? There may seem to be an obvious answer: after the variable has been declared/created. Right? Not quite.</p> <p>Consider:</p> <pre><code>greeting();\n// Hello!\nfunction greeting() {\nconsole.log(\"Hello!\");\n}\n</code></pre> <p>This code works fine. You may have seen or even written code like it before. But did you ever wonder how or why it works? Specifically, why can you access the identifier <code>greeting</code> from line 1 (to retrieve and execute a function reference), even though the <code>greeting()</code> function declaration doesn't occur until line 4?</p> <p>Recall Chapter 1 points out that all identifiers are registered to their respective scopes during compile time. Moreover, every identifier is created at the beginning of the scope it belongs to, every time that scope is entered.</p> <p>The term most commonly used for a variable being visible from the beginning of its enclosing scope, even though its declaration may appear further down in the scope, is called hoisting.</p> <p>But hoisting alone doesn't fully answer the question. We can see an identifier called <code>greeting</code> from the beginning of the scope, but why can we call the <code>greeting()</code> function before it's been declared?</p> <p>In other words, how does the variable <code>greeting</code> have any value (the function reference) assigned to it, from the moment the scope starts running? The answer is a special characteristic of formal <code>function</code> declarations, called function hoisting. When a <code>function</code> declaration's name identifier is registered at the top of its scope, it's additionally auto-initialized to that function's reference. That's why the function can be called throughout the entire scope!</p> <p>One key detail is that both function hoisting and <code>var</code>-flavored variable hoisting attach their name identifiers to the nearest enclosing function scope (or, if none, the global scope), not a block scope.</p> NOTE: Declarations with <code>let</code> and <code>const</code> still hoist (see the TDZ discussion later in this chapter). But these two declaration forms attach to their enclosing block rather than just an enclosing function as with <code>var</code> and <code>function</code> declarations. See \"Scoping with Blocks\" in Chapter 6 for more information."},{"location":"scope-closures/ch5/#hoisting-declaration-vs-expression","title":"Hoisting: Declaration vs. Expression","text":"<p>Function hoisting only applies to formal <code>function</code> declarations (specifically those which appear outside of blocks\u2014see \"FiB\" in Chapter 6), not to <code>function</code> expression assignments. Consider:</p> <pre><code>greeting();\n// TypeError\nvar greeting = function greeting() {\nconsole.log(\"Hello!\");\n};\n</code></pre> <p>Line 1 (<code>greeting();</code>) throws an error. But the kind of error thrown is very important to notice. A <code>TypeError</code> means we're trying to do something with a value that is not allowed. Depending on your JS environment, the error message would say something like, \"'undefined' is not a function,\" or more helpfully, \"'greeting' is not a function.\"</p> <p>Notice that the error is not a <code>ReferenceError</code>. JS isn't telling us that it couldn't find <code>greeting</code> as an identifier in the scope. It's telling us that <code>greeting</code> was found but doesn't hold a function reference at that moment. Only functions can be invoked, so attempting to invoke some non-function value results in an error.</p> <p>But what does <code>greeting</code> hold, if not the function reference?</p> <p>In addition to being hoisted, variables declared with <code>var</code> are also automatically initialized to <code>undefined</code> at the beginning of their scope\u2014again, the nearest enclosing function, or the global. Once initialized, they're available to be used (assigned to, retrieved from, etc.) throughout the whole scope.</p> <p>So on that first line, <code>greeting</code> exists, but it holds only the default <code>undefined</code> value. It's not until line 4 that <code>greeting</code> gets assigned the function reference.</p> <p>Pay close attention to the distinction here. A <code>function</code> declaration is hoisted and initialized to its function value (again, called function hoisting). A <code>var</code> variable is also hoisted, and then auto-initialized to <code>undefined</code>. Any subsequent <code>function</code> expression assignments to that variable don't happen until that assignment is processed during runtime execution.</p> <p>In both cases, the name of the identifier is hoisted. But the function reference association isn't handled at initialization time (beginning of the scope) unless the identifier was created in a formal <code>function</code> declaration.</p>"},{"location":"scope-closures/ch5/#variable-hoisting","title":"Variable Hoisting","text":"<p>Let's look at another example of variable hoisting:</p> <pre><code>greeting = \"Hello!\";\nconsole.log(greeting);\n// Hello!\nvar greeting = \"Howdy!\";\n</code></pre> <p>Though <code>greeting</code> isn't declared until line 5, it's available to be assigned to as early as line 1. Why?</p> <p>There's two necessary parts to the explanation:</p> <ul> <li>the identifier is hoisted,</li> <li>and it's automatically initialized to the value <code>undefined</code> from the top of the scope.</li> </ul> NOTE: Using variable hoisting of this sort probably feels unnatural, and many readers might rightly want to avoid relying on it in their programs. But should all hoisting (including function hoisting) be avoided? We'll explore these different perspectives on hoisting in more detail in Appendix A."},{"location":"scope-closures/ch5/#hoisting-yet-another-metaphor","title":"Hoisting: Yet Another Metaphor","text":"<p>Chapter 2 was full of metaphors (to illustrate scope), but here we are faced with yet another: hoisting itself. Rather than hoisting being a concrete execution step the JS engine performs, it's more useful to think of hoisting as a visualization of various actions JS takes in setting up the program before execution.</p> <p>The typical assertion of what hoisting means: lifting\u2014like lifting a heavy weight upward\u2014any identifiers all the way to the top of a scope. The explanation often asserted is that the JS engine will actually rewrite that program before execution, so that it looks more like this:</p> <pre><code>var greeting;           // hoisted declaration\ngreeting = \"Hello!\";    // the original line 1\nconsole.log(greeting);  // Hello!\ngreeting = \"Howdy!\";    // `var` is gone!\n</code></pre> <p>The hoisting (metaphor) proposes that JS pre-processes the original program and re-arranges it a bit, so that all the declarations have been moved to the top of their respective scopes, before execution. Moreover, the hoisting metaphor asserts that <code>function</code> declarations are, in their entirety, hoisted to the top of each scope. Consider:</p> <pre><code>studentName = \"Suzy\";\ngreeting();\n// Hello Suzy!\nfunction greeting() {\nconsole.log(`Hello ${ studentName }!`);\n}\nvar studentName;\n</code></pre> <p>The \"rule\" of the hoisting metaphor is that function declarations are hoisted first, then variables are hoisted immediately after all the functions. Thus, the hoisting story suggests that program is re-arranged by the JS engine to look like this:</p> <pre><code>function greeting() {\nconsole.log(`Hello ${ studentName }!`);\n}\nvar studentName;\nstudentName = \"Suzy\";\ngreeting();\n// Hello Suzy!\n</code></pre> <p>This hoisting metaphor is convenient. Its benefit is allowing us to hand wave over the magical look-ahead pre-processing necessary to find all these declarations buried deep in scopes and somehow move (hoist) them to the top; we can just think about the program as if it's executed by the JS engine in a single pass, top-down.</p> <p>Single-pass definitely seems more straightforward than Chapter 1's assertion of a two-phase processing.</p> <p>Hoisting as a mechanism for re-ordering code may be an attractive simplification, but it's not accurate. The JS engine doesn't actually re-arrange the code. It can't magically look ahead and find declarations; the only way to accurately find them, as well as all the scope boundaries in the program, would be to fully parse the code.</p> <p>Guess what parsing is? The first phase of the two-phase processing! There's no magical mental gymnastics that gets around that fact.</p> <p>So if the hoisting metaphor is (at best) inaccurate, what should we do with the term? I think it's still useful\u2014indeed, even members of TC39 regularly use it!\u2014but I don't think we should claim it's an actual re-arrangement of source code.</p> WARNING: Incorrect or incomplete mental models often still seem sufficient because they can occasionally lead to accidental right answers. But in the long run it's harder to accurately analyze and predict outcomes if your thinking isn't particularly aligned with how the JS engine works. <p>I assert that hoisting should be used to refer to the compile-time operation of generating runtime instructions for the automatic registration of a variable at the beginning of its scope, each time that scope is entered.</p> <p>That's a subtle but important shift, from hoisting as a runtime behavior to its proper place among compile-time tasks.</p>"},{"location":"scope-closures/ch5/#re-declaration","title":"Re-declaration?","text":"<p>What do you think happens when a variable is declared more than once in the same scope? Consider:</p> <pre><code>var studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\nvar studentName;\nconsole.log(studentName);   // ???\n</code></pre> <p>What do you expect to be printed for that second message? Many believe the second <code>var studentName</code> has re-declared the variable (and thus \"reset\" it), so they expect <code>undefined</code> to be printed.</p> <p>But is there such a thing as a variable being \"re-declared\" in the same scope? No.</p> <p>If you consider this program from the perspective of the hoisting metaphor, the code would be re-arranged like this for execution purposes:</p> <pre><code>var studentName;\nvar studentName;    // clearly a pointless no-op!\nstudentName = \"Frank\";\nconsole.log(studentName);\n// Frank\nconsole.log(studentName);\n// Frank\n</code></pre> <p>Since hoisting is actually about registering a variable at the beginning of a scope, there's nothing to be done in the middle of the scope where the original program actually had the second <code>var studentName</code> statement. It's just a no-op(eration), a pointless statement.</p> TIP: In the style of the conversation narrative from Chapter 2, Compiler would find the second <code>var</code> declaration statement and ask the Scope Manager if it had already seen a <code>studentName</code> identifier; since it had, there wouldn't be anything else to do. <p>It's also important to point out that <code>var studentName;</code> doesn't mean <code>var studentName = undefined;</code>, as most assume. Let's prove they're different by considering this variation of the program:</p> <pre><code>var studentName = \"Frank\";\nconsole.log(studentName);   // Frank\nvar studentName;\nconsole.log(studentName);   // Frank &lt;--- still!\n// let's add the initialization explicitly\nvar studentName = undefined;\nconsole.log(studentName);   // undefined &lt;--- see!?\n</code></pre> <p>See how the explicit <code>= undefined</code> initialization produces a different outcome than assuming it happens implicitly when omitted? In the next section, we'll revisit this topic of initialization of variables from their declarations.</p> <p>A repeated <code>var</code> declaration of the same identifier name in a scope is effectively a do-nothing operation. Here's another illustration, this time across a function of the same name:</p> <pre><code>var greeting;\nfunction greeting() {\nconsole.log(\"Hello!\");\n}\n// basically, a no-op\nvar greeting;\ntypeof greeting;        // \"function\"\nvar greeting = \"Hello!\";\ntypeof greeting;        // \"string\"\n</code></pre> <p>The first <code>greeting</code> declaration registers the identifier to the scope, and because it's a <code>var</code> the auto-initialization will be <code>undefined</code>. The <code>function</code> declaration doesn't need to re-register the identifier, but because of function hoisting it overrides the auto-initialization to use the function reference. The second <code>var greeting</code> by itself doesn't do anything since <code>greeting</code> is already an identifier and function hoisting already took precedence for the auto-initialization.</p> <p>Actually assigning <code>\"Hello!\"</code> to <code>greeting</code> changes its value from the initial function <code>greeting()</code> to the string; <code>var</code> itself doesn't have any effect.</p> <p>What about repeating a declaration within a scope using <code>let</code> or <code>const</code>?</p> <pre><code>let studentName = \"Frank\";\nconsole.log(studentName);\nlet studentName = \"Suzy\";\n</code></pre> <p>This program will not execute, but instead immediately throw a <code>SyntaxError</code>. Depending on your JS environment, the error message will indicate something like: \"studentName has already been declared.\" In other words, this is a case where attempted \"re-declaration\" is explicitly not allowed!</p> <p>It's not just that two declarations involving <code>let</code> will throw this error. If either declaration uses <code>let</code>, the other can be either <code>let</code> or <code>var</code>, and the error will still occur, as illustrated with these two variations:</p> <pre><code>var studentName = \"Frank\";\nlet studentName = \"Suzy\";\n</code></pre> <p>and:</p> <pre><code>let studentName = \"Frank\";\nvar studentName = \"Suzy\";\n</code></pre> <p>In both cases, a <code>SyntaxError</code> is thrown on the second declaration. In other words, the only way to \"re-declare\" a variable is to use <code>var</code> for all (two or more) of its declarations.</p> <p>But why disallow it? The reason for the error is not technical per se, as <code>var</code> \"re-declaration\" has always been allowed; clearly, the same allowance could have been made for <code>let</code>.</p> <p>It's really more of a \"social engineering\" issue. \"Re-declaration\" of variables is seen by some, including many on the TC39 body, as a bad habit that can lead to program bugs. So when ES6 introduced <code>let</code>, they decided to prevent \"re-declaration\" with an error.</p> NOTE: This is of course a stylistic opinion, not really a technical argument. Many developers agree with the position, and that's probably in part why TC39 included the error (as well as <code>let</code> conforming to <code>const</code>). But a reasonable case could have been made that staying consistent with <code>var</code>'s precedent was more prudent, and that such opinion-enforcement was best left to opt-in tooling like linters. In Appendix A, we'll explore whether <code>var</code> (and its associated behavior, like \"re-declaration\") can still be useful in modern JS. <p>When Compiler asks Scope Manager about a declaration, if that identifier has already been declared, and if either/both declarations were made with <code>let</code>, an error is thrown. The intended signal to the developer is \"Stop relying on sloppy re-declaration!\"</p>"},{"location":"scope-closures/ch5/#constants","title":"Constants?","text":"<p>The <code>const</code> keyword is more constrained than <code>let</code>. Like <code>let</code>, <code>const</code> cannot be repeated with the same identifier in the same scope. But there's actually an overriding technical reason why that sort of \"re-declaration\" is disallowed, unlike <code>let</code> which disallows \"re-declaration\" mostly for stylistic reasons.</p> <p>The <code>const</code> keyword requires a variable to be initialized, so omitting an assignment from the declaration results in a <code>SyntaxError</code>:</p> <pre><code>const empty;   // SyntaxError\n</code></pre> <p><code>const</code> declarations create variables that cannot be re-assigned:</p> <pre><code>const studentName = \"Frank\";\nconsole.log(studentName);\n// Frank\nstudentName = \"Suzy\";   // TypeError\n</code></pre> <p>The <code>studentName</code> variable cannot be re-assigned because it's declared with a <code>const</code>.</p> WARNING: The error thrown when re-assigning <code>studentName</code> is a <code>TypeError</code>, not a <code>SyntaxError</code>. The subtle distinction here is actually pretty important, but unfortunately far too easy to miss. Syntax errors represent faults in the program that stop it from even starting execution. Type errors represent faults that arise during program execution. In the preceding snippet, <code>\"Frank\"</code> is printed out before we process the re-assignment of <code>studentName</code>, which then throws the error. <p>So if <code>const</code> declarations cannot be re-assigned, and <code>const</code> declarations always require assignments, then we have a clear technical reason why <code>const</code> must disallow any \"re-declarations\": any <code>const</code> \"re-declaration\" would also necessarily be a <code>const</code> re-assignment, which can't be allowed!</p> <pre><code>const studentName = \"Frank\";\n// obviously this must be an error\nconst studentName = \"Suzy\";\n</code></pre> <p>Since <code>const</code> \"re-declaration\" must be disallowed (on those technical grounds), TC39 essentially felt that <code>let</code> \"re-declaration\" should be disallowed as well, for consistency. It's debatable if this was the best choice, but at least we have the reasoning behind the decision.</p>"},{"location":"scope-closures/ch5/#loops","title":"Loops","text":"<p>So it's clear from our previous discussion that JS doesn't really want us to \"re-declare\" our variables within the same scope. That probably seems like a straightforward admonition, until you consider what it means for repeated execution of declaration statements in loops. Consider:</p> <pre><code>var keepGoing = true;\nwhile (keepGoing) {\nlet value = Math.random();\nif (value &gt; 0.5) {\nkeepGoing = false;\n}\n}\n</code></pre> <p>Is <code>value</code> being \"re-declared\" repeatedly in this program? Will we get errors thrown? No.</p> <p>All the rules of scope (including \"re-declaration\" of <code>let</code>-created variables) are applied per scope instance. In other words, each time a scope is entered during execution, everything resets.</p> <p>Each loop iteration is its own new scope instance, and within each scope instance, <code>value</code> is only being declared once. So there's no attempted \"re-declaration,\" and thus no error. Before we consider other loop forms, what if the <code>value</code> declaration in the previous snippet were changed to a <code>var</code>?</p> <pre><code>var keepGoing = true;\nwhile (keepGoing) {\nvar value = Math.random();\nif (value &gt; 0.5) {\nkeepGoing = false;\n}\n}\n</code></pre> <p>Is <code>value</code> being \"re-declared\" here, especially since we know <code>var</code> allows it? No. Because <code>var</code> is not treated as a block-scoping declaration (see Chapter 6), it attaches itself to the global scope. So there's just one <code>value</code> variable, in the same scope as <code>keepGoing</code> (global scope, in this case). No \"re-declaration\" here, either!</p> <p>One way to keep this all straight is to remember that <code>var</code>, <code>let</code>, and <code>const</code> keywords are effectively removed from the code by the time it starts to execute. They're handled entirely by the compiler.</p> <p>If you mentally erase the declarator keywords and then try to process the code, it should help you decide if and when (re-)declarations might occur.</p> <p>What about \"re-declaration\" with other loop forms, like <code>for</code>-loops?</p> <pre><code>for (let i = 0; i &lt; 3; i++) {\nlet value = i * 10;\nconsole.log(`${ i }: ${ value }`);\n}\n// 0: 0\n// 1: 10\n// 2: 20\n</code></pre> <p>It should be clear that there's only one <code>value</code> declared per scope instance. But what about <code>i</code>? Is it being \"re-declared\"?</p> <p>To answer that, consider what scope <code>i</code> is in. It might seem like it would be in the outer (in this case, global) scope, but it's not. It's in the scope of <code>for</code>-loop body, just like <code>value</code> is. In fact, you could sorta think about that loop in this more verbose equivalent form:</p> <pre><code>{\n// a fictional variable for illustration\nlet $$i = 0;\nfor ( /* nothing */; $$i &lt; 3; $$i++) {\n// here's our actual loop `i`!\nlet i = $$i;\nlet value = i * 10;\nconsole.log(`${ i }: ${ value }`);\n}\n// 0: 0\n// 1: 10\n// 2: 20\n}\n</code></pre> <p>Now it should be clear: the <code>i</code> and <code>value</code> variables are both declared exactly once per scope instance. No \"re-declaration\" here.</p> <p>What about other <code>for</code>-loop forms?</p> <pre><code>for (let index in students) {\n// this is fine\n}\nfor (let student of students) {\n// so is this\n}\n</code></pre> <p>Same thing with <code>for..in</code> and <code>for..of</code> loops: the declared variable is treated as inside the loop body, and thus is handled per iteration (aka, per scope instance). No \"re-declaration.\"</p> <p>OK, I know you're thinking that I sound like a broken record at this point. But let's explore how <code>const</code> impacts these looping constructs. Consider:</p> <pre><code>var keepGoing = true;\nwhile (keepGoing) {\n// ooo, a shiny constant!\nconst value = Math.random();\nif (value &gt; 0.5) {\nkeepGoing = false;\n}\n}\n</code></pre> <p>Just like the <code>let</code> variant of this program we saw earlier, <code>const</code> is being run exactly once within each loop iteration, so it's safe from \"re-declaration\" troubles. But things get more complicated when we talk about <code>for</code>-loops.</p> <p><code>for..in</code> and <code>for..of</code> are fine to use with <code>const</code>:</p> <pre><code>for (const index in students) {\n// this is fine\n}\nfor (const student of students) {\n// this is also fine\n}\n</code></pre> <p>But not the general <code>for</code>-loop:</p> <pre><code>for (const i = 0; i &lt; 3; i++) {\n// oops, this is going to fail with\n// a Type Error after the first iteration\n}\n</code></pre> <p>What's wrong here? We could use <code>let</code> just fine in this construct, and we asserted that it creates a new <code>i</code> for each loop iteration scope, so it doesn't even seem to be a \"re-declaration.\"</p> <p>Let's mentally \"expand\" that loop like we did earlier:</p> <pre><code>{\n// a fictional variable for illustration\nconst $$i = 0;\nfor ( ; $$i &lt; 3; $$i++) {\n// here's our actual loop `i`!\nconst i = $$i;\n// ..\n}\n}\n</code></pre> <p>Do you spot the problem? Our <code>i</code> is indeed just created once inside the loop. That's not the problem. The problem is the conceptual <code>$$i</code> that must be incremented each time with the <code>$$i++</code> expression. That's re-assignment (not \"re-declaration\"), which isn't allowed for constants.</p> <p>Remember, this \"expanded\" form is only a conceptual model to help you intuit the source of the problem. You might wonder if JS could have effectively made the <code>const $$i = 0</code> instead into <code>let $ii = 0</code>, which would then allow <code>const</code> to work with our classic <code>for</code>-loop? It's possible, but then it could have introduced potentially surprising exceptions to <code>for</code>-loop semantics.</p> <p>For example, it would have been a rather arbitrary (and likely confusing) nuanced exception to allow <code>i++</code> in the <code>for</code>-loop header to skirt strictness of the <code>const</code> assignment, but not allow other re-assignments of <code>i</code> inside the loop iteration, as is sometimes useful.</p> <p>The straightforward answer is: <code>const</code> can't be used with the classic <code>for</code>-loop form because of the required re-assignment.</p> <p>Interestingly, if you don't do re-assignment, then it's valid:</p> <pre><code>var keepGoing = true;\nfor (const i = 0; keepGoing; /* nothing here */ ) {\nkeepGoing = (Math.random() &gt; 0.5);\n// ..\n}\n</code></pre> <p>That works, but it's pointless. There's no reason to declare <code>i</code> in that position with a <code>const</code>, since the whole point of such a variable in that position is to be used for counting iterations. Just use a different loop form, like a <code>while</code> loop, or use a <code>let</code>!</p>"},{"location":"scope-closures/ch5/#uninitialized-variables-aka-tdz","title":"Uninitialized Variables (aka, TDZ)","text":"<p>With <code>var</code> declarations, the variable is \"hoisted\" to the top of its scope. But it's also automatically initialized to the <code>undefined</code> value, so that the variable can be used throughout the entire scope.</p> <p>However, <code>let</code> and <code>const</code> declarations are not quite the same in this respect.</p> <p>Consider:</p> <pre><code>console.log(studentName);\n// ReferenceError\nlet studentName = \"Suzy\";\n</code></pre> <p>The result of this program is that a <code>ReferenceError</code> is thrown on the first line. Depending on your JS environment, the error message may say something like: \"Cannot access studentName before initialization.\"</p> NOTE: The error message as seen here used to be much more vague or misleading. Thankfully, several of us in the community were successfully able to lobby for JS engines to improve this error message so it more accurately tells you what's wrong! <p>That error message is quite indicative of what's wrong: <code>studentName</code> exists on line 1, but it's not been initialized, so it cannot be used yet. Let's try this:</p> <pre><code>studentName = \"Suzy\";   // let's try to initialize it!\n// ReferenceError\nconsole.log(studentName);\nlet studentName;\n</code></pre> <p>Oops. We still get the <code>ReferenceError</code>, but now on the first line where we're trying to assign to (aka, initialize!) this so-called \"uninitialized\" variable <code>studentName</code>. What's the deal!?</p> <p>The real question is, how do we initialize an uninitialized variable? For <code>let</code>/<code>const</code>, the only way to do so is with an assignment attached to a declaration statement. An assignment by itself is insufficient! Consider:</p> <pre><code>let studentName = \"Suzy\";\nconsole.log(studentName);   // Suzy\n</code></pre> <p>Here, we are initializing the <code>studentName</code> (in this case, to <code>\"Suzy\"</code> instead of <code>undefined</code>) by way of the <code>let</code> declaration statement form that's coupled with an assignment.</p> <p>Alternatively:</p> <pre><code>// ..\nlet studentName;\n// or:\n// let studentName = undefined;\n// ..\nstudentName = \"Suzy\";\nconsole.log(studentName);\n// Suzy\n</code></pre> NOTE: That's interesting! Recall from earlier, we said that <code>var studentName;</code> is not the same as <code>var studentName = undefined;</code>, but here with <code>let</code>, they behave the same. The difference comes down to the fact that <code>var studentName</code> automatically initializes at the top of the scope, where <code>let studentName</code> does not. <p>Remember that we've asserted a few times so far that Compiler ends up removing any <code>var</code>/<code>let</code>/<code>const</code> declarators, replacing them with the instructions at the top of each scope to register the appropriate identifiers.</p> <p>So if we analyze what's going on here, we see that an additional nuance is that Compiler is also adding an instruction in the middle of the program, at the point where the variable <code>studentName</code> was declared, to handle that declaration's auto-initialization. We cannot use the variable at any point prior to that initialization occuring. The same goes for <code>const</code> as it does for <code>let</code>.</p> <p>The term coined by TC39 to refer to this period of time from the entering of a scope to where the auto-initialization of the variable occurs is: Temporal Dead Zone (TDZ).</p> <p>The TDZ is the time window where a variable exists but is still uninitialized, and therefore cannot be accessed in any way. Only the execution of the instructions left by Compiler at the point of the original declaration can do that initialization. After that moment, the TDZ is done, and the variable is free to be used for the rest of the scope.</p> <p>A <code>var</code> also technically has a TDZ, but it's zero in length and thus unobservable to our programs! Only <code>let</code> and <code>const</code> have an observable TDZ.</p> <p>By the way, \"temporal\" in TDZ does indeed refer to time not position in code. Consider:</p> <pre><code>askQuestion();\n// ReferenceError\nlet studentName = \"Suzy\";\nfunction askQuestion() {\nconsole.log(`${ studentName }, do you know?`);\n}\n</code></pre> <p>Even though positionally the <code>console.log(..)</code> referencing <code>studentName</code> comes after the <code>let studentName</code> declaration, timing wise the <code>askQuestion()</code> function is invoked before the <code>let</code> statement is encountered, while <code>studentName</code> is still in its TDZ! Hence the error.</p> <p>There's a common misconception that TDZ means <code>let</code> and <code>const</code> do not hoist. This is an inaccurate, or at least slightly misleading, claim. They definitely hoist.</p> <p>The actual difference is that <code>let</code>/<code>const</code> declarations do not automatically initialize at the beginning of the scope, the way <code>var</code> does. The debate then is if the auto-initialization is part of hoisting, or not? I think auto-registration of a variable at the top of the scope (i.e., what I call \"hoisting\") and auto-initialization at the top of the scope (to <code>undefined</code>) are distinct operations and shouldn't be lumped together under the single term \"hoisting.\"</p> <p>We've already seen that <code>let</code> and <code>const</code> don't auto-initialize at the top of the scope. But let's prove that <code>let</code> and <code>const</code> do hoist (auto-register at the top of the scope), courtesy of our friend shadowing (see \"Shadowing\" in Chapter 3):</p> <pre><code>var studentName = \"Kyle\";\n{\nconsole.log(studentName);\n// ???\n// ..\nlet studentName = \"Suzy\";\nconsole.log(studentName);\n// Suzy\n}\n</code></pre> <p>What's going to happen with the first <code>console.log(..)</code> statement? If <code>let studentName</code> didn't hoist to the top of the scope, then the first <code>console.log(..)</code> should print <code>\"Kyle\"</code>, right? At that moment, it would seem, only the outer <code>studentName</code> exists, so that's the variable <code>console.log(..)</code> should access and print.</p> <p>But instead, the first <code>console.log(..)</code> throws a TDZ error, because in fact, the inner scope's <code>studentName</code> was hoisted (auto-registered at the top of the scope). What didn't happen (yet!) was the auto-initialization of that inner <code>studentName</code>; it's still uninitialized at that moment, hence the TDZ violation!</p> <p>So to summarize, TDZ errors occur because <code>let</code>/<code>const</code> declarations do hoist their declarations to the top of their scopes, but unlike <code>var</code>, they defer the auto-initialization of their variables until the moment in the code's sequencing where the original declaration appeared. This window of time (hint: temporal), whatever its length, is the TDZ.</p> <p>How can you avoid TDZ errors?</p> <p>My advice: always put your <code>let</code> and <code>const</code> declarations at the top of any scope. Shrink the TDZ window to zero (or near zero) length, and then it'll be moot.</p> <p>But why is TDZ even a thing? Why didn't TC39 dictate that <code>let</code>/<code>const</code> auto-initialize the way <code>var</code> does? Just be patient, we'll come back to explore the why of TDZ in Appendix A.</p>"},{"location":"scope-closures/ch5/#finally-initialized","title":"Finally Initialized","text":"<p>Working with variables has much more nuance than it seems at first glance. Hoisting, (re)declaration, and the TDZ are common sources of confusion for developers, especially those who have worked in other languages before coming to JS. Before moving on, make sure your mental model is fully grounded on these aspects of JS scope and variables.</p> <p>Hoisting is generally cited as an explicit mechanism of the JS engine, but it's really more a metaphor to describe the various ways JS handles variable declarations during compilation. But even as a metaphor, hoisting offers useful structure for thinking about the life-cycle of a variable\u2014when it's created, when it's available to use, when it goes away.</p> <p>Declaration and re-declaration of variables tend to cause confusion when thought of as runtime operations. But if you shift to compile-time thinking for these operations, the quirks and shadows diminish.</p> <p>The TDZ (temporal dead zone) error is strange and frustrating when encountered. Fortunately, TDZ is relatively straightforward to avoid if you're always careful to place <code>let</code>/<code>const</code> declarations at the top of any scope.</p> <p>As you successfully navigate these twists and turns of variable scope, the next chapter will lay out the factors that guide our decisions to place our declarations in various scopes, especially nested blocks.</p>"},{"location":"scope-closures/ch6/","title":"Chapter 6: Limiting Scope Exposure","text":"<p>So far our focus has been explaining the mechanics of how scopes and variables work. With that foundation now firmly in place, our attention raises to a higher level of thinking: decisions and patterns we apply across the whole program.</p> <p>To begin, we're going to look at how and why we should be using different levels of scope (functions and blocks) to organize our program's variables, specifically to reduce scope over-exposure.</p>"},{"location":"scope-closures/ch6/#least-exposure","title":"Least Exposure","text":"<p>It makes sense that functions define their own scopes. But why do we need blocks to create scopes as well?</p> <p>Software engineering articulates a fundamental discipline, typically applied to software security, called \"The Principle of Least Privilege\" (POLP). 1 And a variation of this principle that applies to our current discussion is typically labeled as \"Least Exposure\" (POLE).</p> <p>POLP expresses a defensive posture to software architecture: components of the system should be designed to function with least privilege, least access, least exposure. If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint, because a compromise or failure of one piece has a minimized impact on the rest of the system.</p> <p>If POLP focuses on system-level component design, the POLE Exposure variant focuses on a lower level; we'll apply it to how scopes interact with each other.</p> <p>In following POLE, what do we want to minimize the exposure of? Simply: the variables registered in each scope.</p> <p>Think of it this way: why shouldn't you just place all the variables of your program out in the global scope? That probably immediately feels like a bad idea, but it's worth considering why that is. When variables used by one part of the program are exposed to another part of the program, via scope, there are three main hazards that often arise:</p> <ul> <li> <p>Naming Collisions: if you use a common and useful variable/function name in two different parts of the program, but the identifier comes from one shared scope (like the global scope), then name collision occurs, and it's very likely that bugs will occur as one part uses the variable/function in a way the other part doesn't expect.</p> <p>For example, imagine if all your loops used a single global <code>i</code> index variable, and then it happens that one loop in a function is running during an iteration of a loop from another function, and now the shared <code>i</code> variable gets an unexpected value.</p> </li> <li> <p>Unexpected Behavior: if you expose variables/functions whose usage is otherwise private to a piece of the program, it allows other developers to use them in ways you didn't intend, which can violate expected behavior and cause bugs.</p> <p>For example, if your part of the program assumes an array contains all numbers, but someone else's code accesses and modifies the array to include booleans and strings, your code may then misbehave in unexpected ways.</p> <p>Worse, exposure of private details invites those with mal-intent to try to work around limitations you have imposed, to do things with your part of the software that shouldn't be allowed.</p> </li> <li> <p>Unintended Dependency: if you expose variables/functions unnecessarily, it invites other developers to use and depend on those otherwise private pieces. While that doesn't break your program today, it creates a refactoring hazard in the future, because now you cannot as easily refactor that variable or function without potentially breaking other parts of the software that you don't control.</p> <p>For example, if your code relies on an array of numbers, and you later decide it's better to use some other data structure instead of an array, you now must take on the liability of adjusting other affected parts of the software.</p> </li> </ul> <p>POLE, as applied to variable/function scoping, essentially says, default to exposing the bare minimum necessary, keeping everything else as private as possible. Declare variables in as small and deeply nested of scopes as possible, rather than placing everything in the global (or even outer function) scope.</p> <p>If you design your software accordingly, you have a much greater chance of avoiding (or at least minimizing) these three hazards.</p> <p>Consider:</p> <pre><code>function diff(x,y) {\nif (x &gt; y) {\nlet tmp = x;\nx = y;\ny = tmp;\n}\nreturn y - x;\n}\ndiff(3,7);      // 4\ndiff(7,5);      // 2\n</code></pre> <p>In this <code>diff(..)</code> function, we want to ensure that <code>y</code> is greater than or equal to <code>x</code>, so that when we subtract (<code>y - x</code>), the result is <code>0</code> or larger. If <code>x</code> is initially larger (the result would be negative!), we swap <code>x</code> and <code>y</code> using a <code>tmp</code> variable, to keep the result positive.</p> <p>In this simple example, it doesn't seem to matter whether <code>tmp</code> is inside the <code>if</code> block or whether it belongs at the function level\u2014it certainly shouldn't be a global variable! However, following the POLE principle, <code>tmp</code> should be as hidden in scope as possible. So we block scope <code>tmp</code> (using <code>let</code>) to the <code>if</code> block.</p>"},{"location":"scope-closures/ch6/#hiding-in-plain-function-scope","title":"Hiding in Plain (Function) Scope","text":"<p>It should now be clear why it's important to hide our variable and function declarations in the lowest (most deeply nested) scopes possible. But how do we do so?</p> <p>We've already seen the <code>let</code> and <code>const</code> keywords, which are block scoped declarators; we'll come back to them in more detail shortly. But first, what about hiding <code>var</code> or <code>function</code> declarations in scopes? That can easily be done by wrapping a <code>function</code> scope around a declaration.</p> <p>Let's consider an example where <code>function</code> scoping can be useful.</p> <p>The mathematical operation \"factorial\" (notated as \"6!\") is the multiplication of a given integer against all successively lower integers down to <code>1</code>\u2014actually, you can stop at <code>2</code> since multiplying <code>1</code> does nothing. In other words, \"6!\" is the same as \"6 * 5!\", which is the same as \"6 * 5 * 4!\", and so on. Because of the nature of the math involved, once any given integer's factorial (like \"4!\") has been calculated, we shouldn't need to do that work again, as it'll always be the same answer.</p> <p>So if you naively calculate factorial for <code>6</code>, then later want to calculate factorial for <code>7</code>, you might unnecessarily re-calculate the factorials of all the integers from 2 up to 6. If you're willing to trade memory for speed, you can solve that wasted computation by caching each integer's factorial as it's calculated:</p> <pre><code>var cache = {};\nfunction factorial(x) {\nif (x &lt; 2) return 1;\nif (!(x in cache)) {\ncache[x] = x * factorial(x - 1);\n}\nreturn cache[x];\n}\nfactorial(6);\n// 720\ncache;\n// {\n//     \"2\": 2,\n//     \"3\": 6,\n//     \"4\": 24,\n//     \"5\": 120,\n//     \"6\": 720\n// }\nfactorial(7);\n// 5040\n</code></pre> <p>We're storing all the computed factorials in <code>cache</code> so that across multiple calls to <code>factorial(..)</code>, the previous computations remain. But the <code>cache</code> variable is pretty obviously a private detail of how <code>factorial(..)</code> works, not something that should be exposed in an outer scope\u2014especially not the global scope.</p> NOTE: <code>factorial(..)</code> here is recursive\u2014a call to itself is made from inside\u2014but that's just for brevity of code sake; a non-recursive implementation would yield the same scoping analysis with respect to <code>cache</code>. <p>However, fixing this over-exposure issue is not as simple as hiding the <code>cache</code> variable inside <code>factorial(..)</code>, as it might seem. Since we need <code>cache</code> to survive multiple calls, it must be located in a scope outside that function. So what can we do?</p> <p>Define another middle scope (between the outer/global scope and the inside of <code>factorial(..)</code>) for <code>cache</code> to be located:</p> <pre><code>// outer/global scope\nfunction hideTheCache() {\n// \"middle scope\", where we hide `cache`\nvar cache = {};\nreturn factorial;\n// **********************\nfunction factorial(x) {\n// inner scope\nif (x &lt; 2) return 1;\nif (!(x in cache)) {\ncache[x] = x * factorial(x - 1);\n}\nreturn cache[x];\n}\n}\nvar factorial = hideTheCache();\nfactorial(6);\n// 720\nfactorial(7);\n// 5040\n</code></pre> <p>The <code>hideTheCache()</code> function serves no other purpose than to create a scope for <code>cache</code> to persist in across multiple calls to <code>factorial(..)</code>. But for <code>factorial(..)</code> to have access to <code>cache</code>, we have to define <code>factorial(..)</code> inside that same scope. Then we return the function reference, as a value from <code>hideTheCache()</code>, and store it in an outer scope variable, also named <code>factorial</code>. Now as we call <code>factorial(..)</code> (multiple times!), its persistent <code>cache</code> stays hidden yet accessible only to <code>factorial(..)</code>!</p> <p>OK, but... it's going to be tedious to define (and name!) a <code>hideTheCache(..)</code> function scope each time such a need for variable/function hiding occurs, especially since we'll likely want to avoid name collisions with this function by giving each occurrence a unique name. Ugh.</p> NOTE: The illustrated technique\u2014caching a function's computed output to optimize performance when repeated calls of the same inputs are expected\u2014is quite common in the Functional Programming (FP) world, canonically referred to as \"memoization\"; this caching relies on closure (see Chapter 7). Also, there are memory usage concerns (addressed in \"A Word About Memory\" in Appendix B). FP libraries will usually provide an optimized and vetted utility for memoization of functions, which would take the place of <code>hideTheCache(..)</code> here. Memoization is beyond the scope (pun intended!) of our discussion, but see my Functional-Light JavaScript book for more information. <p>Rather than defining a new and uniquely named function each time one of those scope-only-for-the-purpose-of-hiding-a-variable situations occurs, a perhaps better solution is to use a function expression:</p> <pre><code>var factorial = (function hideTheCache() {\nvar cache = {};\nfunction factorial(x) {\nif (x &lt; 2) return 1;\nif (!(x in cache)) {\ncache[x] = x * factorial(x - 1);\n}\nreturn cache[x];\n}\nreturn factorial;\n})();\nfactorial(6);\n// 720\nfactorial(7);\n// 5040\n</code></pre> <p>Wait! This is still using a function to create the scope for hiding <code>cache</code>, and in this case, the function is still named <code>hideTheCache</code>, so how does that solve anything?</p> <p>Recall from \"Function Name Scope\" (in Chapter 3), what happens to the name identifier from a <code>function</code> expression. Since <code>hideTheCache(..)</code> is defined as a <code>function</code> expression instead of a <code>function</code> declaration, its name is in its own scope\u2014essentially the same scope as <code>cache</code>\u2014rather than in the outer/global scope.</p> <p>That means we can name every single occurrence of such a function expression the exact same name, and never have any collision. More appropriately, we can name each occurrence semantically based on whatever it is we're trying to hide, and not worry that whatever name we choose is going to collide with any other <code>function</code> expression scope in the program.</p> <p>In fact, we could just leave off the name entirely\u2014thus defining an \"anonymous <code>function</code> expression\" instead. But Appendix A will discuss the importance of names even for such scope-only functions.</p>"},{"location":"scope-closures/ch6/#invoking-function-expressions-immediately","title":"Invoking Function Expressions Immediately","text":"<p>There's another important bit in the previous factorial recursive program that's easy to miss: the line at the end of the <code>function</code> expression that contains <code>})();</code>.</p> <p>Notice that we surrounded the entire <code>function</code> expression in a set of <code>( .. )</code>, and then on the end, we added that second <code>()</code> parentheses set; that's actually calling the <code>function</code> expression we just defined. Moreover, in this case, the first set of surrounding <code>( .. )</code> around the function expression is not strictly necessary (more on that in a moment), but we used them for readability sake anyway.</p> <p>So, in other words, we're defining a <code>function</code> expression that's then immediately invoked. This common pattern has a (very creative!) name: Immediately Invoked Function Expression (IIFE).</p> <p>An IIFE is useful when we want to create a scope to hide variables/functions. Since it's an expression, it can be used in any place in a JS program where an expression is allowed. An IIFE can be named, as with <code>hideTheCache()</code>, or (much more commonly!) unnamed/anonymous. And it can be standalone or, as before, part of another statement\u2014<code>hideTheCache()</code> returns the <code>factorial()</code> function reference which is then <code>=</code> assigned to the variable <code>factorial</code>.</p> <p>For comparison, here's an example of a standalone IIFE:</p> <pre><code>// outer scope\n(function(){\n// inner hidden scope\n})();\n// more outer scope\n</code></pre> <p>Unlike earlier with <code>hideTheCache()</code>, where the outer surrounding <code>(..)</code> were noted as being an optional stylistic choice, for a standalone IIFE they're required; they distinguish the <code>function</code> as an expression, not a statement. For consistency, however, always surround an IIFE <code>function</code> with <code>( .. )</code>.</p> NOTE: Technically, the surrounding <code>( .. )</code> aren't the only syntactic way to ensure the <code>function</code> in an IIFE is treated by the JS parser as a function expression. We'll look at some other options in Appendix A."},{"location":"scope-closures/ch6/#function-boundaries","title":"Function Boundaries","text":"<p>Beware that using an IIFE to define a scope can have some unintended consequences, depending on the code around it. Because an IIFE is a full function, the function boundary alters the behavior of certain statements/constructs.</p> <p>For example, a <code>return</code> statement in some piece of code would change its meaning if an IIFE is wrapped around it, because now the <code>return</code> would refer to the IIFE's function. Non-arrow function IIFEs also change the binding of a <code>this</code> keyword\u2014more on that in the Objects &amp; Classes book. And statements like <code>break</code> and <code>continue</code> won't operate across an IIFE function boundary to control an outer loop or block.</p> <p>So, if the code you need to wrap a scope around has <code>return</code>, <code>this</code>, <code>break</code>, or <code>continue</code> in it, an IIFE is probably not the best approach. In that case, you might look to create the scope with a block instead of a function.</p>"},{"location":"scope-closures/ch6/#scoping-with-blocks","title":"Scoping with Blocks","text":"<p>You should by this point feel fairly comfortable with the merits of creating scopes to limit identifier exposure.</p> <p>So far, we looked at doing this via <code>function</code> (i.e., IIFE) scope. But let's now consider using <code>let</code> declarations with nested blocks. In general, any <code>{ .. }</code> curly-brace pair which is a statement will act as a block, but not necessarily as a scope.</p> <p>A block only becomes a scope if necessary, to contain its block-scoped declarations (i.e., <code>let</code> or <code>const</code>). Consider:</p> <pre><code>{\n// not necessarily a scope (yet)\n// ..\n// now we know the block needs to be a scope\nlet thisIsNowAScope = true;\nfor (let i = 0; i &lt; 5; i++) {\n// this is also a scope, activated each\n// iteration\nif (i % 2 == 0) {\n// this is just a block, not a scope\nconsole.log(i);\n}\n}\n}\n// 0 2 4\n</code></pre> <p>Not all <code>{ .. }</code> curly-brace pairs create blocks (and thus are eligible to become scopes):</p> <ul> <li> <p>Object literals use <code>{ .. }</code> curly-brace pairs to delimit their key-value lists, but such object values are not scopes.</p> </li> <li> <p><code>class</code> uses <code>{ .. }</code> curly-braces around its body definition, but this is not a block or scope.</p> </li> <li> <p>A <code>function</code> uses <code>{ .. }</code> around its body, but this is not technically a block\u2014it's a single statement for the function body. It is, however, a (function) scope.</p> </li> <li> <p>The <code>{ .. }</code> curly-brace pair on a <code>switch</code> statement (around the set of <code>case</code> clauses) does not define a block/scope.</p> </li> </ul> <p>Other than such non-block examples, a <code>{ .. }</code> curly-brace pair can define a block attached to a statement (like an <code>if</code> or <code>for</code>), or stand alone by itself\u2014see the outermost <code>{ .. }</code> curly brace pair in the previous snippet. An explicit block of this sort\u2014if it has no declarations, it's not actually a scope\u2014serves no operational purpose, though it can still be useful as a semantic signal.</p> <p>Explicit standalone <code>{ .. }</code> blocks have always been valid JS syntax, but since they couldn't be a scope prior to ES6's <code>let</code>/<code>const</code>, they are quite rare. However, post ES6, they're starting to catch on a little bit.</p> <p>In most languages that support block scoping, an explicit block scope is an extremely common pattern for creating a narrow slice of scope for one or a few variables. So following the POLE principle, we should embrace this pattern more widespread in JS as well; use (explicit) block scoping to narrow the exposure of identifiers to the minimum practical.</p> <p>An explicit block scope can be useful even inside of another block (whether the outer block is a scope or not).</p> <p>For example:</p> <pre><code>if (somethingHappened) {\n// this is a block, but not a scope\n{\n// this is both a block and an\n// explicit scope\nlet msg = somethingHappened.message();\nnotifyOthers(msg);\n}\n// ..\nrecoverFromSomething();\n}\n</code></pre> <p>Here, the <code>{ .. }</code> curly-brace pair inside the <code>if</code> statement is an even smaller inner explicit block scope for <code>msg</code>, since that variable is not needed for the entire <code>if</code> block. Most developers would just block-scope <code>msg</code> to the <code>if</code> block and move on. And to be fair, when there's only a few lines to consider, it's a toss-up judgement call. But as code grows, these over-exposure issues become more pronounced.</p> <p>So does it matter enough to add the extra <code>{ .. }</code> pair and indentation level? I think you should follow POLE and always (within reason!) define the smallest block for each variable. So I recommend using the extra explicit block scope as shown.</p> <p>Recall the discussion of TDZ errors from \"Uninitialized Variables (TDZ)\" (Chapter 5). My suggestion there was: to minimize the risk of TDZ errors with <code>let</code>/<code>const</code> declarations, always put those declarations at the top of their scope.</p> <p>If you find yourself placing a <code>let</code> declaration in the middle of a scope, first think, \"Oh, no! TDZ alert!\" If this <code>let</code> declaration isn't needed in the first half of that block, you should use an inner explicit block scope to further narrow its exposure!</p> <p>Another example with an explicit block scope:</p> <pre><code>function getNextMonthStart(dateStr) {\nvar nextMonth, year;\n{\nlet curMonth;\n[ , year, curMonth ] = dateStr.match(\n/(\\d{4})-(\\d{2})-\\d{2}/\n) || [];\nnextMonth = (Number(curMonth) % 12) + 1;\n}\nif (nextMonth == 1) {\nyear++;\n}\nreturn `${ year }-${\nString(nextMonth).padStart(2,\"0\")\n}-01`;\n}\ngetNextMonthStart(\"2019-12-25\");   // 2020-01-01\n</code></pre> <p>Let's first identify the scopes and their identifiers:</p> <ol> <li> <p>The outer/global scope has one identifier, the function <code>getNextMonthStart(..)</code>.</p> </li> <li> <p>The function scope for <code>getNextMonthStart(..)</code> has three: <code>dateStr</code> (parameter), <code>nextMonth</code>, and <code>year</code>.</p> </li> <li> <p>The <code>{ .. }</code> curly-brace pair defines an inner block scope that includes one variable: <code>curMonth</code>.</p> </li> </ol> <p>So why put <code>curMonth</code> in an explicit block scope instead of just alongside <code>nextMonth</code> and <code>year</code> in the top-level function scope? Because <code>curMonth</code> is only needed for those first two statements; at the function scope level it's over-exposed.</p> <p>This example is small, so the hazards of over-exposing <code>curMonth</code> are pretty limited. But the benefits of the POLE principle are best achieved when you adopt the mindset of minimizing scope exposure by default, as a habit. If you follow the principle consistently even in the small cases, it will serve you more as your programs grow.</p> <p>Let's now look at an even more substantial example:</p> <pre><code>function sortNamesByLength(names) {\nvar buckets = [];\nfor (let firstName of names) {\nif (buckets[firstName.length] == null) {\nbuckets[firstName.length] = [];\n}\nbuckets[firstName.length].push(firstName);\n}\n// a block to narrow the scope\n{\nlet sortedNames = [];\nfor (let bucket of buckets) {\nif (bucket) {\n// sort each bucket alphanumerically\nbucket.sort();\n// append the sorted names to our\n// running list\nsortedNames = [\n...sortedNames,\n...bucket\n];\n}\n}\nreturn sortedNames;\n}\n}\nsortNamesByLength([\n\"Sally\",\n\"Suzy\",\n\"Frank\",\n\"John\",\n\"Jennifer\",\n\"Scott\"\n]);\n// [ \"John\", \"Suzy\", \"Frank\", \"Sally\",\n//   \"Scott\", \"Jennifer\" ]\n</code></pre> <p>There are six identifiers declared across five different scopes. Could all of these variables have existed in the single outer/global scope? Technically, yes, since they're all uniquely named and thus have no name collisions. But this would be really poor code organization, and would likely lead to both confusion and future bugs.</p> <p>We split them out into each inner nested scope as appropriate. Each variable is defined at the innermost scope possible for the program to operate as desired.</p> <p><code>sortedNames</code> could have been defined in the top-level function scope, but it's only needed for the second half of this function. To avoid over-exposing that variable in a higher level scope, we again follow POLE and block-scope it in the inner explicit block scope.</p>"},{"location":"scope-closures/ch6/#var-and-let","title":"<code>var</code> and <code>let</code>","text":"<p>Next, let's talk about the declaration <code>var buckets</code>. That variable is used across the entire function (except the final <code>return</code> statement). Any variable that is needed across all (or even most) of a function should be declared so that such usage is obvious.</p> NOTE: The parameter <code>names</code> isn't used across the whole function, but there's no way limit the scope of a parameter, so it behaves as a function-wide declaration regardless. <p>So why did we use <code>var</code> instead of <code>let</code> to declare the <code>buckets</code> variable? There's both semantic and technical reasons to choose <code>var</code> here.</p> <p>Stylistically, <code>var</code> has always, from the earliest days of JS, signaled \"variable that belongs to a whole function.\" As we asserted in \"Lexical Scope\" (Chapter 1), <code>var</code> attaches to the nearest enclosing function scope, no matter where it appears. That's true even if <code>var</code> appears inside a block:</p> <pre><code>function diff(x,y) {\nif (x &gt; y) {\nvar tmp = x;    // `tmp` is function-scoped\nx = y;\ny = tmp;\n}\nreturn y - x;\n}\n</code></pre> <p>Even though <code>var</code> is inside a block, its declaration is function-scoped (to <code>diff(..)</code>), not block-scoped.</p> <p>While you can declare <code>var</code> inside a block (and still have it be function-scoped), I would recommend against this approach except in a few specific cases (discussed in Appendix A). Otherwise, <code>var</code> should be reserved for use in the top-level scope of a function.</p> <p>Why not just use <code>let</code> in that same location? Because <code>var</code> is visually distinct from <code>let</code> and therefore signals clearly, \"this variable is function-scoped.\" Using <code>let</code> in the top-level scope, especially if not in the first few lines of a function, and when all the other declarations in blocks use <code>let</code>, does not visually draw attention to the difference with the function-scoped declaration.</p> <p>In other words, I feel <code>var</code> better communicates function-scoped than <code>let</code> does, and <code>let</code> both communicates (and achieves!) block-scoping where <code>var</code> is insufficient. As long as your programs are going to need both function-scoped and block-scoped variables, the most sensible and readable approach is to use both <code>var</code> and <code>let</code> together, each for their own best purpose.</p> <p>There are other semantic and operational reasons to choose <code>var</code> or <code>let</code> in different scenarios. We'll explore the case for <code>var</code> and <code>let</code> in more detail in Appendix A.</p> WARNING: My recommendation to use both <code>var</code> and <code>let</code> is clearly controversial and contradicts the majority. It's far more common to hear assertions like, \"var is broken, let fixes it\" and, \"never use var, let is the replacement.\" Those opinions are valid, but they're merely opinions, just like mine. <code>var</code> is not factually broken or deprecated; it has worked since early JS and it will continue to work as long as JS is around."},{"location":"scope-closures/ch6/#where-to-let","title":"Where To <code>let</code>?","text":"<p>My advice to reserve <code>var</code> for (mostly) only a top-level function scope means that most other declarations should use <code>let</code>. But you may still be wondering how to decide where each declaration in your program belongs?</p> <p>POLE already guides you on those decisions, but let's make sure we explicitly state it. The way to decide is not based on which keyword you want to use. The way to decide is to ask, \"What is the most minimal scope exposure that's sufficient for this variable?\"</p> <p>Once that is answered, you'll know if a variable belongs in a block scope or the function scope. If you decide initially that a variable should be block-scoped, and later realize it needs to be elevated to be function-scoped, then that dictates a change not only in the location of that variable's declaration, but also the declarator keyword used. The decision-making process really should proceed like that.</p> <p>If a declaration belongs in a block scope, use <code>let</code>. If it belongs in the function scope, use <code>var</code> (again, just my opinion).</p> <p>But another way to sort of visualize this decision making is to consider the pre-ES6 version of a program. For example, let's recall <code>diff(..)</code> from earlier:</p> <pre><code>function diff(x,y) {\nvar tmp;\nif (x &gt; y) {\ntmp = x;\nx = y;\ny = tmp;\n}\nreturn y - x;\n}\n</code></pre> <p>In this version of <code>diff(..)</code>, <code>tmp</code> is clearly declared in the function scope. Is that appropriate for <code>tmp</code>? I would argue, no. <code>tmp</code> is only needed for those few statements. It's not needed for the <code>return</code> statement. It should therefore be block-scoped.</p> <p>Prior to ES6, we didn't have <code>let</code> so we couldn't actually block-scope it. But we could do the next-best thing in signaling our intent:</p> <pre><code>function diff(x,y) {\nif (x &gt; y) {\n// `tmp` is still function-scoped, but\n// the placement here semantically\n// signals block-scoping\nvar tmp = x;\nx = y;\ny = tmp;\n}\nreturn y - x;\n}\n</code></pre> <p>Placing the <code>var</code> declaration for <code>tmp</code> inside the <code>if</code> statement signals to the reader of the code that <code>tmp</code> belongs to that block. Even though JS doesn't enforce that scoping, the semantic signal still has benefit for the reader of your code.</p> <p>Following this perspective, you can find any <code>var</code> that's inside a block of this sort and switch it to <code>let</code> to enforce the semantic signal already being sent. That's proper usage of <code>let</code> in my opinion.</p> <p>Another example that was historically based on <code>var</code> but which should now pretty much always use <code>let</code> is the <code>for</code> loop:</p> <pre><code>for (var i = 0; i &lt; 5; i++) {\n// do something\n}\n</code></pre> <p>No matter where such a loop is defined, the <code>i</code> should basically always be used only inside the loop, in which case POLE dictates it should be declared with <code>let</code> instead of <code>var</code>:</p> <pre><code>for (let i = 0; i &lt; 5; i++) {\n// do something\n}\n</code></pre> <p>Almost the only case where switching a <code>var</code> to a <code>let</code> in this way would \"break\" your code is if you were relying on accessing the loop's iterator (<code>i</code>) outside/after the loop, such as:</p> <pre><code>for (var i = 0; i &lt; 5; i++) {\nif (checkValue(i)) {\nbreak;\n}\n}\nif (i &lt; 5) {\nconsole.log(\"The loop stopped early!\");\n}\n</code></pre> <p>This usage pattern is not terribly uncommon, but most feel it smells like poor code structure. A preferable approach is to use another outer-scoped variable for that purpose:</p> <pre><code>var lastI;\nfor (let i = 0; i &lt; 5; i++) {\nlastI = i;\nif (checkValue(i)) {\nbreak;\n}\n}\nif (lastI &lt; 5) {\nconsole.log(\"The loop stopped early!\");\n}\n</code></pre> <p><code>lastI</code> is needed across this whole scope, so it's declared with <code>var</code>. <code>i</code> is only needed in (each) loop iteration, so it's declared with <code>let</code>.</p>"},{"location":"scope-closures/ch6/#whats-the-catch","title":"What's the Catch?","text":"<p>So far we've asserted that <code>var</code> and parameters are function-scoped, and <code>let</code>/<code>const</code> signal block-scoped declarations. There's one little exception to call out: the <code>catch</code> clause.</p> <p>Since the introduction of <code>try..catch</code> back in ES3 (in 1999), the <code>catch</code> clause has used an additional (little-known) block-scoping declaration capability:</p> <pre><code>try {\ndoesntExist();\n}\ncatch (err) {\nconsole.log(err);\n// ReferenceError: 'doesntExist' is not defined\n// ^^^^ message printed from the caught exception\nlet onlyHere = true;\nvar outerVariable = true;\n}\nconsole.log(outerVariable);     // true\nconsole.log(err);\n// ReferenceError: 'err' is not defined\n// ^^^^ this is another thrown (uncaught) exception\n</code></pre> <p>The <code>err</code> variable declared by the <code>catch</code> clause is block-scoped to that block. This <code>catch</code> clause block can hold other block-scoped declarations via <code>let</code>. But a <code>var</code> declaration inside this block still attaches to the outer function/global scope.</p> <p>ES2019 (recently, at the time of writing) changed <code>catch</code> clauses so their declaration is optional; if the declaration is omitted, the <code>catch</code> block is no longer (by default) a scope; it's still a block, though!</p> <p>So if you need to react to the condition that an exception occurred (so you can gracefully recover), but you don't care about the error value itself, you can omit the <code>catch</code> declaration:</p> <pre><code>try {\ndoOptionOne();\n}\ncatch {   // catch-declaration omitted\ndoOptionTwoInstead();\n}\n</code></pre> <p>This is a small but delightful simplification of syntax for a fairly common use case, and may also be slightly more performant in removing an unnecessary scope!</p>"},{"location":"scope-closures/ch6/#function-declarations-in-blocks-fib","title":"Function Declarations in Blocks (FiB)","text":"<p>We've seen now that declarations using <code>let</code> or <code>const</code> are block-scoped, and <code>var</code> declarations are function-scoped. So what about <code>function</code> declarations that appear directly inside blocks? As a feature, this is called \"FiB.\"</p> <p>We typically think of <code>function</code> declarations like they're the equivalent of a <code>var</code> declaration. So are they function-scoped like <code>var</code> is?</p> <p>No and yes. I know... that's confusing. Let's dig in:</p> <pre><code>if (false) {\nfunction ask() {\nconsole.log(\"Does this run?\");\n}\n}\nask();\n</code></pre> <p>What do you expect for this program to do? Three reasonable outcomes:</p> <ol> <li> <p>The <code>ask()</code> call might fail with a <code>ReferenceError</code> exception, because the <code>ask</code> identifier is block-scoped to the <code>if</code> block scope and thus isn't available in the outer/global scope.</p> </li> <li> <p>The <code>ask()</code> call might fail with a <code>TypeError</code> exception, because the <code>ask</code> identifier exists, but it's <code>undefined</code> (since the <code>if</code> statement doesn't run) and thus not a callable function.</p> </li> <li> <p>The <code>ask()</code> call might run correctly, printing out the \"Does it run?\" message.</p> </li> </ol> <p>Here's the confusing part: depending on which JS environment you try that code snippet in, you may get different results! This is one of those few crazy areas where existing legacy behavior betrays a predictable outcome.</p> <p>The JS specification says that <code>function</code> declarations inside of blocks are block-scoped, so the answer should be (1). However, most browser-based JS engines (including v8, which comes from Chrome but is also used in Node) will behave as (2), meaning the identifier is scoped outside the <code>if</code> block but the function value is not automatically initialized, so it remains <code>undefined</code>.</p> <p>Why are browser JS engines allowed to behave contrary to the specification? Because these engines already had certain behaviors around FiB before ES6 introduced block scoping, and there was concern that changing to adhere to the specification might break some existing website JS code. As such, an exception was made in Appendix B of the JS specification, which allows certain deviations for browser JS engines (only!).</p> NOTE: You wouldn't typically categorize Node as a browser JS environment, since it usually runs on a server. But Node's v8 engine is shared with Chrome (and Edge) browsers. Since v8 is first a browser JS engine, it adopts this Appendix B exception, which then means that the browser exceptions are extended to Node. <p>One of the most common use cases for placing a <code>function</code> declaration in a block is to conditionally define a function one way or another (like with an <code>if..else</code> statement) depending on some environment state. For example:</p> <pre><code>if (typeof Array.isArray != \"undefined\") {\nfunction isArray(a) {\nreturn Array.isArray(a);\n}\n}\nelse {\nfunction isArray(a) {\nreturn Object.prototype.toString.call(a)\n== \"[object Array]\";\n}\n}\n</code></pre> <p>It's tempting to structure code this way for performance reasons, since the <code>typeof Array.isArray</code> check is only performed once, as opposed to defining just one <code>isArray(..)</code> and putting the <code>if</code> statement inside it\u2014the check would then run unnecessarily on every call.</p> WARNING: In addition to the risks of FiB deviations, another problem with conditional-definition of functions is it's harder to debug such a program. If you end up with a bug in the <code>isArray(..)</code> function, you first have to figure out which <code>isArray(..)</code> implementation is actually running! Sometimes, the bug is that the wrong one was applied because the conditional check was incorrect! If you define multiple versions of a function, that program is always harder to reason about and maintain. <p>In addition to the previous snippets, several other FiB corner cases are lurking; such behaviors in various browsers and non-browser JS environments (JS engines that aren't browser based) will likely vary. For example:</p> <pre><code>if (true) {\nfunction ask() {\nconsole.log(\"Am I called?\");\n}\n}\nif (true) {\nfunction ask() {\nconsole.log(\"Or what about me?\");\n}\n}\nfor (let i = 0; i &lt; 5; i++) {\nfunction ask() {\nconsole.log(\"Or is it one of these?\");\n}\n}\nask();\nfunction ask() {\nconsole.log(\"Wait, maybe, it's this one?\");\n}\n</code></pre> <p>Recall that function hoisting as described in \"When Can I Use a Variable?\" (in Chapter 5) might suggest that the final <code>ask()</code> in this snippet, with \"Wait, maybe...\" as its message, would hoist above the call to <code>ask()</code>. Since it's the last function declaration of that name, it should \"win,\" right? Unfortunately, no.</p> <p>It's not my intention to document all these weird corner cases, nor to try to explain why each of them behaves a certain way. That information is, in my opinion, arcane legacy trivia.</p> <p>My real concern with FiB is, what advice can I give to ensure your code behaves predictably in all circumstances?</p> <p>As far as I'm concerned, the only practical answer to avoiding the vagaries of FiB is to simply avoid FiB entirely. In other words, never place a <code>function</code> declaration directly inside any block. Always place <code>function</code> declarations anywhere in the top-level scope of a function (or in the global scope).</p> <p>So for the earlier <code>if..else</code> example, my suggestion is to avoid conditionally defining functions if at all possible. Yes, it may be slightly less performant, but this is the better overall approach:</p> <pre><code>function isArray(a) {\nif (typeof Array.isArray != \"undefined\") {\nreturn Array.isArray(a);\n}\nelse {\nreturn Object.prototype.toString.call(a)\n== \"[object Array]\";\n}\n}\n</code></pre> <p>If that performance hit becomes a critical path issue for your application, I suggest you consider this approach:</p> <pre><code>var isArray = function isArray(a) {\nreturn Array.isArray(a);\n};\n// override the definition, if you must\nif (typeof Array.isArray == \"undefined\") {\nisArray = function isArray(a) {\nreturn Object.prototype.toString.call(a)\n== \"[object Array]\";\n};\n}\n</code></pre> <p>It's important to notice that here I'm placing a <code>function</code> expression, not a declaration, inside the <code>if</code> statement. That's perfectly fine and valid, for <code>function</code> expressions to appear inside blocks. Our discussion about FiB is about avoiding <code>function</code> declarations in blocks.</p> <p>Even if you test your program and it works correctly, the small benefit you may derive from using FiB style in your code is far outweighed by the potential risks in the future for confusion by other developers, or variances in how your code runs in other JS environments.</p> <p>FiB is not worth it, and should be avoided.</p>"},{"location":"scope-closures/ch6/#blocked-over","title":"Blocked Over","text":"<p>The point of LEXICAL scoping rules in a programming language is so we can appropriately organize our program's variables, both for operational as well as semantic code communication purposes.</p> <p>And one of the most important organizational techniques is to ensure that no variable is over-exposed to unnecessary scopes (POLE). Hopefully you now appreciate block scoping much more deeply than before.</p> <p>Hopefully by now you feel like you're standing on much more solid ground with understanding LEXICAL scope. From that base, the next chapter jumps into the weighty topic of closure.</p> <ol> <li> <p>Principle of Least Privilege, https://en.wikipedia.org/wiki/Principle_of_least_privilege, 3 March 2020.\u00a0\u21a9</p> </li> </ol>"},{"location":"scope-closures/ch7/","title":"Chapter 7: Using Closures","text":"<p>closures_bard.md</p> <p>Up to this point, we've focused on the ins and outs of LEXICAL scope, and how that affects the organization and usage of variables in our programs.</p> <p>Our attention again shifts broader in abstraction, to the historically somewhat daunting topic of closure. Don't worry! You don't need an advanced computer science degree to make sense of it. Our broad goal in this book is not merely to understand scope, but to more effectively use it in the structure of our programs; closure is central to that effort.</p> <p>Recall the main conclusion of Chapter 6: the least exposure principle (POLE) encourages us to use block (and function) scoping to limit the scope exposure of variables. This helps keep code understandable and maintainable, and helps avoid many scoping pitfalls (i.e., name collision, etc.).</p> <p>Closure builds on this approach: for variables we need to use over time, instead of placing them in larger outer scopes, we can encapsulate (more narrowly scope) them but still preserve access from inside functions, for broader use. Functions remember these referenced scoped variables via closure.</p> <p>We already saw an example of this kind of closure in the previous chapter (<code>factorial(..)</code> in Chapter 6), and you've almost certainly already used it in your own programs. If you've ever written a callback that accesses variables outside its own scope... guess what!? That's closure.</p> <p>Closure is one of the most important language characteristics ever invented in programming\u2014it underlies major programming paradigms, including Functional Programming (FP), modules, and even a bit of class-oriented design. Getting comfortable with closure is required for mastering JS and effectively leveraging many important design patterns throughout your code.</p> <p>Addressing all aspects of closure requires a daunting mountain of discussion and code throughout this chapter. Make sure to take your time and ensure you're comfortable with each bit before moving onto the next.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#see-the-closure","title":"See the Closure","text":"<p>Closure is originally a mathematical concept, from lambda calculus. But I'm not going to list out math formulas or use a bunch of notation and jargon to define it.</p> <p>Instead, I'm going to focus on a practical perspective. We'll start by defining closure in terms of what we can observe in different behavior of our programs, as opposed to if closure was not present in JS. However, later in this chapter, we're going to flip closure around to look at it from an alternative perspective.</p> <p>Closure is a behavior of functions and only functions. If you aren't dealing with a function, closure does not apply. An object cannot have closure, nor does a class have closure (though its functions/methods might). Only functions have closure.</p> <p>For closure to be observed, a function must be invoked, and specifically it must be invoked in a different branch of the scope chain from where it was originally defined. A function executing in the same scope it was defined would not exhibit any observably different behavior with or without closure being possible; by the observational perspective and definition, that is not closure.</p> <p>Let's look at some code, annotated with its relevant scope bubble colors (see Chapter 2):</p> <pre><code>// outer/global scope: RED(1)\nfunction lookupStudent(studentID) {\n// function scope: BLUE(2)\nvar students = [\n{ id: 14, name: \"Kyle\" },\n{ id: 73, name: \"Suzy\" },\n{ id: 112, name: \"Frank\" },\n{ id: 6, name: \"Sarah\" }\n];\nreturn function greetStudent(greeting){\n// function scope: GREEN(3)\nvar student = students.find(\nstudent =&gt; student.id == studentID\n);\nreturn `${ greeting }, ${ student.name }!`;\n};\n}\nvar chosenStudents = [\nlookupStudent(6),\nlookupStudent(112)\n];\n// accessing the function's name:\nchosenStudents[0].name;\n// greetStudent\nchosenStudents[0](\"Hello\");\n// Hello, Sarah!\nchosenStudents[1](\"Howdy\");\n// Howdy, Frank!\n</code></pre> <p>The first thing to notice about this code is that the <code>lookupStudent(..)</code> outer function creates and returns an inner function called <code>greetStudent(..)</code>. <code>lookupStudent(..)</code> is called twice, producing two separate instances of its inner <code>greetStudent(..)</code> function, both of which are saved into the <code>chosenStudents</code> array.</p> <p>We verify that's the case by checking the <code>.name</code> property of the returned function saved in <code>chosenStudents[0]</code>, and it's indeed an instance of the inner <code>greetStudent(..)</code>.</p> <p>After each call to <code>lookupStudent(..)</code> finishes, it would seem like all its inner variables would be discarded and GC'd (garbage collected). The inner function is the only thing that seems to be returned and preserved. But here's where the behavior differs in ways we can start to observe.</p> <p>While <code>greetStudent(..)</code> does receive a single argument as the parameter named <code>greeting</code>, it also makes reference to both <code>students</code> and <code>studentID</code>, identifiers which come from the enclosing scope of <code>lookupStudent(..)</code>. Each of those references from the inner function to the variable in an outer scope is called a closure. In academic terms, each instance of <code>greetStudent(..)</code> closes over the outer variables <code>students</code> and <code>studentID</code>.</p> <p>So what do those closures do here, in a concrete, observable sense?</p> <p>Closure allows <code>greetStudent(..)</code> to continue to access those outer variables even after the outer scope is finished (when each call to <code>lookupStudent(..)</code> completes). Instead of the instances of <code>students</code> and <code>studentID</code> being GC'd, they stay around in memory. At a later time when either instance of the <code>greetStudent(..)</code> function is invoked, those variables are still there, holding their current values.</p> <p>If JS functions did not have closure, the completion of each <code>lookupStudent(..)</code> call would immediately tear down its scope and GC the <code>students</code> and <code>studentID</code> variables. When we later called one of the <code>greetStudent(..)</code> functions, what would then happen?</p> <p>If <code>greetStudent(..)</code> tried to access what it thought was a BLUE(2) marble, but that marble did not actually exist (anymore), the reasonable assumption is we should get a <code>ReferenceError</code>, right?</p> <p>But we don't get an error. The fact that the execution of <code>chosenStudents[0](\"Hello\")</code> works and returns us the message \"Hello, Sarah!\", means it was still able to access the <code>students</code> and <code>studentID</code> variables. This is a direct observation of closure!</p>","tags":["closures"]},{"location":"scope-closures/ch7/#pointed-closure","title":"Pointed Closure","text":"<p>Actually, we glossed over a little detail in the previous discussion which I'm guessing many readers missed!</p> <p>Because of how terse the syntax for <code>=&gt;</code> arrow functions is, it's easy to forget that they still create a scope (as asserted in \"Arrow Functions\" in Chapter 3). The <code>student =&gt; student.id == studentID</code> arrow function is creating another scope bubble inside the <code>greetStudent(..)</code> function scope.</p> <p>Building on the metaphor of colored buckets and bubbles from Chapter 2, if we were creating a colored diagram for this code, there's a fourth scope at this innermost nesting level, so we'd need a fourth color; perhaps we'd pick ORANGE(4) for that scope:</p> <pre><code>var student = students.find(\nstudent =&gt;\n// function scope: ORANGE(4)\nstudent.id == studentID\n);\n</code></pre> <p>The BLUE(2) <code>studentID</code> reference is actually inside the ORANGE(4) scope rather than the GREEN(3) scope of <code>greetStudent(..)</code>; also, the <code>student</code> parameter of the arrow function is ORANGE(4), shadowing the GREEN(3) <code>student</code>.</p> <p>The consequence here is that this arrow function passed as a callback to the array's <code>find(..)</code> method has to hold the closure over <code>studentID</code>, rather than <code>greetStudent(..)</code> holding that closure. That's not too big of a deal, as everything still works as expected. It's just important not to skip over the fact that even tiny arrow functions can get in on the closure party.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#adding-up-closures","title":"Adding Up Closures","text":"<p>Let's examine one of the canonical examples often cited for closure:</p> <pre><code>function adder(num1) {\nreturn function addTo(num2){\nreturn num1 + num2;\n};\n}\nvar add10To = adder(10);\nvar add42To = adder(42);\nadd10To(15);    // 25\nadd42To(9);     // 51\n</code></pre> <p>Each instance of the inner <code>addTo(..)</code> function is closing over its own <code>num1</code> variable (with values <code>10</code> and <code>42</code>, respectively), so those <code>num1</code>'s don't go away just because <code>adder(..)</code> finishes. When we later invoke one of those inner <code>addTo(..)</code> instances, such as the <code>add10To(15)</code> call, its closed-over <code>num1</code> variable still exists and still holds the original <code>10</code> value. The operation is thus able to perform <code>10 + 15</code> and return the answer <code>25</code>.</p> <p>An important detail might have been too easy to gloss over in that previous paragraph, so let's reinforce it: closure is associated with an instance of a function, rather than its single LEXICAL definition. In the preceding snippet, there's just one inner <code>addTo(..)</code> function defined inside <code>adder(..)</code>, so it might seem like that would imply a single closure.</p> <p>But actually, every time the outer <code>adder(..)</code> function runs, a new inner <code>addTo(..)</code> function instance is created, and for each new instance, a new closure. So each inner function instance (labeled <code>add10To(..)</code> and <code>add42To(..)</code> in our program) has its own closure over its own instance of the scope environment from that execution of <code>adder(..)</code>.</p> <p>Even though closure is based on LEXICAL scope, which is handled at compile time, closure is observed as a runtime characteristic of function instances.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#live-link-not-a-snapshot","title":"Live Link, Not a Snapshot","text":"<p>In both examples from the previous sections, we read the value from a variable that was held in a closure. That makes it feel like closure might be a snapshot of a value at some given moment. Indeed, that's a common misconception.</p> <p>Closure is actually a live link, preserving access to the full variable itself. We're not limited to merely reading a value; the closed-over variable can be updated (re-assigned) as well! By closing over a variable in a function, we can keep using that variable (read and write) as long as that function reference exists in the program, and from anywhere we want to invoke that function. This is why closure is such a powerful technique used widely across so many areas of programming!</p> <p>Figure 4 depicts the function instances and scope links:</p> Fig. 4: Visualizing Closures <p>As shown in Figure 4, each call to <code>adder(..)</code> creates a new BLUE(2) scope containing a <code>num1</code> variable, as well as a new instance of <code>addTo(..)</code> function as a GREEN(3) scope. Notice that the function instances (<code>addTo10(..)</code> and <code>addTo42(..)</code>) are present in and invoked from the RED(1) scope.</p> <p>Now let's examine an example where the closed-over variable is updated:</p> <pre><code>function makeCounter() {\nvar count = 0;\nreturn function getCurrent() {\ncount = count + 1;\nreturn count;\n};\n}\nvar hits = makeCounter();\n// later\nhits();     // 1\n// later\nhits();     // 2\nhits();     // 3\n</code></pre> <p>The <code>count</code> variable is closed over by the inner <code>getCurrent()</code> function, which keeps it around instead of it being subjected to GC. The <code>hits()</code> function calls access and update this variable, returning an incrementing count each time.</p> <p>Though the enclosing scope of a closure is typically from a function, that's not actually required; there only needs to be an inner function present inside an outer scope:</p> <pre><code>var hits;\n{   // an outer scope (but not a function)\nlet count = 0;\nhits = function getCurrent(){\ncount = count + 1;\nreturn count;\n};\n}\nhits();     // 1\nhits();     // 2\nhits();     // 3\n</code></pre> NOTE: I deliberately defined <code>getCurrent()</code> as a <code>function</code> expression instead of a <code>function</code> declaration. This isn't about closure, but with the dangerous quirks of FiB (Chapter 6). <p>Because it's so common to mistake closure as value-oriented instead of variable-oriented, developers sometimes get tripped up trying to use closure to snapshot-preserve a value from some moment in time. Consider:</p> <pre><code>var studentName = \"Frank\";\nvar greeting = function hello() {\n// we are closing over `studentName`,\n// not \"Frank\"\nconsole.log(\n`Hello, ${ studentName }!`\n);\n}\n// later\nstudentName = \"Suzy\";\n// later\ngreeting();\n// Hello, Suzy!\n</code></pre> <p>By defining <code>greeting()</code> (aka, <code>hello()</code>) when <code>studentName</code> holds the value <code>\"Frank\"</code> (before the re-assignment to <code>\"Suzy\"</code>), the mistaken assumption is often that the closure will capture <code>\"Frank\"</code>. But <code>greeting()</code> is closed over the variable <code>studentName</code>, not its value. Whenever <code>greeting()</code> is invoked, the current value of the variable (<code>\"Suzy\"</code>, in this case) is reflected.</p> <p>The classic illustration of this mistake is defining functions inside a loop:</p> <pre><code>var keeps = [];\nfor (var i = 0; i &lt; 3; i++) {\nkeeps[i] = function keepI(){\n// closure over `i`\nreturn i;\n};\n}\nkeeps[0]();   // 3 -- WHY!?\nkeeps[1]();   // 3\nkeeps[2]();   // 3\n</code></pre> NOTE: This kind of closure illustration typically uses a <code>setTimeout(..)</code> or some other callback like an event handler, inside the loop. I've simplified the example by storing function references in an array, so that we don't need to consider asynchronous timing in our analysis. The closure principle is the same, regardless. <p>You might have expected the <code>keeps[0]()</code> invocation to return <code>0</code>, since that function was created during the first iteration of the loop when <code>i</code> was <code>0</code>. But again, that assumption stems from thinking of closure as value-oriented rather than variable-oriented.</p> <p>Something about the structure of a <code>for</code>-loop can trick us into thinking that each iteration gets its own new <code>i</code> variable; in fact, this program only has one <code>i</code> since it was declared with <code>var</code>.</p> <p>Each saved function returns <code>3</code>, because by the end of the loop, the single <code>i</code> variable in the program has been assigned <code>3</code>. Each of the three functions in the <code>keeps</code> array do have individual closures, but they're all closed over that same shared <code>i</code> variable.</p> <p>Of course, a single variable can only ever hold one value at any given moment. So if you want to preserve multiple values, you need a different variable for each.</p> <p>How could we do that in the loop snippet? Let's create a new variable for each iteration:</p> <pre><code>var keeps = [];\nfor (var i = 0; i &lt; 3; i++) {\n// new `j` created each iteration, which gets\n// a copy of the value of `i` at this moment\nlet j = i;\n// the `i` here isn't being closed over, so\n// it's fine to immediately use its current\n// value in each loop iteration\nkeeps[i] = function keepEachJ(){\n// close over `j`, not `i`!\nreturn j;\n};\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2\n</code></pre> <p>Each function is now closed over a separate (new) variable from each iteration, even though all of them are named <code>j</code>. And each <code>j</code> gets a copy of the value of <code>i</code> at that point in the loop iteration; that <code>j</code> never gets re-assigned. So all three functions now return their expected values: <code>0</code>, <code>1</code>, and <code>2</code>!</p> <p>Again remember, even if we were using asynchrony in this program, such as passing each inner <code>keepEachJ()</code> function into <code>setTimeout(..)</code> or some event handler subscription, the same kind of closure behavior would still be observed.</p> <p>Recall the \"Loops\" section in Chapter 5, which illustrates how a <code>let</code> declaration in a <code>for</code> loop actually creates not just one variable for the loop, but actually creates a new variable for each iteration of the loop. That trick/quirk is exactly what we need for our loop closures:</p> <pre><code>var keeps = [];\nfor (let i = 0; i &lt; 3; i++) {\n// the `let i` gives us a new `i` for\n// each iteration, automatically!\nkeeps[i] = function keepEachI(){\nreturn i;\n};\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2\n</code></pre> <p>Since we're using <code>let</code>, three <code>i</code>'s are created, one for each loop, so each of the three closures just work as expected.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#common-closures-ajax-and-events","title":"Common Closures: Ajax and Events","text":"<p>Closure is most commonly encountered with callbacks:</p> <pre><code>function lookupStudentRecord(studentID) {\najax(\n`https://some.api/student/${ studentID }`,\nfunction onRecord(record) {\nconsole.log(\n`${ record.name } (${ studentID })`\n);\n}\n);\n}\nlookupStudentRecord(114);\n// Frank (114)\n</code></pre> <p>The <code>onRecord(..)</code> callback is going to be invoked at some point in the future, after the response from the Ajax call comes back. This invocation will happen from the internals of the <code>ajax(..)</code> utility, wherever that comes from. Furthermore, when that happens, the <code>lookupStudentRecord(..)</code> call will long since have completed.</p> <p>Why then is <code>studentID</code> still around and accessible to the callback? Closure.</p> <p>Event handlers are another common usage of closure:</p> <pre><code>function listenForClicks(btn,label) {\nbtn.addEventListener(\"click\",function onClick(){\nconsole.log(\n`The ${ label } button was clicked!`\n);\n});\n}\nvar submitBtn = document.getElementById(\"submit-btn\");\nlistenForClicks(submitBtn,\"Checkout\");\n</code></pre> <p>The <code>label</code> parameter is closed over by the <code>onClick(..)</code> event handler callback. When the button is clicked, <code>label</code> still exists to be used. This is closure.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#what-if-i-cant-see-it","title":"What If I Can't See It?","text":"<p>You've probably heard this common adage:</p> <p>If a tree falls in the forest but nobody is around to hear it, does it make a sound?</p> <p>It's a silly bit of philosophical gymnastics. Of course from a scientific perspective, sound waves are created. But the real point: does it matter if the sound happens?</p> <p>Remember, the emphasis in our definition of closure is observability. If a closure exists (in a technical, implementation, or academic sense) but it cannot be observed in our programs, does it matter? No.</p> <p>To reinforce this point, let's look at some examples that are not observably based on closure.</p> <p>For example, invoking a function that makes use of LEXICAL scope lookup:</p> <pre><code>function say(myName) {\nvar greeting = \"Hello\";\noutput();\nfunction output() {\nconsole.log(\n`${ greeting }, ${ myName }!`\n);\n}\n}\nsay(\"Kyle\");\n// Hello, Kyle!\n</code></pre> <p>The inner function <code>output()</code> accesses the variables <code>greeting</code> and <code>myName</code> from its enclosing scope. But the invocation of <code>output()</code> happens in that same scope, where of course <code>greeting</code> and <code>myName</code> are still available; that's just LEXICAL scope, not closure.</p> <p>Any lexically scoped language whose functions didn't support closure would still behave this same way.</p> <p>In fact, global scope variables essentially cannot be (observably) closed over, because they're always accessible from everywhere. No function can ever be invoked in any part of the scope chain that is not a descendant of the global scope.</p> <p>Consider:</p> <pre><code>var students = [\n{ id: 14, name: \"Kyle\" },\n{ id: 73, name: \"Suzy\" },\n{ id: 112, name: \"Frank\" },\n{ id: 6, name: \"Sarah\" }\n];\nfunction getFirstStudent() {\nreturn function firstStudent(){\nreturn students[0].name;\n};\n}\nvar student = getFirstStudent();\nstudent();\n// Kyle\n</code></pre> <p>The inner <code>firstStudent()</code> function does reference <code>students</code>, which is a variable outside its own scope. But since <code>students</code> happens to be from the global scope, no matter where that function is invoked in the program, its ability to access <code>students</code> is nothing more special than normal LEXICAL scope.</p> <p>All function invocations can access global variables, regardless of whether closure is supported by the language or not. Global variables don't need to be closed over.</p> <p>Variables that are merely present but never accessed don't result in closure:</p> <pre><code>function lookupStudent(studentID) {\nreturn function nobody(){\nvar msg = \"Nobody's here yet.\";\nconsole.log(msg);\n};\n}\nvar student = lookupStudent(112);\nstudent();\n// Nobody's here yet.\n</code></pre> <p>The inner function <code>nobody()</code> doesn't close over any outer variables\u2014it only uses its own variable <code>msg</code>. Even though <code>studentID</code> is present in the enclosing scope, <code>studentID</code> is not referred to by <code>nobody()</code>. The JS engine doesn't need to keep <code>studentID</code> around after <code>lookupStudent(..)</code> has finished running, so GC wants to clean up that memory!</p> <p>Whether JS functions support closure or not, this program would behave the same. Therefore, no observed closure here.</p> <p>If there's no function invocation, closure can't be observed:</p> <pre><code>function greetStudent(studentName) {\nreturn function greeting(){\nconsole.log(\n`Hello, ${ studentName }!`\n);\n};\n}\ngreetStudent(\"Kyle\");\n// nothing else happens\n</code></pre> <p>This one's tricky, because the outer function definitely does get invoked. But the inner function is the one that could have had closure, and yet it's never invoked; the returned function here is just thrown away. So even if technically the JS engine created closure for a brief moment, it was not observed in any meaningful way in this program.</p> <p>A tree may have fallen... but we didn't hear it, so we don't care.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#observable-definition","title":"Observable Definition","text":"<p>We're now ready to define closure:</p> <p>Closure is observed when a function uses variable(s) from outer scope(s) even while running in a scope where those variable(s) wouldn't be accessible.</p> <p>The key parts of this definition are:</p> <ul> <li> <p>Must be a function involved</p> </li> <li> <p>Must reference at least one variable from an outer scope</p> </li> <li> <p>Must be invoked in a different branch of the scope chain from the variable(s)</p> </li> </ul> <p>This observation-oriented definition means we shouldn't dismiss closure as some indirect, academic trivia. Instead, we should look and plan for the direct, concrete effects closure has on our program behavior.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#the-closure-lifecycle-and-garbage-collection-gc","title":"The Closure Lifecycle and Garbage Collection (GC)","text":"<p>Since closure is inherently tied to a function instance, its closure over a variable lasts as long as there is still a reference to that function.</p> <p>If ten functions all close over the same variable, and over time nine of these function references are discarded, the lone remaining function reference still preserves that variable. Once that final function reference is discarded, the last closure over that variable is gone, and the variable itself is GC'd.</p> <p>This has an important impact on building efficient and performant programs. Closure can unexpectedly prevent the GC of a variable that you're otherwise done with, which leads to run-away memory usage over time. That's why it's important to discard function references (and thus their closures) when they're not needed anymore.</p> <p>Consider:</p> <pre><code>function manageBtnClickEvents(btn) {\nvar clickHandlers = [];\nreturn function listener(cb){\nif (cb) {\nlet clickHandler =\nfunction onClick(evt){\nconsole.log(\"clicked!\");\ncb(evt);\n};\nclickHandlers.push(clickHandler);\nbtn.addEventListener(\n\"click\",\nclickHandler\n);\n}\nelse {\n// passing no callback unsubscribes\n// all click handlers\nfor (let handler of clickHandlers) {\nbtn.removeEventListener(\n\"click\",\nhandler\n);\n}\nclickHandlers = [];\n}\n};\n}\n// var mySubmitBtn = ..\nvar onSubmit = manageBtnClickEvents(mySubmitBtn);\nonSubmit(function checkout(evt){\n// handle checkout\n});\nonSubmit(function trackAction(evt){\n// log action to analytics\n});\n// later, unsubscribe all handlers:\nonSubmit();\n</code></pre> <p>In this program, the inner <code>onClick(..)</code> function holds a closure over the passed in <code>cb</code> (the provided event callback). That means the <code>checkout()</code> and <code>trackAction()</code> function expression references are held via closure (and cannot be GC'd) for as long as these event handlers are subscribed.</p> <p>When we call <code>onSubmit()</code> with no input on the last line, all event handlers are unsubscribed, and the <code>clickHandlers</code> array is emptied. Once all click handler function references are discarded, the closures of <code>cb</code> references to <code>checkout()</code> and <code>trackAction()</code> are discarded.</p> <p>When considering the overall health and efficiency of the program, unsubscribing an event handler when it's no longer needed can be even more important than the initial subscription!</p>","tags":["closures"]},{"location":"scope-closures/ch7/#per-variable-or-per-scope","title":"Per Variable or Per Scope?","text":"<p>Another question we need to tackle: should we think of closure as applied only to the referenced outer variable(s), or does closure preserve the entire scope chain with all its variables?</p> <p>In other words, in the previous event subscription snippet, is the inner <code>onClick(..)</code> function closed over only <code>cb</code>, or is it also closed over <code>clickHandler</code>, <code>clickHandlers</code>, and <code>btn</code>?</p> <p>Conceptually, closure is per variable rather than per scope. Ajax callbacks, event handlers, and all other forms of function closures are typically assumed to close over only what they explicitly reference.</p> <p>But the reality is more complicated than that.</p> <p>Another program to consider:</p> <pre><code>function manageStudentGrades(studentRecords) {\nvar grades = studentRecords.map(getGrade);\nreturn addGrade;\n// ************************\nfunction getGrade(record){\nreturn record.grade;\n}\nfunction sortAndTrimGradesList() {\n// sort by grades, descending\ngrades.sort(function desc(g1,g2){\nreturn g2 - g1;\n});\n// only keep the top 10 grades\ngrades = grades.slice(0,10);\n}\nfunction addGrade(newGrade) {\ngrades.push(newGrade);\nsortAndTrimGradesList();\nreturn grades;\n}\n}\nvar addNextGrade = manageStudentGrades([\n{ id: 14, name: \"Kyle\", grade: 86 },\n{ id: 73, name: \"Suzy\", grade: 87 },\n{ id: 112, name: \"Frank\", grade: 75 },\n// ..many more records..\n{ id: 6, name: \"Sarah\", grade: 91 }\n]);\n// later\naddNextGrade(81);\naddNextGrade(68);\n// [ .., .., ... ]\n</code></pre> <p>The outer function <code>manageStudentGrades(..)</code> takes a list of student records, and returns an <code>addGrade(..)</code> function reference, which we externally label <code>addNextGrade(..)</code>. Each time we call <code>addNextGrade(..)</code> with a new grade, we get back a current list of the top 10 grades, sorted numerically descending (see <code>sortAndTrimGradesList()</code>).</p> <p>From the end of the original <code>manageStudentGrades(..)</code> call, and between the multiple <code>addNextGrade(..)</code> calls, the <code>grades</code> variable is preserved inside <code>addGrade(..)</code> via closure; that's how the running list of top grades is maintained. Remember, it's a closure over the variable <code>grades</code> itself, not the array it holds.</p> <p>That's not the only closure involved, however. Can you spot other variables being closed over?</p> <p>Did you spot that <code>addGrade(..)</code> references <code>sortAndTrimGradesList</code>? That means it's also closed over that identifier, which happens to hold a reference to the <code>sortAndTrimGradesList()</code> function. That second inner function has to stay around so that <code>addGrade(..)</code> can keep calling it, which also means any variables it closes over stick around\u2014though, in this case, nothing extra is closed over there.</p> <p>What else is closed over?</p> <p>Consider the <code>getGrade</code> variable (and its function); is it closed over? It's referenced in the outer scope of <code>manageStudentGrades(..)</code> in the <code>.map(getGrade)</code> call. But it's not referenced in <code>addGrade(..)</code> or <code>sortAndTrimGradesList()</code>.</p> <p>What about the (potentially) large list of student records we pass in as <code>studentRecords</code>? Is that variable closed over? If it is, the array of student records is never getting GC'd, which leads to this program holding onto a larger amount of memory than we might assume. But if we look closely again, none of the inner functions reference <code>studentRecords</code>.</p> <p>According to the per variable definition of closure, since <code>getGrade</code> and <code>studentRecords</code> are not referenced by the inner functions, they're not closed over. They should be freely available for GC right after the <code>manageStudentGrades(..)</code> call completes.</p> <p>Indeed, try debugging this code in a recent JS engine, like v8 in Chrome, placing a breakpoint inside the <code>addGrade(..)</code> function. You may notice that the inspector does not list the <code>studentRecords</code> variable. That's proof, debugging-wise anyway, that the engine does not maintain <code>studentRecords</code> via closure. Phew!</p> <p>But how reliable is this observation as proof? Consider this (rather contrived!) program:</p> <pre><code>function storeStudentInfo(id,name,grade) {\nreturn function getInfo(whichValue){\n// warning:\n//   using `eval(..)` is a bad idea!\nvar val = eval(whichValue);\nreturn val;\n};\n}\nvar info = storeStudentInfo(73,\"Suzy\",87);\ninfo(\"name\");\n// Suzy\ninfo(\"grade\");\n// 87\n</code></pre> <p>Notice that the inner function <code>getInfo(..)</code> is not explicitly closed over any of <code>id</code>, <code>name</code>, or <code>grade</code> variables. And yet, calls to <code>info(..)</code> seem to still be able to access the variables, albeit through use of the <code>eval(..)</code> LEXICAL scope cheat (see Chapter 1).</p> <p>So all the variables were definitely preserved via closure, despite not being explicitly referenced by the inner function. So does that disprove the per variable assertion in favor of per scope? Depends.</p> <p>Many modern JS engines do apply an optimization that removes any variables from a closure scope that aren't explicitly referenced. However, as we see with <code>eval(..)</code>, there are situations where such an optimization cannot be applied, and the closure scope continues to contain all its original variables. In other words, closure must be per scope, implementation wise, and then an optional optimization trims down the scope to only what was closed over (a similar outcome as per variable closure).</p> <p>Even as recent as a few years ago, many JS engines did not apply this optimization; it's possible your websites may still run in such browsers, especially on older or lower-end devices. That means it's possible that long-lived closures such as event handlers may be holding onto memory much longer than we would have assumed.</p> <p>And the fact that it's an optional optimization in the first place, rather than a requirement of the specification, means that we shouldn't just casually over-assume its applicability.</p> <p>In cases where a variable holds a large value (like an object or array) and that variable is present in a closure scope, if you don't need that value anymore and don't want that memory held, it's safer (memory usage) to manually discard the value rather than relying on closure optimization/GC.</p> <p>Let's apply a fix to the earlier <code>manageStudentGrades(..)</code> example to ensure the potentially large array held in <code>studentRecords</code> is not caught up in a closure scope unnecessarily:</p> <pre><code>function manageStudentGrades(studentRecords) {\nvar grades = studentRecords.map(getGrade);\n// unset `studentRecords` to prevent unwanted\n// memory retention in the closure\nstudentRecords = null;\nreturn addGrade;\n// ..\n}\n</code></pre> <p>We're not removing <code>studentRecords</code> from the closure scope; that we cannot control. We're ensuring that even if <code>studentRecords</code> remains in the closure scope, that variable is no longer referencing the potentially large array of data; the array can be GC'd.</p> <p>Again, in many cases JS might automatically optimize the program to the same effect. But it's still a good habit to be careful and explicitly make sure we don't keep any significant amount of device memory tied up any longer than necessary.</p> <p>As a matter of fact, we also technically don't need the function <code>getGrade()</code> anymore after the <code>.map(getGrade)</code> call completes. If profiling our application showed this was a critical area of excess memory use, we could possibly eek out a tiny bit more memory by freeing up that reference so its value isn't tied up either. That's likely unnecessary in this toy example, but this is a general technique to keep in mind if you're optimizing the memory footprint of your application.</p> <p>The takeaway: it's important to know where closures appear in our programs, and what variables are included. We should manage these closures carefully so we're only holding onto what's minimally needed and not wasting memory.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#an-alternative-perspective","title":"An Alternative Perspective","text":"<p>Reviewing our working definition for closure, the assertion is that functions are \"first-class values\" that can be passed around the program, just like any other value. Closure is the link-association that connects that function to the scope/variables outside of itself, no matter where that function goes.</p> <p>Let's recall a code example from earlier in this chapter, again with relevant scope bubble colors annotated:</p> <pre><code>// outer/global scope: RED(1)\nfunction adder(num1) {\n// function scope: BLUE(2)\nreturn function addTo(num2){\n// function scope: GREEN(3)\nreturn num1 + num2;\n};\n}\nvar add10To = adder(10);\nvar add42To = adder(42);\nadd10To(15);    // 25\nadd42To(9);     // 51\n</code></pre> <p>Our current perspective suggests that wherever a function is passed and invoked, closure preserves a hidden link back to the original scope to facilitate the access to the closed-over variables. Figure 4, repeated here for convenience, illustrates this notion:</p> Fig. 4 (repeat): Visualizing Closures <p>But there's another way of thinking about closure, and more precisely the nature of functions being passed around, that may help deepen the mental models.</p> <p>This alternative model de-emphasizes \"functions as first-class values,\" and instead embraces how functions (like all non-primitive values) are held by reference in JS, and assigned/passed by reference-copy\u2014see Appendix A of the Get Started book for more information.</p> <p>Instead of thinking about the inner function instance of <code>addTo(..)</code> moving to the outer RED(1) scope via the <code>return</code> and assignment, we can envision that function instances actually just stay in place in their own scope environment, of course with their scope-chain intact.</p> <p>What gets sent to the RED(1) scope is just a reference to the in-place function instance, rather than the function instance itself. Figure 5 depicts the inner function instances remaining in place, pointed to by the RED(1) <code>addTo10</code> and <code>addTo42</code> references, respectively:</p> Fig. 5: Visualizing Closures (Alternative) <p>As shown in Figure 5, each call to <code>adder(..)</code> still creates a new BLUE(2) scope containing a <code>num1</code> variable, as well as an instance of the GREEN(3) <code>addTo(..)</code> scope. But what's different from Figure 4 is, now these GREEN(3) instances remain in place, naturally nested inside of their BLUE(2) scope instances. The <code>addTo10</code> and <code>addTo42</code> references are moved to the RED(1) outer scope, not the function instances themselves.</p> <p>When <code>addTo10(15)</code> is called, the <code>addTo(..)</code> function instance (still in place in its original BLUE(2) scope environment) is invoked. Since the function instance itself never moved, of course it still has natural access to its scope chain. Same with the <code>addTo42(9)</code> call\u2014nothing special here beyond LEXICAL scope.</p> <p>So what then is closure, if not the magic that lets a function maintain a link to its original scope chain even as that function moves around in other scopes? In this alternative model, functions stay in place and keep accessing their original scope chain just like they always could.</p> <p>Closure instead describes the magic of keeping alive a function instance, along with its whole scope environment and chain, for as long as there's at least one reference to that function instance floating around in any other part of the program.</p> <p>That definition of closure is less observational and a bit less familiar-sounding compared to the traditional academic perspective. But it's nonetheless still useful, because the benefit is that we simplify explanation of closure to a straightforward combination of references and in-place function instances.</p> <p>The previous model (Figure 4) is not wrong at describing closure in JS. It's just more conceptually inspired, an academic perspective on closure. By contrast, the alternative model (Figure 5) could be described as a bit more implementation focused, how JS actually works.</p> <p>Both perspectives/models are useful in understanding closure, but the reader may find one a little easier to hold than the other. Whichever you choose, the observable outcomes in our program are the same.</p> NOTE: This alternative model for closure does affect whether we classify synchronous callbacks as examples of closure or not. More on this nuance in Appendix A.","tags":["closures"]},{"location":"scope-closures/ch7/#why-closure","title":"Why Closure?","text":"<p>Now that we have a well-rounded sense of what closure is and how it works, let's explore some ways it can improve the code structure and organization of an example program.</p> <p>Imagine you have a button on a page that when clicked, should retrieve and send some data via an Ajax request. Without using closure:</p> <pre><code>var APIendpoints = {\nstudentIDs:\n\"https://some.api/register-students\",\n// ..\n};\nvar data = {\nstudentIDs: [ 14, 73, 112, 6 ],\n// ..\n};\nfunction makeRequest(evt) {\nvar btn = evt.target;\nvar recordKind = btn.dataset.kind;\najax(\nAPIendpoints[recordKind],\ndata[recordKind]\n);\n}\n// &lt;button data-kind=\"studentIDs\"&gt;\n//    Register Students\n// &lt;/button&gt;\nbtn.addEventListener(\"click\",makeRequest);\n</code></pre> <p>The <code>makeRequest(..)</code> utility only receives an <code>evt</code> object from a click event. From there, it has to retrieve the <code>data-kind</code> attribute from the target button element, and use that value to lookup both a URL for the API endpoint as well as what data should be included in the Ajax request.</p> <p>This works OK, but it's unfortunate (inefficient, more confusing) that the event handler has to read a DOM attribute each time it's fired. Why couldn't an event handler remember this value? Let's try using closure to improve the code:</p> <pre><code>var APIendpoints = {\nstudentIDs:\n\"https://some.api/register-students\",\n// ..\n};\nvar data = {\nstudentIDs: [ 14, 73, 112, 6 ],\n// ..\n};\nfunction setupButtonHandler(btn) {\nvar recordKind = btn.dataset.kind;\nbtn.addEventListener(\n\"click\",\nfunction makeRequest(evt){\najax(\nAPIendpoints[recordKind],\ndata[recordKind]\n);\n}\n);\n}\n// &lt;button data-kind=\"studentIDs\"&gt;\n//    Register Students\n// &lt;/button&gt;\nsetupButtonHandler(btn);\n</code></pre> <p>With the <code>setupButtonHandler(..)</code> approach, the <code>data-kind</code> attribute is retrieved once and assigned to the <code>recordKind</code> variable at initial setup. <code>recordKind</code> is then closed over by the inner <code>makeRequest(..)</code> click handler, and its value is used on each event firing to look up the URL and data that should be sent.</p> NOTE: <code>evt</code> is still passed to <code>makeRequest(..)</code>, though in this case we're not using it anymore. It's still listed, for consistency with the previous snippet. <p>By placing <code>recordKind</code> inside <code>setupButtonHandler(..)</code>, we limit the scope exposure of that variable to a more appropriate subset of the program; storing it globally would have been worse for code organization and readability. Closure lets the inner <code>makeRequest()</code> function instance remember this variable and access whenever it's needed.</p> <p>Building on this pattern, we could have looked up both the URL and data once, at setup:</p> <pre><code>function setupButtonHandler(btn) {\nvar recordKind = btn.dataset.kind;\nvar requestURL = APIendpoints[recordKind];\nvar requestData = data[recordKind];\nbtn.addEventListener(\n\"click\",\nfunction makeRequest(evt){\najax(requestURL,requestData);\n}\n);\n}\n</code></pre> <p>Now <code>makeRequest(..)</code> is closed over <code>requestURL</code> and <code>requestData</code>, which is a little bit cleaner to understand, and also slightly more performant.</p> <p>Two similar techniques from the Functional Programming (FP) paradigm that rely on closure are partial application and currying. Briefly, with these techniques, we alter the shape of functions that require multiple inputs so some inputs are provided up front, and other inputs are provided later; the initial inputs are remembered via closure. Once all inputs have been provided, the underlying action is performed.</p> <p>By creating a function instance that encapsulates some information inside (via closure), the function-with-stored-information can later be used directly without needing to re-provide that input. This makes that part of the code cleaner, and also offers the opportunity to label partially applied functions with better semantic names.</p> <p>Adapting partial application, we can further improve the preceding code:</p> <pre><code>function defineHandler(requestURL,requestData) {\nreturn function makeRequest(evt){\najax(requestURL,requestData);\n};\n}\nfunction setupButtonHandler(btn) {\nvar recordKind = btn.dataset.kind;\nvar handler = defineHandler(\nAPIendpoints[recordKind],\ndata[recordKind]\n);\nbtn.addEventListener(\"click\",handler);\n}\n</code></pre> <p>The <code>requestURL</code> and <code>requestData</code> inputs are provided ahead of time, resulting in the <code>makeRequest(..)</code> partially applied function, which we locally label <code>handler</code>. When the event eventually fires, the final input (<code>evt</code>, even though it's ignored) is passed to <code>handler()</code>, completing its inputs and triggering the underlying Ajax request.</p> <p>Behavior-wise, this program is pretty similar to the previous one, with the same type of closure. But by isolating the creation of <code>makeRequest(..)</code> in a separate utility (<code>defineHandler(..)</code>), we make that definition more reusable across the program. We also explicitly limit the closure scope to only the two variables needed.</p>","tags":["closures"]},{"location":"scope-closures/ch7/#closer-to-closure","title":"Closer to Closure","text":"<p>As we close down a dense chapter, take some deep breaths let it all sink in. Seriously, that's a lot of information for anyone to consume!</p> <p>We explored two models for mentally tackling closure:</p> <ul> <li> <p>Observational: closure is a function instance remembering its outer variables even as that function is passed to and invoked in other scopes.</p> </li> <li> <p>Implementational: closure is a function instance and its scope environment preserved in-place while any references to it are passed around and invoked from other scopes.</p> </li> </ul> <p>Summarizing the benefits to our programs:</p> <ul> <li> <p>Closure can improve efficiency by allowing a function instance to remember previously determined information instead of having to compute it each time.</p> </li> <li> <p>Closure can improve code readability, bounding scope-exposure by encapsulating variable(s) inside function instances, while still making sure the information in those variables is accessible for future use. The resultant narrower, more specialized function instances are cleaner to interact with, since the preserved information doesn't need to be passed in every invocation.</p> </li> </ul> <p>Before you move on, take some time to restate this summary in your own words, explaining what closure is and why it's helpful in your programs. The main book text concludes with a final chapter that builds on top of closure with the module pattern.</p>","tags":["closures"]},{"location":"scope-closures/ch8/","title":"Chapter 8: The Module Pattern","text":"<p>In this chapter, we wrap up the main text of the book by exploring one of the most important code organization patterns in all of programming: the module. As we'll see, modules are inherently built from what we've already covered: the payoff for your efforts in learning LEXICAL scope and closure.</p> <p>We've examined every angle of LEXICAL scope, from the breadth of the global scope down through nested block scopes, into the intricacies of the variable lifecycle. Then we leveraged LEXICAL scope to understand the full power of closure.</p> <p>Take a moment to reflect on how far you've come in this journey so far; you've taken big steps in getting to know JS more deeply!</p> <p>The central theme of this book has been that understanding and mastering scope and closure is key in properly structuring and organizing our code, especially the decisions on where to store information in variables.</p> <p>Our goal in this final chapter is to appreciate how modules embody the importance of these topics, elevating them from abstract concepts to concrete, practical improvements in building programs.</p>"},{"location":"scope-closures/ch8/#encapsulation-and-least-exposure-pole","title":"Encapsulation and Least Exposure (POLE)","text":"<p>Encapsulation is often cited as a principle of object-oriented (OO) programming, but it's more fundamental and broadly applicable than that. The goal of encapsulation is the bundling or co-location of information (data) and behavior (functions) that together serve a common purpose.</p> <p>Independent of any syntax or code mechanisms, the spirit of encapsulation can be realized in something as simple as using separate files to hold bits of the overall program with common purpose. If we bundle everything that powers a list of search results into a single file called \"search-list.js\", we're encapsulating that part of the program.</p> <p>The recent trend in modern front-end programming to organize applications around Component architecture pushes encapsulation even further. For many, it feels natural to consolidate everything that constitutes the search results list\u2014even beyond code, including presentational markup and styling\u2014into a single unit of program logic, something tangible we can interact with. And then we label that collection the \"SearchList\" component.</p> <p>Another key goal is the control of visibility of certain aspects of the encapsulated data and functionality. Recall from Chapter 6 the least exposure principle (POLE), which seeks to defensively guard against various dangers of scope over-exposure; these affect both variables and functions. In JS, we most often implement visibility control through the mechanics of LEXICAL scope.</p> <p>The idea is to group alike program bits together, and selectively limit programmatic access to the parts we consider private details. What's not considered private is then marked as public, accessible to the whole program.</p> <p>The natural effect of this effort is better code organization. It's easier to build and maintain software when we know where things are, with clear and obvious boundaries and connection points. It's also easier to maintain quality if we avoid the pitfalls of over-exposed data and functionality.</p> <p>These are some of the main benefits of organizing JS programs into modules.</p>"},{"location":"scope-closures/ch8/#what-is-a-module","title":"What Is a Module?","text":"<p>A module is a collection of related data and functions (often referred to as methods in this context), characterized by a division between hidden private details and public accessible details, usually called the \"public API.\"</p> <p>A module is also stateful: it maintains some information over time, along with functionality to access and update that information.</p> NOTE: A broader concern of the module pattern is fully embracing system-level modularization through loose-coupling and other program architecture techniques. That's a complex topic well beyond the bounds of our discussion, but is worth further study beyond this book. <p>To get a better sense of what a module is, let's compare some module characteristics to useful code patterns that aren't quite modules.</p>"},{"location":"scope-closures/ch8/#namespaces-stateless-grouping","title":"Namespaces (Stateless Grouping)","text":"<p>If you group a set of related functions together, without data, then you don't really have the expected encapsulation a module implies. The better term for this grouping of stateless functions is a namespace:</p> <pre><code>// namespace, not module\nvar Utils = {\ncancelEvt(evt) {\nevt.preventDefault();\nevt.stopPropagation();\nevt.stopImmediatePropagation();\n},\nwait(ms) {\nreturn new Promise(function c(res){\nsetTimeout(res,ms);\n});\n},\nisValidEmail(email) {\nreturn /[^@]+@[^@.]+\\.[^@.]+/.test(email);\n}\n};\n</code></pre> <p><code>Utils</code> here is a useful collection of utilities, yet they're all state-independent functions. Gathering functionality together is generally good practice, but that doesn't make this a module. Rather, we've defined a <code>Utils</code> namespace and organized the functions under it.</p>"},{"location":"scope-closures/ch8/#data-structures-stateful-grouping","title":"Data Structures (Stateful Grouping)","text":"<p>Even if you bundle data and stateful functions together, if you're not limiting the visibility of any of it, then you're stopping short of the POLE aspect of encapsulation; it's not particularly helpful to label that a module.</p> <p>Consider:</p> <pre><code>// data structure, not module\nvar Student = {\nrecords: [\n{ id: 14, name: \"Kyle\", grade: 86 },\n{ id: 73, name: \"Suzy\", grade: 87 },\n{ id: 112, name: \"Frank\", grade: 75 },\n{ id: 6, name: \"Sarah\", grade: 91 }\n],\ngetName(studentID) {\nvar student = this.records.find(\nstudent =&gt; student.id == studentID\n);\nreturn student.name;\n}\n};\nStudent.getName(73);\n// Suzy\n</code></pre> <p>Since <code>records</code> is publicly accessible data, not hidden behind a public API, <code>Student</code> here isn't really a module.</p> <p><code>Student</code> does have the data-and-functionality aspect of encapsulation, but not the visibility-control aspect. It's best to label this an instance of a data structure.</p>"},{"location":"scope-closures/ch8/#modules-stateful-access-control","title":"Modules (Stateful Access Control)","text":"<p>To embody the full spirit of the module pattern, we not only need grouping and state, but also access control through visibility (private vs. public).</p> <p>Let's turn <code>Student</code> from the previous section into a module. We'll start with a form I call the \"classic module,\" which was originally referred to as the \"revealing module\" when it first emerged in the early 2000s. Consider:</p> <pre><code>var Student = (function defineStudent(){\nvar records = [\n{ id: 14, name: \"Kyle\", grade: 86 },\n{ id: 73, name: \"Suzy\", grade: 87 },\n{ id: 112, name: \"Frank\", grade: 75 },\n{ id: 6, name: \"Sarah\", grade: 91 }\n];\nvar publicAPI = {\ngetName\n};\nreturn publicAPI;\n// ************************\nfunction getName(studentID) {\nvar student = records.find(\nstudent =&gt; student.id == studentID\n);\nreturn student.name;\n}\n})();\nStudent.getName(73);   // Suzy\n</code></pre> <p><code>Student</code> is now an instance of a module. It features a public API with a single method: <code>getName(..)</code>. This method is able to access the private hidden <code>records</code> data.</p> WARNING: I should point out that the explicit student data being hard-coded into this module definition is just for our illustration purposes. A typical module in your program will receive this data from an outside source, typically loaded from databases, JSON data files, Ajax calls, etc. The data is then injected into the module instance typically through method(s) on the module's public API. <p>How does the classic module format work?</p> <p>Notice that the instance of the module is created by the <code>defineStudent()</code> IIFE being executed. This IIFE returns an object (named <code>publicAPI</code>) that has a property on it referencing the inner <code>getName(..)</code> function.</p> <p>Naming the object <code>publicAPI</code> is stylistic preference on my part. The object can be named whatever you like (JS doesn't care), or you can just return an object directly without assigning it to any internal named variable. More on this choice in Appendix A.</p> <p>From the outside, <code>Student.getName(..)</code> invokes this exposed inner function, which maintains access to the inner <code>records</code> variable via closure.</p> <p>You don't have to return an object with a function as one of its properties. You could just return a function directly, in place of the object. That still satisfies all the core bits of a classic module.</p> <p>By virtue of how LEXICAL scope works, defining variables and functions inside your outer module definition function makes everything by default private. Only properties added to the public API object returned from the function will be exported for external public use.</p> <p>The use of an IIFE implies that our program only ever needs a single central instance of the module, commonly referred to as a \"singleton.\" Indeed, this specific example is simple enough that there's no obvious reason we'd need anything more than just one instance of the <code>Student</code> module.</p>"},{"location":"scope-closures/ch8/#module-factory-multiple-instances","title":"Module Factory (Multiple Instances)","text":"<p>But if we did want to define a module that supported multiple instances in our program, we can slightly tweak the code:</p> <pre><code>// factory function, not singleton IIFE\nfunction defineStudent() {\nvar records = [\n{ id: 14, name: \"Kyle\", grade: 86 },\n{ id: 73, name: \"Suzy\", grade: 87 },\n{ id: 112, name: \"Frank\", grade: 75 },\n{ id: 6, name: \"Sarah\", grade: 91 }\n];\nvar publicAPI = {\ngetName\n};\nreturn publicAPI;\n// ************************\nfunction getName(studentID) {\nvar student = records.find(\nstudent =&gt; student.id == studentID\n);\nreturn student.name;\n}\n}\nvar fullTime = defineStudent();\nfullTime.getName(73);            // Suzy\n</code></pre> <p>Rather than specifying <code>defineStudent()</code> as an IIFE, we just define it as a normal standalone function, which is commonly referred to in this context as a \"module factory\" function.</p> <p>We then call the module factory, producing an instance of the module that we label <code>fullTime</code>. This module instance implies a new instance of the inner scope, and thus a new closure that <code>getName(..)</code> holds over <code>records</code>. <code>fullTime.getName(..)</code> now invokes the method on that specific instance.</p>"},{"location":"scope-closures/ch8/#classic-module-definition","title":"Classic Module Definition","text":"<p>So to clarify what makes something a classic module:</p> <ul> <li> <p>There must be an outer scope, typically from a module factory function running at least once.</p> </li> <li> <p>The module's inner scope must have at least one piece of hidden information that represents state for the module.</p> </li> <li> <p>The module must return on its public API a reference to at least one function that has closure over the hidden module state (so that this state is actually preserved).</p> </li> </ul> <p>You'll likely run across other variations on this classic module approach, which we'll look at in more detail in Appendix A.</p>"},{"location":"scope-closures/ch8/#node-commonjs-modules","title":"Node CommonJS Modules","text":"<p>In Chapter 4, we introduced the CommonJS module format used by Node. Unlike the classic module format described earlier, where you could bundle the module factory or IIFE alongside any other code including other modules, CommonJS modules are file-based; one module per file.</p> <p>Let's tweak our module example to adhere to that format:</p> <pre><code>module.exports.getName = getName;\n// ************************\nvar records = [\n{ id: 14, name: \"Kyle\", grade: 86 },\n{ id: 73, name: \"Suzy\", grade: 87 },\n{ id: 112, name: \"Frank\", grade: 75 },\n{ id: 6, name: \"Sarah\", grade: 91 }\n];\nfunction getName(studentID) {\nvar student = records.find(\nstudent =&gt; student.id == studentID\n);\nreturn student.name;\n}\n</code></pre> <p>The <code>records</code> and <code>getName</code> identifiers are in the top-level scope of this module, but that's not the global scope (as explained in Chapter 4). As such, everything here is by default private to the module.</p> <p>To expose something on the public API of a CommonJS module, you add a property to the empty object provided as <code>module.exports</code>. In some older legacy code, you may run across references to just a bare <code>exports</code>, but for code clarity you should always fully qualify that reference with the <code>module.</code> prefix.</p> <p>For style purposes, I like to put my \"exports\" at the top and my module implementation at the bottom. But these exports can be placed anywhere. I strongly recommend collecting them all together, either at the top or bottom of your file.</p> <p>Some developers have the habit of replacing the default exports object, like this:</p> <pre><code>// defining a new object for the API\nmodule.exports = {\n// ..exports..\n};\n</code></pre> <p>There are some quirks with this approach, including unexpected behavior if multiple such modules circularly depend on each other. As such, I recommend against replacing the object. If you want to assign multiple exports at once, using object literal style definition, you can do this instead:</p> <pre><code>Object.assign(module.exports,{\n// .. exports ..\n});\n</code></pre> <p>What's happening here is defining the <code>{ .. }</code> object literal with your module's public API specified, and then <code>Object.assign(..)</code> is performing a shallow copy of all those properties onto the existing <code>module.exports</code> object, instead of replacing it This is a nice balance of convenience and safer module behavior.</p> <p>To include another module instance into your module/program, use Node's <code>require(..)</code> method. Assuming this module is located at \"/path/to/student.js\", this is how we can access it:</p> <pre><code>var Student = require(\"/path/to/student.js\");\nStudent.getName(73);\n// Suzy\n</code></pre> <p><code>Student</code> now references the public API of our example module.</p> <p>CommonJS modules behave as singleton instances, similar to the IIFE module definition style presented before. No matter how many times you <code>require(..)</code> the same module, you just get additional references to the single shared module instance.</p> <p><code>require(..)</code> is an all-or-nothing mechanism; it includes a reference of the entire exposed public API of the module. To effectively access only part of the API, the typical approach looks like this:</p> <pre><code>var getName = require(\"/path/to/student.js\").getName;\n// or alternately:\nvar { getName } = require(\"/path/to/student.js\");\n</code></pre> <p>Similar to the classic module format, the publicly exported methods of a CommonJS module's API hold closures over the internal module details. That's how the module singleton state is maintained across the lifetime of your program.</p> NOTE: In Node <code>require(\"student\")</code> statements, non-absolute paths (<code>\"student\"</code>) assume a \".js\" file extension and search \"node_modules\"."},{"location":"scope-closures/ch8/#modern-es-modules-esm","title":"Modern ES Modules (ESM)","text":"<p>The ESM format shares several similarities with the CommonJS format. ESM is file-based, and module instances are singletons, with everything private by default. One notable difference is that ESM files are assumed to be strict-mode, without needing a <code>\"use strict\"</code> pragma at the top. There's no way to define an ESM as non-strict-mode.</p> <p>Instead of <code>module.exports</code> in CommonJS, ESM uses an <code>export</code> keyword to expose something on the public API of the module. The <code>import</code> keyword replaces the <code>require(..)</code> statement. Let's adjust \"students.js\" to use the ESM format:</p> <pre><code>export { getName };\n// ************************\nvar records = [\n{ id: 14, name: \"Kyle\", grade: 86 },\n{ id: 73, name: \"Suzy\", grade: 87 },\n{ id: 112, name: \"Frank\", grade: 75 },\n{ id: 6, name: \"Sarah\", grade: 91 }\n];\nfunction getName(studentID) {\nvar student = records.find(\nstudent =&gt; student.id == studentID\n);\nreturn student.name;\n}\n</code></pre> <p>The only change here is the <code>export { getName }</code> statement. As before, <code>export</code> statements can appear anywhere throughout the file, though <code>export</code> must be at the top-level scope; it cannot be inside any other block or function.</p> <p>ESM offers a fair bit of variation on how the <code>export</code> statements can be specified. For example:</p> <pre><code>export function getName(studentID) {\n// ..\n}\n</code></pre> <p>Even though <code>export</code> appears before the <code>function</code> keyword here, this form is still a <code>function</code> declaration that also happens to be exported. That is, the <code>getName</code> identifier is function hoisted (see Chapter 5), so it's available throughout the whole scope of the module.</p> <p>Another allowed variation:</p> <pre><code>export default function getName(studentID) {\n// ..\n}\n</code></pre> <p>This is a so-called \"default export,\" which has different semantics from other exports. In essence, a \"default export\" is a shorthand for consumers of the module when they <code>import</code>, giving them a terser syntax when they only need this single default API member.</p> <p>Non-<code>default</code> exports are referred to as \"named exports.\"</p> <p>The <code>import</code> keyword\u2014like <code>export</code>, it must be used only at the top level of an ESM outside of any blocks or functions\u2014also has a number of variations in syntax. The first is referred to as \"named import\":</p> <pre><code>import { getName } from \"/path/to/students.js\";\ngetName(73);   // Suzy\n</code></pre> <p>As you can see, this form imports only the specifically named public API members from a module (skipping anything not named explicitly), and it adds those identifiers to the top-level scope of the current module. This type of import is a familiar style to those used to package imports in languages like Java.</p> <p>Multiple API members can be listed inside the <code>{ .. }</code> set, separated with commas. A named import can also be renamed with the <code>as</code> keyword:</p> <pre><code>import { getName as getStudentName }\nfrom \"/path/to/students.js\";\ngetStudentName(73);\n// Suzy\n</code></pre> <p>If <code>getName</code> is a \"default export\" of the module, we can import it like this:</p> <pre><code>import getName from \"/path/to/students.js\";\ngetName(73);   // Suzy\n</code></pre> <p>The only difference here is dropping the <code>{ }</code> around the import binding. If you want to mix a default import with other named imports:</p> <pre><code>import { default as getName, /* .. others .. */ }\nfrom \"/path/to/students.js\";\ngetName(73);   // Suzy\n</code></pre> <p>By contrast, the other major variation on <code>import</code> is called \"namespace import\":</p> <pre><code>import * as Student from \"/path/to/students.js\";\nStudent.getName(73);   // Suzy\n</code></pre> <p>As is likely obvious, the <code>*</code> imports everything exported to the API, default and named, and stores it all under the single namespace identifier as specified. This approach most closely matches the form of classic modules for most of JS's history.</p> NOTE: As of the time of this writing, modern browsers have supported ESM for a few years now, but Node's stable'ish support for ESM is fairly recent, and has been evolving for quite a while. The evolution is likely to continue for another year or more; the introduction of ESM to JS back in ES6 created a number of challenging compatibility concerns for Node's interop with CommonJS modules. Consult Node's ESM documentation for all the latest details: https://nodejs.org/api/esm.html"},{"location":"scope-closures/ch8/#exit-scope","title":"Exit Scope","text":"<p>Whether you use the classic module format (browser or Node), CommonJS format (in Node), or ESM format (browser or Node), modules are one of the most effective ways to structure and organize your program's functionality and data.</p> <p>The module pattern is the conclusion of our journey in this book of learning how we can use the rules of LEXICAL scope to place variables and functions in proper locations. POLE is the defensive private by default posture we always take, making sure we avoid over-exposure and interact only with the minimal public API surface area necessary.</p> <p>And underneath modules, the magic of how all our module state is maintained is closures leveraging the LEXICAL scope system.</p> <p>That's it for the main text. Congratulations on quite a journey so far! As I've said numerous times throughout, it's a really good idea to pause, reflect, and practice what we've just discussed.</p> <p>When you're comfortable and ready, check out the appendices, which dig deeper into some of the corners of these topics, and also challenge you with some practice exercises to solidify what you've learned.</p>"},{"location":"scope-closures/closures_bard/","title":"closures bard","text":"<p>closure is a bad name that means nothing and confuses people</p> <p>a better name is nested function, or enclosed functio</p> Term Definition Closure A closure is a function that has access to the variables in its LEXICAL scope, even after the function has returned. Lexical scope The LEXICAL scope of a variable is the place in the code where the variable is declared. Example Consider the following code: <pre><code>function makeCounter() {\nlet counter = 0;\nfunction increment() {\ncounter++;\nreturn counter;\n}\nreturn increment;\n}\n</code></pre> <p>The <code>makeCounter()</code> function declares a variable called <code>counter</code>. The <code>increment()</code> function is declared inside the <code>makeCounter()</code> function, so it has access to the <code>counter</code> variable. Even though the <code>makeCounter()</code> function returns the <code>increment()</code> function, the <code>counter</code> variable is still in scope. This means that the <code>increment()</code> function can still access the <code>counter</code> variable even after the <code>makeCounter()</code> function has returned.</p> Term Definition Benefits Closures can be used to implement things like callbacks, promises, and event handlers. They can also be used to create reusable code that can be used in different contexts. Drawbacks Closures can make code more difficult to understand and debug. They can also make code less performant, as they can create additional scope chains. <p>I hope this helps! Let me know if you have any other questions.</p>","tags":["closures","bard"]},{"location":"scope-closures/scope_bard/","title":"scope: bard version","text":"<p>Sure, here is a summary of JavaScript scope in a table:</p> Scope Description Global scope The global scope is the outermost scope in a JavaScript program. It is created when the program starts and is destroyed when the program ends. All variables declared at the global scope are accessible from within any function in the program. Function scope A function scope is created when a function is called. It is a nested scope within the global scope. Variables declared within a function are only accessible from within that function and its child functions. Block scope A block scope is created when a block of code is enclosed in curly braces {}. It is a nested scope within the function scope in which the block is declared. Variables declared within a block are only accessible from within that block and its child blocks. <p>Here are some examples of how scopes work in JavaScript:</p> <pre><code>// Global scope\nvar myVar = \"This is a global variable.\";\n// Function scope\nfunction myFunction() {\nvar myVar = \"This is a local variable.\";\nconsole.log(myVar); // This will log \"This is a local variable.\"\n}\nmyFunction(); // This will also log \"This is a local variable.\"\n// Block scope\n{\nvar myVar = \"This is a block variable.\";\nconsole.log(myVar); // This will log \"This is a block variable.\"\n}\nconsole.log(myVar); // This will not log anything, because myVar is not defined in the global scope.\n</code></pre> <pre><code>flowchart TD\n\nsubgraph Global Scope\n  A[Global Variable]\nend\n\nsubgraph Function Scope\n  B[Local Variable]\n  C[Function]\nend\n\nsubgraph Block Scope\n  D[Block Variable]\nend\n\nA --&gt; B\nB --&gt; C\nC --&gt; D</code></pre>","tags":["bard","scope"]},{"location":"scope-closures/toc/","title":"Scope &amp; Closures - 2nd Edition","text":""},{"location":"scope-closures/toc/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: What's the Scope?<ul> <li>About This Book</li> <li>Compiled vs. Interpreted</li> <li>Compiling Code</li> <li>Compiler Speak</li> <li>Cheating: Run-Time Scope Modifications</li> <li>Lexical Scope</li> </ul> </li> <li>Chapter 2: Illustrating Lexical Scope<ul> <li>Marbles, and Buckets, and Bubbles... Oh My!</li> <li>A Conversation Among Friends</li> <li>Nested Scope</li> <li>Continue the Conversation</li> </ul> </li> <li>Chapter 3: The Scope Chain<ul> <li>\"Lookup\" Is (Mostly) Conceptual</li> <li>Shadowing</li> <li>Function Name Scope</li> <li>Arrow Functions</li> <li>Backing Out</li> </ul> </li> <li>Chapter 4: Around the Global Scope<ul> <li>Why Global Scope?</li> <li>Where Exactly is this Global Scope?</li> <li>Global This</li> <li>Globally Aware</li> </ul> </li> <li>Chapter 5: The (Not So) Secret Lifecycle of Variables<ul> <li>When Can I Use a Variable?</li> <li>Hoisting: Yet Another Metaphor</li> <li>Re-declaration?</li> <li>Uninitialized Variables (aka, TDZ)</li> <li>Finally Initialized</li> </ul> </li> <li>Chapter 6: Limiting Scope Exposure<ul> <li>Least Exposure</li> <li>Hiding in Plain (Function) Scope</li> <li>Scoping with Blocks</li> <li>Function Declarations in Blocks</li> <li>Blocked Over</li> </ul> </li> <li>Chapter 7: Using Closures<ul> <li>See the Closure</li> <li>The Closure Lifecycle and Garbage Collection (GC)</li> <li>Why Closure?</li> <li>An Alternative Perspective</li> <li>Closer to Closure</li> </ul> </li> <li>Chapter 8: The Module Pattern<ul> <li>Encapsulation and Least Exposure (POLE)</li> <li>What is a Module?</li> <li>Node CommonJS Modules</li> <li>Modern ES Modules (ESM)</li> <li>Exit Scope</li> </ul> </li> <li>Appendix A: Exploring Further<ul> <li>Implied Scopes</li> <li>Anonymous vs. Named Functions</li> <li>Hoisting: Functions and Variables</li> <li>The Case for <code>var</code></li> <li>What's the Deal with TDZ?</li> <li>Are Synchronous Callbacks Still Closures?</li> <li>Classic Module Variations</li> </ul> </li> <li>Appendix B: Practice<ul> <li>Buckets of Marbles</li> <li>Closure (PART 1)</li> <li>Closure (PART 2)</li> <li>Closure (PART 3)</li> <li>Modules</li> <li>Suggested Solutions</li> </ul> </li> </ul>"},{"location":"sync-async/ch1/","title":"Chapter 1: TODO","text":"NOTE: Work in progress"},{"location":"sync-async/toc/","title":"TOC: Sync &amp; Async - 2nd Edition","text":"NOTE: Work in progress"},{"location":"sync-async/toc/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: TODO<ul> <li>TODO</li> </ul> </li> </ul>"},{"location":"types-grammar/ch1/","title":"Chapter 1: Primitive Values","text":"NOTE: Work in progress <p>In Chapter 1 of the \"Objects &amp; Classes\" book of this series, we confronted the common misconception that \"everything in JS is an object\". We now circle back to that topic, and again dispell that myth.</p> <p>Here, we'll look at the core value types of JS, specifically the non-object types called primitives.</p>"},{"location":"types-grammar/ch1/#value-types","title":"Value Types","text":"<p>JS doesn't apply types to variables or properties -- what I call, \"container types\" -- but rather, values themselves have types -- what I call, \"value types\".</p> <p>The language provides seven built-in, primitive (non-object) value types: 1</p> <ul> <li><code>undefined</code></li> <li><code>null</code></li> <li><code>boolean</code></li> <li><code>number</code></li> <li><code>bigint</code></li> <li><code>symbol</code></li> <li><code>string</code></li> </ul> <p>These value-types define collections of one or more concrete values, each with a set of shared behaviors for all values of each type.</p>"},{"location":"types-grammar/ch1/#type-of","title":"Type-Of","text":"<p>Any value's value-type can be inspected via the <code>typeof</code> operator, which always returns a <code>string</code> value representing the underlying JS value-type:</p> <pre><code>typeof true;            // \"boolean\"\ntypeof 42;              // \"number\"\ntypeof 42n;             // \"bigint\"\ntypeof Symbol(\"42\");    // \"symbol\"\n</code></pre> <p>The <code>typeof</code> operator, when used against a variable instead of a value, is reporting the value-type of the value in the variable:</p> <pre><code>greeting = \"Hello\";\ntypeof greeting;        // \"string\"\n</code></pre> <p>JS variables themselves don't have types. They hold any arbitrary value, which itself has a value-type.</p>"},{"location":"types-grammar/ch1/#non-objects","title":"Non-objects?","text":"<p>What specifically makes the 7 primitive value types distinct from the object value types (and sub-types)? Why shouldn't we just consider them all as essentially objects under the covers?</p> <p>Consider:</p> <pre><code>myName = \"Kyle\";\nmyName.nickname = \"getify\";\nconsole.log(myName.nickname);           // undefined\n</code></pre> <p>This snippet appears to silently fail to add a <code>nickname</code> property to a primitive string. Taken at face value, that might imply that primitives are really just objects under the covers, as many have (wrongly) asserted over the years.</p> WARNING: One might explain that silent failure as an example of auto-boxing (see \"Automatic Objects\" in Chapter 3), where the primitive is implicitly converted to a <code>String</code> instance wrapper object while attempting to assign the property, and then this internal object is thrown away after the statement completes. In fact, I said exactly that in the first edition of this book. But I was wrong; oops! <p>Something deeper is at play, as we see in this version of the previous snippet:</p> <pre><code>\"use strict\";\nmyName = \"Kyle\";\nmyName.nickname = \"getify\";\n// TypeError: Cannot create property 'nickname'\n// on string 'Kyle'\n</code></pre> <p>Interesting! In strict-mode, JS enforces a restriction that disallows setting a new property on a primitive value, as if implicitly promoting it to a new object.</p> <p>By contrast, in non-strict mode, JS allows the violation to go unmentioned. So why? Because strict-mode was added to the language in ES5.1 (2011), more than 15 years in, and such a change would have broken existing programs had it not been defined as sensitive to the new strict-mode declaration.</p> <p>So what can we conclude about the distinction between primitives and objects? Primitives are values that are not allowed to have properties; only objects are allowed such.</p> TIP: This particular distinction seems to be contradicted by expressions like <code>\"hello\".length</code>; even in strict-mode, it returns the expected value <code>5</code>. So it certainly seems like the string has a <code>length</code> property! But, as just previously mentioned, the correct explanation is auto-boxing; we'll cover the topic in \"Automatic Objects\" in Chapter 3."},{"location":"types-grammar/ch1/#empty-values","title":"Empty Values","text":"<p>The <code>null</code> and <code>undefined</code> types both typically represent an emptiness or absence of value.</p> <p>Unfortunately, the <code>null</code> value-type has an unexpected <code>typeof</code> result. Instead of <code>\"null\"</code>, we see:</p> <pre><code>typeof null;            // \"object\"\n</code></pre> <p>No, that doesn't mean that <code>null</code> is somehow a special kind of object. It's just a legacy of early days of JS, which cannot be changed because of how much code out in the wild it would break.</p> <p>The <code>undefined</code> type is reported both for explicit <code>undefined</code> values and any place where a seemingly missing value is encountered:</p> <pre><code>typeof undefined;               // \"undefined\"\nvar whatever;\ntypeof whatever;                // \"undefined\"\ntypeof nonExistent;             // \"undefined\"\nwhatever = {};\ntypeof whatever.missingProp;    // \"undefined\"\nwhatever = [];\ntypeof whatever[10];            // \"undefined\"\n</code></pre> NOTE: The <code>typeof nonExistent</code> expression is referring to an undeclared variable <code>nonExistent</code>. Normally, accessing an undeclared variable reference would cause an exception, but the <code>typeof</code> operator is afforded the special ability to safely access even non-existent identifiers and calmly return <code>\"undefined\"</code> instead of throwing an exception. <p>However, each respective \"empty\" type has exactly one value, of the same name. So <code>null</code> is the only value in the <code>null</code> value-type, and <code>undefined</code> is the only value in the <code>undefined</code> value-type.</p>"},{"location":"types-grammar/ch1/#nullish","title":"Null'ish","text":"<p>Semantically, <code>null</code> and <code>undefined</code> types both represent general emptiness, or absence of another affirmative, meaningful value.</p> NOTE: JS operations which behave the same whether <code>null</code> or <code>undefined</code> is encountered, are referred to as \"null'ish\" (or \"nullish\"). I guess \"undefined'ish\" would look/sound too weird! <p>For a lot of JS, especially the code developers write, these two nullish values are interchangeable; the decision to intentionally use/assign <code>null</code> or <code>undefined</code> in any given scenario is situation dependent and left up to the developer.</p> <p>JS provides a number of capabilities for helping treat the two nullish values as indistinguishable.</p> <p>For example, the <code>==</code> (coercive-equality comparision) operator specifically treats <code>null</code> and <code>undefined</code> as coercively equal to each other, but to no other values in the language. As such, a <code>.. == null</code> check is safe to perform if you want to check if a value is specifically either <code>null</code> or <code>undefined</code>:</p> <pre><code>if (greeting == null) {\n// greeting is nullish/empty\n}\n</code></pre> <p>Another (recent) addition to JS is the <code>??</code> (nullish-coalescing) operator:</p> <pre><code>who = myName ?? \"User\";\n// equivalent to:\nwho = (myName != null) ? myName : \"User\";\n</code></pre> <p>As the ternary equivalent illustrates, <code>??</code> checks to see if <code>myName</code> is non-nullish, and if so, returns its value. Otherwise, it returns the other operand (here, <code>\"User\"</code>).</p> <p>Along with <code>??</code>, JS also added the <code>?.</code> (nullish conditional-chaining) operator:</p> <pre><code>record = {\nshippingAddress: {\nstreet: \"123 JS Lane\",\ncity: \"Browserville\",\nstate: \"XY\"\n}\n};\nconsole.log( record?.shippingAddress?.street );\n// 123 JS Lane\nconsole.log( record?.billingAddress?.street );\n// undefined\n</code></pre> <p>The <code>?.</code> operator checks the value immediately preceding (to the left) value, and if it's nullish, the operator stops and returns an <code>undefined</code> value. Otherwise, it performs the <code>.</code> property access against that value and continues with the expression.</p> <p>Just to be clear: <code>record?.</code> is saying, \"check <code>record</code> for nullish before <code>.</code> property access\". Additionally, <code>billingAddress?.</code> is saying, \"check <code>billingAddress</code> for nullish before <code>.</code> property access\".</p> WARNING: Some JS developers believe that the newer <code>?.</code> is superior to <code>.</code>, and should thus almost always be used instead of <code>.</code>. I believe that's an unwise perspective. First of all, it's adding extra visual clutter, which should only be done if you're getting benefit from it. Secondly, you should be aware of, and planning for, the emptiness of some value, to justify using <code>?.</code>. If you always expect a non-nullish value to be present in some expression, using <code>?.</code> to access a property on it is not only unnecessary/wasteful, but also could potentially hide future bugs where your assumption of value-presence had failed but <code>?.</code> covered it up. As with most features in JS, use <code>.</code> where it's most appropriate, and use <code>?.</code> where it's most appropriate. Never substitute one when the other is more appropriate. <p>There's also a somewhat strange <code>?.[</code> form of the operator, not <code>?[</code>, for when you need to use <code>[ .. ]</code> style access instead of <code>.</code> access:</p> <pre><code>record?.[\"shipping\" + \"Address\"]?.state;    // XY\n</code></pre> <p>Yet another variation, referred to as \"optional-call\", is <code>?.(</code>, and is used when conditionally calling a function if the value is non-nullish:</p> <pre><code>// instead of:\n//   if (someFunc) someFunc(42);\n//\n// or:\n//   someFunc &amp;&amp; someFunc(42);\nsomeFunc?.(42);\n</code></pre> <p>The <code>?.(</code> operator seems like it is checking to see if <code>someFunc(..)</code> is a valid function that can be called. But it's not! It's only checking to make sure the value is non-nullish before trying to invoke it. If it's some other non-nullish but also non-function value type, the execution attempt will still fail with a <code>TypeError</code> exception.</p> WARNING: Because of that gotcha, I strongly dislike this operator form, and caution anyone against ever using it. I think it's a poorly conceived feature that does more harm (to JS itself, and to programs) than good. There's very few JS features I would go so far as to say, \"never use it.\" But this is one of the truly bad parts of the language, in my opinion."},{"location":"types-grammar/ch1/#distinctish","title":"Distinct'ish","text":"<p>It's important to keep in mind that <code>null</code> and <code>undefined</code> are actually distinct types, and thus <code>null</code> can be noticeably different from <code>undefined</code>. You can, carefully, construct programs that mostly treat them as indistinguishable. But that requires care and discipline by the developer. From JS's perspective, they're more often distinct.</p> <p>There are cases where <code>null</code> and <code>undefined</code> will trigger different behavior by the language, which is important to keep in mind. We won't cover all the cases exhaustively here, but here's on example:</p> <pre><code>function greet(msg = \"Hello\") {\nconsole.log(msg);\n}\ngreet();            // Hello\ngreet(undefined);   // Hello\ngreet(\"Hi\");        // Hi\ngreet(null);        // null\n</code></pre> <p>The <code>= ..</code> clause on a parameter is referred to as the \"parameter default\". It only kicks in and assigns its default value to the parameter if the argument in that position is missing, or is exactly the <code>undefined</code> value. If you pass <code>null</code>, that clause doesn't trigger, and <code>null</code> is thus assigned to the parameter.</p> <p>There's no right or wrong way to use <code>null</code> or <code>undefined</code> in a program. So the takeaway is: be careful when choosing one value or the other. And if you're using them interchangeably, be extra careful.</p>"},{"location":"types-grammar/ch1/#boolean-values","title":"Boolean Values","text":"<p>The <code>boolean</code> type contains two values: <code>false</code> and <code>true</code>.</p> <p>In the \"old days\", programming languages would, by convention, use <code>0</code> to mean <code>false</code> and <code>1</code> to mean <code>true</code>. So you can think of the <code>boolean</code> type, and the keywords <code>false</code> and <code>true</code>, as a semantic convenience sugar on top of the <code>0</code> and <code>1</code> values:</p> <pre><code>// isLoggedIn = 1;\nisLoggedIn = true;\nisComplete = 0;\n// isComplete = false;\n</code></pre> <p>Boolean values are how all decision making happens in a JS program:</p> <pre><code>if (isLoggedIn) {\n// do something\n}\nwhile (!isComplete) {\n// keep going\n}\n</code></pre> <p>The <code>!</code> operator negates/flips a boolean value to the other one: <code>false</code> becomes <code>true</code>, and <code>true</code> becomes <code>false</code>.</p>"},{"location":"types-grammar/ch1/#string-values","title":"String Values","text":"<p>The <code>string</code> type contains any value which is a collection of one or more characters, delimited (surrounding on either side) by quote characters:</p> <pre><code>myName = \"Kyle\";\n</code></pre> <p>JS does not distinguish a single character as a different type as some languages do; <code>\"a\"</code> is a string just like <code>\"abc\"</code> is.</p> <p>Strings can be delimited by double-quotes (<code>\"</code>), single-quotes (<code>'</code>), or back-ticks (<code>`</code>). The ending delimiter must always match the starting delimiter.</p> <p>Strings have an intrinsic length which corresponds to how many code-points -- actually, code-units, more on that in a bit -- they contain.</p> <pre><code>myName = \"Kyle\";\nmyName.length;      // 4\n</code></pre> <p>This does not necessarily correspond to the number of visible characters present between the start and end delimiters (aka, the string literal). It can sometimes be a little confusing to keep straight the difference between a string literal and the underlying string value, so pay close attention.</p> NOTE: We'll cover length computation of strings in detail, in Chapter 2."},{"location":"types-grammar/ch1/#js-character-encodings","title":"JS Character Encodings","text":"<p>What type of character encoding does JS use for string characters?</p> <p>You've probably heard of \"Unicode\" and perhaps even \"UTF-8\" (8-bit) or \"UTF-16\" (16-bit). If you're like me (before doing the research it took to write this text), you might have just hand-waved and decided that's all you need to know about character encodings in JS strings.</p> <p>But... it's not. Not even close.</p> <p>It turns out, you need to understand how a variety of aspects of Unicode work, and even to consider concepts from UCS-2 (2-byte Universal Character Set), which is similar to UTF-16, but not quite the same. 2</p> <p>Unicode defines all the \"characters\" we can represent universally in computer programs, by assigning a specific number to each, called code-points. These numbers range from <code>0</code> all the way up to a maximum of <code>1114111</code> (<code>10FFFF</code> in hexadecimal).</p> <p>The standard notation for Unicode characters is <code>U+</code> followed by 4-6 hexadecimal characters. For example, the <code>\u2764</code> (heart symbol) is code-point <code>10084</code> (<code>2764</code> in hexadecimal), and is thus notated with <code>U+2764</code>.</p> <p>The first group of 65,535 code points in Unicode is called the BMP (Basic Multilingual Plane). These can all be represented with 16 bits (2 bytes). When representing Unicode characters from the BMP, it's fairly straightforward, as they can fit neatly into single UTF-16 JS characters.</p> <p>All the rest of the code points are grouped into 16 so called \"supplemental planes\" or \"astral planes\". These code-points require more than 16 bits to represent -- 21 bits to be exact -- so when representing extended/supplemental characters above the BMP, JS actually stores these code-points as a pairing of two adjacent 16-bit code units, called surrogate halves (or surrogate pairs).</p> <p>For example, the Unicode code point <code>127878</code> (hexadecimal <code>1F386</code>) is <code>\ud83c\udf86</code> (fireworks symbol). JS stores this in a string value as two surrogate-halve code units: <code>U+D83C</code> and <code>U+DF86</code>. Keep in mind that these two parts of the whole character do not standalone; they're only valid/meaningful when paired immediately adjacent to each other.</p> <p>This has implications on the length of strings, because a single visible character like the <code>\ud83c\udf86</code> fireworks symbol, when in a JS string, is a counted as 2 characters for the purposes of the string length!</p> <p>We'll revisit Unicode characters in a bit, and then cover the challenges of computing string length in Chapter 2.</p>"},{"location":"types-grammar/ch1/#escape-sequences","title":"Escape Sequences","text":"<p>If <code>\"</code> or <code>'</code> are used to delimit a string literal, the contents are only parsed for character-escape sequences: <code>\\</code> followed by one or more characters that JS recognizes and parses with special meaning. Any other characters in a string that don't parse as escape-sequences (single-character or multi-character), are inserted as-is into the string value.</p> <p>For single-character escape sequences, the following characters are recognized after a <code>\\</code>: <code>b</code>, <code>f</code>, <code>n</code>, <code>r</code>, <code>t</code>, <code>v</code>, <code>0</code>, <code>'</code>, <code>\"</code>, and <code>\\</code>. For example,  <code>\\n</code> means new-line, <code>\\t</code> means tab, etc.</p> <p>If a <code>\\</code> is followed by any other character (except <code>x</code> and <code>u</code> -- explained below), like for example <code>\\k</code>, that sequence is interpreted as the <code>\\</code> being an unnecessary escape, which is thus dropped, leaving just the literal character itself (<code>k</code>).</p> <p>To include a <code>\"</code> in the middle of a <code>\"</code>-delimited string literal, use the <code>\\\"</code> escape sequence. Similarly, if you're including a <code>'</code> character in the middle of a <code>'</code>-delimited string literal, use the <code>\\'</code> escape sequence. By contrast, a <code>'</code> does not need to be escaped inside a <code>\"</code>-delimited string, nor vice versa.</p> <pre><code>myTitle = \"Kyle Simpson (aka, \\\"getify\\\"), former O'Reilly author\";\nconsole.log(myTitle);\n// Kyle Simpson (aka, \"getify\"), former O'Reilly author\n</code></pre> <p>In text, forward slash <code>/</code> is most common. But occasionally, you need a backward slash <code>\\</code>. To include a literal <code>\\</code> backslash character without it performing as the start of a character-escape sequence, use the <code>\\\\</code> (double backslashes).</p> <p>So, then... what would <code>\\\\\\</code> (three backslashes) in a string parse as? The first two <code>\\</code>'s would be a <code>\\\\</code> escape sequence, thereby inserting just a single <code>\\</code> character in the string value, and the remaining <code>\\</code> would just escape whatever character comes immediately after it.</p> <p>One place backslashes show up commonly is in Windows file paths, which use the <code>\\</code> separator instead of the <code>/</code> separator used in linux/unix style paths:</p> <pre><code>windowsFontsPath =\n\"C:\\\\Windows\\\\Fonts\\\\\";\nconsole.log(windowsFontsPath);\n// C:\\Windows\\Fonts\\\"\n</code></pre> TIP: What about four backslashes <code>\\\\\\\\</code> in a string literal? Well, that's just two <code>\\\\</code> escape sequences next to each other, so it results in two adjacent backslashes (<code>\\\\</code>) in the underlying string value. You might recognize there's an odd/even rule pattern at play. You should thus be able to deciper any odd (<code>\\\\\\\\\\</code>, <code>\\\\\\\\\\\\\\\\\\</code>, etc) or even (<code>\\\\\\\\\\\\</code>, <code>\\\\\\\\\\\\\\\\\\\\</code>, etc) number of backslashes in a string literal."},{"location":"types-grammar/ch1/#line-continuation","title":"Line Continuation","text":"<p>The <code>\\</code> character followed by an actual new-line character (not just literal <code>n</code>) is a special case, and it creates what's called a line-continuation:</p> <pre><code>greeting = \"Hello \\\nFriends!\";\nconsole.log(greeting);\n// Hello Friends!\n</code></pre> <p>As you can see, the new-line at the end of the <code>greeting =</code> line is immediately preceded by a <code>\\</code>, which allows this string literal to continue onto the subsequent line. Without the escaping <code>\\</code> before it, a new-line -- the actual new-line, not the <code>\\n</code> character escape sequence -- appearing in a <code>\"</code> or <code>'</code> delimited string literal would actually produce a JS syntax parsing error.</p> <p>Because the end-of-line <code>\\</code> turns the new-line character into a line continuation, the new-line character is omitted from the string, as shown by the <code>console.log(..)</code> output.</p> NOTE: This line-continuation feature is often referred to as \"multi-line strings\", but I think that's a confusing label. As you can see, the string value itself doesn't have multiple lines, it only was defined across multiple lines via the line continuations. A multi-line string would actually have multiple lines in the underlying value. We'll revisit this topic later in this chapter when we cover Template Literals."},{"location":"types-grammar/ch1/#multi-character-escapes","title":"Multi-Character Escapes","text":"<p>Multi-character escape sequences may be hexadecimal or Unicode sequences.</p> <p>Hexadecimal escape sequences are used to encode any of the base ASCII characters (codes 0-255), and look like <code>\\x</code> followed by exactly two hexadecimal characters (<code>0-9</code> and <code>a-f</code> / <code>A-F</code> -- case insensitive). For example, <code>A9</code> or <code>a9</code> are decimal value <code>169</code>, which corresponds to:</p> <pre><code>copyright = \"\\xA9\";  // or \"\\xa9\"\nconsole.log(copyright);     // \u00a9\n</code></pre> <p>For any normal character that can be typed on a keyboard, such as <code>\"a\"</code>, it's usually most readable to just specify the literal character, as opposed to a more obfuscated hexadecimal representation:</p> <pre><code>\"a\" === \"\\x61\";             // true\n</code></pre>"},{"location":"types-grammar/ch1/#unicode-in-strings","title":"Unicode In Strings","text":"<p>Unicode escape sequences alone can encode any of the characters from the Unicode BMP. They look like <code>\\u</code> followed by exactly four hexadecimal characters.</p> <p>For example, the escape-sequence <code>\\u00A9</code> (or <code>\\u00a9</code>) corresponds to that same <code>\u00a9</code> symbol, while <code>\\u263A</code> (or <code>\\u263a</code>) corresponds to the Unicode character with code-point <code>9786</code>: <code>\u263a</code> (smiley face symbol).</p> <p>When any character-escape sequence (regardless of length) is recognized, the single character it represents is inserted into the string, rather than the original separate characters. So, in the string <code>\"\\u263A\"</code>, there's only one (smiley) character, not six individual characters.</p> <p>But as explained earlier, many Unicode code-points are well above <code>65535</code>. For example, <code>1F4A9</code> (or <code>1f4a9</code>) is decimal code-point <code>128169</code>, which corresponds to the funny <code>\ud83d\udca9</code> (pile-of-poo) symbol.</p> <p>But <code>\\u1F4A9</code> wouldn't work to include this character in a string, since it would be parsed as the Unicode escape sequence <code>\\u1F4A</code>, followed by a literal <code>9</code> character. To address this limitation, a variation of Unicode escape sequences was introduced to allow an arbitrary number of hexadecimal characters after the <code>\\u</code>, by surrounding them with <code>{ .. }</code> curly braces:</p> <pre><code>myReaction = \"\\u{1F4A9}\";\nconsole.log(myReaction);\n// \ud83d\udca9\n</code></pre> <p>Recall the earlier discussion of extended (non-BMP) Unicode characters and surrogate halves? The same <code>\ud83d\udca9</code> could also be defined with two explicit code-units, that form a surrogate pair:</p> <pre><code>myReaction = \"\\uD83D\\uDCA9\";\nconsole.log(myReaction);\n// \ud83d\udca9\n</code></pre> <p>All three representations of this same character are stored internally by JS identically, and are indistinguishable:</p> <pre><code>\"\ud83d\udca9\" === \"\\u{1F4A9}\";                // true\n\"\\u{1F4A9}\" === \"\\uD83D\\uDCA9\";     // true\n</code></pre> <p>Even though JS doesn't care which way such a character is represented in your program, consider the readability differences carefully when authoring your code.</p> NOTE: Even though <code>\ud83d\udca9</code> looks like a single character, its internal representation affects things like the length computation of a string with that character in it. We'll cover length computation of strings in Chapter 2."},{"location":"types-grammar/ch1/#unicode-normalization","title":"Unicode Normalization","text":"<p>Another wrinkle in Unicode string handling is that even certain single BMP characters can be represented in different ways.</p> <p>For example, the <code>\"e\u0301\"</code> character can either be represented as itself (code-point <code>233</code>, aka <code>\\xe9</code> or <code>\\u00e9</code> or <code>\\u{e9}</code>), or as the combination of two code-points: the <code>\"e\"</code> character (code-point <code>101</code>, aka <code>\\x65</code>, <code>\\u0065</code>, <code>\\u{65}</code>) and the combining tilde (code-point <code>769</code>, aka <code>\\u0301</code>, <code>\\u{301}</code>).</p> <p>Consider:</p> <pre><code>eTilde1 = \"e\u0301\";\neTilde2 = \"\\u00e9\";\neTilde3 = \"\\u0065\\u0301\";\nconsole.log(eTilde1);       // e\u0301\nconsole.log(eTilde2);       // e\u0301\nconsole.log(eTilde3);       // e\u0301\n</code></pre> <p>The string literal assigned to <code>eTilde3</code> in this snippet stores the accent mark as a separate combining mark symbol. Like surrogate pairs, a combining mark only makes sense in connection with the symbol it's adjacent to (usually after).</p> <p>The rendering of the Unicode symbol should be the same regardless, but how the <code>\"e\u0301\"</code> character is internally stored affects things like <code>length</code> computation of the containing string, as well as equality and relational comparison (more on these in Chapter 2):</p> <pre><code>eTilde1.length;             // 2\neTilde2.length;             // 1\neTilde3.length;             // 2\neTilde1 === eTilde2;        // false\neTilde1 === eTilde3;        // true\n</code></pre> <p>One particular challenge is that you may copy-paste a string with an <code>\"e\u0301\"</code> character visible in it, and that character you copied may have been in the composed or decomposed form. But there's no visual way to tell, and yet the underlying string value in the literal will be different:</p> <pre><code>\"\u00e9\" === \"e\u0301\";           // false!!\n</code></pre> <p>This internal representation difference can be quite challenging if not carefully planned for. Fortunately, JS provides a <code>normalize(..)</code> utility method on strings to help:</p> <pre><code>eTilde1 = \"e\u0301\";\neTilde2 = \"\\u{e9}\";\neTilde3 = \"\\u{65}\\u{301}\";\neTilde1.normalize(\"NFC\") === eTilde2;\neTilde2.normalize(\"NFD\") === eTilde3;\n</code></pre> <p>The <code>\"NFC\"</code> normalization mode combines adjacent code-points into the composed code-point (if possible), whereas the <code>\"NFD\"</code> normalization mode splits a single code-point into its decomposed code-points (if possible).</p> <p>And there can actually be more than two individual decomposed code-points that make up a single composed code-point -- for example, a single character could have several diacritical marks applied to it.</p> <p>When dealing with Unicode strings that will be compared, sorted, or length analyzed, it's very important to keep Unicode normalization in mind, and use it where necessary.</p>"},{"location":"types-grammar/ch1/#unicode-grapheme-clusters","title":"Unicode Grapheme Clusters","text":"<p>A final complication of Unicode string handling is the support for clustering of multiple adjacent code-points into a single visually distinct symbol, referred to as a grapheme (or a grapheme cluster).</p> <p>An example would be a family emoji such as <code>\"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66\"</code>, which is actually made up of 7 code-points that all cluster/group together into a single visual symbol.</p> <p>Consider:</p> <pre><code>familyEmoji = \"\\u{1f469}\\u{200d}\\u{1f469}\\u{200d}\\u{1f466}\\u{200d}\\u{1f466}\";\nfamilyEmoji;            // \ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66\n</code></pre> <p>This emoji is not a single registered Unicode code-point, and as such, there's no normalization that can be performed to compose these 7 separate code-points into a single entity. The visual rendering logic for such composite symbols is quite complex, well beyond what most of JS developers want to embed into our programs. Libraries do exist for handling some of this logic, but they're often large and still don't necessarily cover all of the nuances/variations.</p> <p>Unlike surrogate pairs and combining marks, the symbols in grapheme clusters can in fact act as standalone characters, but have the special combining behavior when placed adjacent to each other.</p> <p>This kind of complexity significantly affects length computations, comparison, sorting, and many other common string-oriented operations.</p>"},{"location":"types-grammar/ch1/#template-literals","title":"Template Literals","text":"<p>I mentioned earlier that strings can alternately be delimited with <code>`..`</code> back-ticks:</p> <pre><code>myName = `Kyle`;\n</code></pre> <p>All the same rules for character encodings, character escape sequences, and lengths apply to these types of strings.</p> <p>However, the contents of these template (string) literals are additionally parsed for a special delimiter sequence <code>${ .. }</code>, which marks an expression to evaluate and interpolate into the string value at that location:</p> <pre><code>myName = `Kyle`;\ngreeting = `Hello, ${myName}!`;\nconsole.log(greeting);      // Hello, Kyle!\n</code></pre> <p>Everything between the <code>{ .. }</code> in such a template literal is an arbitrary JS expression. It can be simple variables like <code>myName</code>, or complex JS programs, or anything in between (even another template literal expression!).</p> TIP: This feature is commonly called \"template literals\" or \"template strings\", but I think that's confusing. \"Template\" usually means, in programming contexts, a reusable set of text that can be re-evaluated with different data. For example, template engines for pages, email templates for newsletter campaigns, etc. This JS feature is not re-usable. It's a literal, and it produces a single, immediate value (usually a string). You can put such a value in a function, and call the function multiple times. But then the function is acting as the template, not the the literal itself. I prefer instead to refer to this feature as interpolated literals, or the funny, short-hand: interpoliterals. I just think that name is more accurately descriptive. <p>Template literals also have an interesting different behavior with respect to new-lines, compared to classic <code>\"</code> or <code>'</code> delimited strings. Recall that for those strings, a line-continuation required a <code>\\</code> at the end of each line, right before a new-line. Not so, with template literals!</p> <pre><code>myPoem = `\nRoses are red\nViolets are blue\nC3PO's a funny robot\nand so R2.`;\nconsole.log(myPoem);\n//\n// Roses are red\n// Violets are blue\n// C3PO's a funny robot\n// and so R2.\n</code></pre> <p>Line-continuations with template literals do not require escaping. However, that means the new-line is part of the string, even the first new-line above. In other words, <code>myPoem</code> above holds a truly multi-line string, as shown. However, if you <code>\\</code> escape the end of any line in a template literal, the new-line will be omitted, just like with non-template literal strings.</p> <p>Template literals usually result in a string value, but not always. A form of template literal that may look kind of strange is called a tagged template literal:</p> <pre><code>price = formatCurrency`The cost is: ${totalCost}`;\n</code></pre> <p>Here, <code>formatCurrency</code> is a tag applied to the template literal value, which actually invokes <code>formatCurrency(..)</code> as a function, passing it the string literals and interpolated expressions parsed from the value. This function can then assemble those in any way it sees fit -- such as formatting a <code>number</code> value as currency in the current locale -- and return whatever value, string or otherwise, that it wants.</p> <p>So tagged template literals are not always strings; they can be any value. But untagged template literals will always be strings.</p> <p>Some JS developers believe that untagged template literal strings are best to use for all strings, even if not using any expression interpolation or multiple lines. I disagree. I think they should only be used when interpolating (or multi-line'ing).</p> TIP: The principle I always apply in making such determinations: use the closest-matched, and least capable, feature/tool, for any task. <p>Moreover, there are a few places where <code>`..`</code> style strings are disallowed. For example, the <code>\"use strict\"</code> pragma cannot use back-ticks, or the pragma will be silently ignored (and thus the program accidentally runs in non-strict mode). Also, this style of strings cannot be used in quoted property names of object literals, destruturing patterns, or in the ES Module <code>import .. from ..</code> module-specifier clause.</p> <p>My take: use <code>`..`</code> delimited strings where allowed, but only when interpolation/multi-line is needed; and keep using <code>\"..\"</code> or <code>'..'</code> delimited strings for everything else.</p>"},{"location":"types-grammar/ch1/#number-values","title":"Number Values","text":"<p>The <code>number</code> type contains any numeric value (whole number or decimal), such as <code>-42</code> or <code>3.1415926</code>. These values are represented by the JS engine as 64-bit, IEEE-754 double-precision binary floating-point values. 3</p> <p>JS <code>number</code>s are always decimals; whole numbers (aka \"integers\") are not stored in a different/special way. An \"integer\" stored as a <code>number</code> value merely has nothing non-zero as its fraction portion; <code>42</code> is thus indistinguishable in JS from <code>42.0</code> and <code>42.000000</code>.</p> <p>We can use <code>Number.isInteger(..)</code> to determine if a <code>number</code> value has any non-zero fraction or not:</p> <pre><code>Number.isInteger(42);           // true\nNumber.isInteger(42.0);         // true\nNumber.isInteger(42.000000);    // true\nNumber.isInteger(42.0000001);   // false\n</code></pre>"},{"location":"types-grammar/ch1/#parsing-vs-coercion","title":"Parsing vs Coercion","text":"<p>If a string value holds numeric-looking contents, you may need to convert from that string value to a <code>number</code>, for mathematical operation purposes.</p> <p>However, it's very important to distinguish between parsing-conversion and coercive-conversion.</p> <p>We can parse-convert with JS's built-in <code>parseInt(..)</code> or <code>parseFloat(..)</code> utilities:</p> <pre><code>someNumericText = \"123.456\";\nparseInt(someNumericText,10);               // 123\nparseFloat(someNumericText);                // 123.456\nparseInt(\"42\",10) === parseFloat(\"42\");     // true\nparseInt(\"512px\");                          // 512\n</code></pre> NOTE: Parsing is only relevant for string values, as it's a character-by-character (left-to-right) operation. It doesn't make sense to parse the contents of a <code>boolean</code>, nor to parse the contents of a <code>number</code> or a <code>null</code>; there's nothing to parse. If you pass anything other than a string value to <code>parseInt(..)</code> / <code>parseFloat(..)</code>, those utilties first convert that value to a string and then try to parse it. That's almost certainly problematic (leading to bugs) or wasteful -- <code>parseInt(42)</code> is silly, and <code>parseInt(42.3)</code> is an abuse of <code>parseInt(..)</code> to do the job of <code>Math.floor(..)</code>. <p>Parsing pulls out numeric-looking characters from the string value, and puts them into a <code>number</code> value, stopping once it encounters a character that's non-numeric (e.g., not <code>-</code>, <code>.</code> or <code>0</code>-<code>9</code>). If parsing fails on the first character, both utilities return the special <code>NaN</code> value (see \"Invalid Number\" below), indicating the operation was invalid and failed.</p> <p>When <code>parseInt(..)</code> encounters the <code>.</code> in <code>\"123.456\"</code>, it stops, using just the <code>123</code> in the resulting <code>number</code> value. <code>parseFloat(..)</code> by contrast accepts this <code>.</code> character, and keeps right on parsing a float with any decimal digits after the <code>.</code>.</p> <p>The <code>parseInt(..)</code> utility specifically, takes as an optional -- but actually, rather necessary -- second argument, <code>radix</code>: the numeric base to assume for interpreting the string characters for the <code>number</code> (range <code>2</code> - <code>36</code>). <code>10</code> is for standard base-10 numbers, <code>2</code> is for binary, <code>8</code> is for octal, and <code>16</code> is for hexadecimal. Any other unusual <code>radix</code>, like <code>23</code>, assumes digits in order, <code>0</code> - <code>9</code> followed by the <code>a</code> - <code>z</code> (case insensitive) character ordination. If the specified radix is outside the <code>2</code> - <code>36</code> range, <code>parseInt(..)</code> fails as invalid and returns the <code>NaN</code> value.</p> <p>If <code>radix</code> is omitted, the behavior of <code>parseInt(..)</code> is rather nuanced and confusing, in that it attempts to make a best-guess for a radix, based on what it sees in the first character. This historically has lead to lots of subtle bugs, so never rely on the default auto-guessing; always specify an explicit radix (like <code>10</code> in the calls above).</p> <p><code>parseFloat(..)</code> always parses with a radix of <code>10</code>, so no second argument is accepted.</p> WARNING: One surprising difference between <code>parseInt(..)</code> and <code>parseFloat(..)</code> is that <code>parseInt(..)</code> will not fully parse scientific notation (e.g., <code>\"1.23e+5\"</code>), instead stopping at the <code>.</code> as it's not valid for integers; in fact, even <code>\"1e+5\"</code> stops at the <code>\"e\"</code>. <code>parseFloat(..)</code> on the other hand fully parses scientific notation as expected. <p>In contrast to parsing-conversion, coercive-conversion is an all-or-nothing sort of operation. Either the entire contents of the string are recognized as numeric (integer or floating-point), or the whole conversion fails (resulting in <code>NaN</code> -- again, see \"Invalid Number\" later in this chapter).</p> <p>Coercive-conversion can be done explicitly with the <code>Number(..)</code> function (no <code>new</code> keyword) or with the unary <code>+</code> operator in front of the value:</p> <pre><code>someNumericText = \"123.456\";\nNumber(someNumericText);        // 123.456\n+someNumericText;               // 123.456\nNumber(\"512px\");                // NaN\n+\"512px\";                       // NaN\n</code></pre>"},{"location":"types-grammar/ch1/#other-numeric-representations","title":"Other Numeric Representations","text":"<p>In addition to defining numbers using traditional base-10 numerals (<code>0</code>-<code>9</code>), JS supports defining whole-number-only number literals in three other bases: binary (base-2), octal (base-8), and hexadecimal (base-16).</p> <pre><code>// binary\nmyAge = 0b101010;\nmyAge;              // 42\n// octal\nmyAge = 0o52;\nmyAge;              // 42\n// hexadecimal\nmyAge = 0x2a;\nmyAge;              // 42\n</code></pre> <p>As you can see, the prefixes <code>0b</code> (binary), <code>0o</code> (octal), and <code>0x</code> (hexadecimal) signal defining numbers in the different bases, but decimals are not allowed on these numeric literals.</p> NOTE: JS syntax allows <code>0B</code>, <code>0O</code>, and <code>0X</code> prefixes as well. However, please don't ever use those uppercase prefix forms. I think any sensible person would agree: <code>0O</code> is much easier to confuse at a glance than <code>0o</code> (which is, itself, a bit visually ambiguous at a glance). Always stick to the lowercase prefix forms! <p>It's important to realize that you're not defining a different number, just using a different form to produce the same underlying numeric value.</p> <p>By default, JS represents the underlying numeric value in output/string fashion with standard base-10 form. However, <code>number</code> values have a built-in <code>toString(..)</code> method that produces a string representation in any specified base/radix (as with <code>parseInt(..)</code>, in the range <code>2</code> - <code>36</code>):</p> <pre><code>myAge = 42;\nmyAge.toString(2);          // \"101010\"\nmyAge.toString(8);          // \"52\"\nmyAge.toString(16);         // \"2a\"\nmyAge.toString(23);         // \"1j\"\nmyAge.toString(36);         // \"16\"\n</code></pre> <p>You can round-trip any arbitrary-radix string representation back into a <code>number</code> using <code>parseInt(..)</code>, with the appropriate radix:</p> <pre><code>myAge = 42;\nparseInt(myAge.toString(\"23\"),23);      // 42\n</code></pre> <p>Another allowed form for specifying number literals is using scientific notation:</p> <pre><code>myAge = 4.2E1;      // or 4.2e1 or 4.2e+1\nmyAge;              // 42\n</code></pre> <p><code>4.2E1</code> (or <code>4.2e1</code>) means, <code>4.2 * (10 ** 1)</code> (<code>10</code> to the <code>1</code> power). The exponent can optionally have a sign <code>+</code> or <code>-</code>. If the sign is omitted, it's assumed to be <code>+</code>. A negative exponent makes the number smaller (moves the decimal leftward) rather than larger (moving the decimal rightward):</p> <pre><code>4.2E-3;             // 0.0042\n</code></pre> <p>This scientific notation form is especially useful for readability when specifying larger powers of <code>10</code>:</p> <pre><code>someBigPowerOf10 = 1000000000;\n// vs:\nsomeBigPowerOf10 = 1e9;\n</code></pre> <p>By default, JS will represent (e.g., as string values, etc) either very large or very small numbers -- specifically, if the values require more than 21 digits of precision -- using this same scientific notation:</p> <pre><code>ratherBigNumber = 123 ** 11;\nratherBigNumber.toString();     // \"9.748913698143826e+22\"\nprettySmallNumber = 123 ** -11;\nprettySmallNumber.toString();   // \"1.0257553107587752e-23\"\n</code></pre> <p>Numbers with smaller absolute values (closer to <code>0</code>) than these thresholds can still be forced into scientific notation form (as strings):</p> <pre><code>plainBoringNumber = 42;\nplainBoringNumber.toExponential();      // \"4.2e+1\"\nplainBoringNumber.toExponential(0);     // \"4e+1\"\nplainBoringNumber.toExponential(4);     // \"4.2000e+1\"\n</code></pre> <p>The optional argument to <code>toExponential(..)</code> specifies the number of decimal digits to include in the string representation.</p> <p>Another readability affordance for specifying numeric literals in code is the ability to insert <code>_</code> as a digit separator wherever its convenient/meaningful to do so. For example:</p> <pre><code>someBigPowerOf10 = 1_000_000_000;\ntotalCostInPennies = 123_45;  // vs 12_345\n</code></pre> <p>The decision to use <code>12345</code> (no separator), <code>12_345</code> (like \"12,345\"), or <code>123_45</code> (like \"123.45\") is entirely up to the author of the code; JS ignores the separators. But depending on the context, <code>123_45</code> could be more semantically meaningful (readability wise) than the more traditional three-digit-grouping-from-the-right-separated-with-commas style mimicked with <code>12_345</code>.</p>"},{"location":"types-grammar/ch1/#ieee-754-bitwise-binary-representations","title":"IEEE-754 Bitwise Binary Representations","text":"<p>IEEE-7543 is a technical standard for binary representation of decimal numbers. It's widely used by most computer programming languages, including JS, Python, Ruby, etc.</p> <p>I'm not going to cover it exhaustively, but I think a brief primer on how numbers work in languages like JS is more than warranted, given how few programmers have any familiarity with it.</p> <p>In 64-bit IEEE-754 -- so called \"double-precision\", because originally IEEE-754 used to be 32-bit, and now it's double that! -- the 64 bits are divided into three sections: 52 bits for the number's base value (aka, \"fraction\", \"mantissa\", or \"significand\"), 11 bits for the exponent to raise <code>2</code> to before multiplying, and 1 bit for the sign of the ultimate value.</p> NOTE: Since only 52 of the 64 bits are actually used to represent the base value, <code>number</code> doesn't actually have <code>2^64</code> values in it. According to the specification for the <code>number</code> type4, the number of values is precisely <code>2^64 - 2^53 + 3</code>, or about 18 quintillion, split about evenly between positive and negative numbers. <p>These bits are arranged left-to-right, as so (S = Sign Bit, E = Exponent Bit, M = Mantissa Bit):</p> <pre><code>SEEEEEEEEEEEMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n</code></pre> <p>So, the number <code>42</code> (or <code>42.000000</code>) would be represented by these bits:</p> <pre><code>// 42:\n01000000010001010000000000000000\n00000000000000000000000000000000\n</code></pre> <p>The sign bit is <code>0</code>, meaning the number is positive (<code>1</code> means negative).</p> <p>The 11-bit exponent is binary <code>10000000100</code>, which in base-10 is <code>1028</code>. But in IEEE-754, this value is interpreted as being stored unsigned with an \"exponent bias\" of <code>1023</code>, meaning that we're shifting up the exponent range from <code>-1022:1023</code> to <code>1:2046</code> (where <code>0</code> and <code>2047</code> are reserved for special representations). So, take <code>1028</code> and subtract the bias <code>1023</code>, which gives an effective exponent of <code>5</code>. We raise <code>2</code> to that value (<code>2^5</code>), giving <code>32</code>.</p> NOTE: If the subtracting <code>1023</code> from the exponent value gives a negative (e.g., <code>-3</code>), that's still interpreted as <code>2</code>'s exponent; raising <code>2</code> to negative numbers just produces smaller and smaller values. <p>The remaining 52 bits give us the base value <code>01010000...</code>, interpreted as binary decimal <code>1.0101000...</code> (with all trailing zeros). Converting that to base-10, we get <code>1.3125000...</code>. Finally, then multiply that by <code>32</code> already computed from the exponent. The result: <code>42</code>.</p> <p>As you might be able to tell now, this IEEE-754 number representation standard is called \"floating point\" because the decimal point \"floats\" back-and-forth along the bits, depending on the specified exponent value.</p> <p>The number <code>42.0000001</code>, which is only different from <code>42.000000</code> by just <code>0.0000001</code>, would be represented by these bits:</p> <pre><code>// 42.0000001:\n01000000010001010000000000000000\n00000000110101101011111110010101\n</code></pre> <p>Notice how the previous bit pattern and this one differ by quite a few bits in the trailing positions! The binary decimal fraction containing all those extra <code>1</code> bits (<code>1.010100000000...01011111110010101</code>) converts to base-10 as <code>1.31250000312500003652</code>, which multipled by <code>32</code> gives us exactly <code>42.0000001</code>.</p> <p>We'll revisit more details about floating-point (im)precision in Chapter 2. But now you understand a bit more about how IEEE-754 works!</p>"},{"location":"types-grammar/ch1/#number-limits","title":"Number Limits","text":"<p>As might be evident now that you've seen how IEEE-754 works, the 52 bits of the number's base must be shared, representing both the whole number portion (if any) as well as the decimal portion (if any), of the intended <code>number</code> value. Essentially, the larger the whole number portion to be represented, the less bits are available for the decimal portion, and vice versa.</p> <p>The largest value that can accurately be stored in the <code>number</code> type is exposed as <code>Number.MAX_VALUE</code>:</p> <pre><code>Number.MAX_VALUE;           // 1.7976931348623157e+308\n</code></pre> <p>You might expect that value to be a decimal value, given the representation. But on closer inspection, <code>1.79E308</code> is (approximately) <code>2^1024 - 1</code>. That seems much more like it should be an integer, right? We can verify:</p> <pre><code>Number.isInteger(Number.MAX_VALUE);         // true\n</code></pre> <p>But what happens if you go above the max value?</p> <pre><code>Number.MAX_VALUE === (Number.MAX_VALUE + 1);\n// true -- oops!\nNumber.MAX_VALUE === (Number.MAX_VALUE + 10000000);\n// true\n</code></pre> <p>So, is <code>Number.MAX_VALUE</code> actually the largest value representable in JS? It's certainly the largest finite <code>number</code> value.</p> <p>IEEE-754 defines a special infinite value, which JS exposes as <code>Infinity</code>; there's also a <code>-Infinity</code> at the far other end of the number line. Values can be tested to see if they are finite or infinite:</p> <pre><code>Number.isFinite(Number.MAX_VALUE);  // true\nNumber.isFinite(Infinity);          // false\nNumber.isFinite(-Infinity);         // false\n</code></pre> <p>You can't ever count upwards (with <code>+ 1</code>) from <code>Number.MAX_VALUE</code> to <code>Infinity</code>, no matter how long you let the program run, because the <code>+ 1</code> operation isn't actually incrementing beyond the top <code>Number.MAX_VALUE</code> value.</p> <p>However, JS arithmetic operations (<code>+</code>, <code>*</code>, and even <code>/</code>) can definitely overflow the <code>number</code> type on the top-end, in which case <code>Infinity</code> is the result:</p> <pre><code>Number.MAX_VALUE + 1E291;           // 1.7976931348623157e+308\nNumber.MAX_VALUE + 1E292;           // Infinity\nNumber.MAX_VALUE * 1.0000000001;    // Infinity\n1 / 1E-308;                         // 1e+308\n1 / 1E-309;                         // Infinity\n</code></pre> TIP: The reverse is not true: an arithmetic operation on an infinite value will never produce a finite value. <p>Going from the very large to the very, very small -- actually, closest to zero, which is not the same thing as going very, very negative! -- the smallest absolute decimal value you could theoretically store in the <code>number</code> type would be <code>2^-1022</code> (remember the IEEE-754 exponent range?), or around <code>2E-308</code>. However, JS engines are allowed by the specification to vary in their internal representations for this lower limit. Whatever the engine's effective lower limit is, it'll be exposed as <code>Number.MIN_VALUE</code>:</p> <pre><code>Number.MIN_VALUE;               // 5e-324 &lt;-- usually!\n</code></pre> <p>Most JS engines seem to have a minimum representable value around <code>5E-324</code> (about <code>2^-1074</code>). Depending on the engine and/or platform, a different value may be exposed. Be careful about any program logic that relies on such implementation-dependent values.</p>"},{"location":"types-grammar/ch1/#safe-integer-limits","title":"Safe Integer Limits","text":"<p>Since <code>Number.MAX_VALUE</code> is an integer, you might assume that it's the largest integer in the language. But that's not really accurate.</p> <p>The largest integer you can accurately store in the <code>number</code> type is <code>2^53 - 1</code>, or <code>9007199254740991</code>, which is way smaller than <code>Number.MAX_VALUE</code> (about <code>2^1024 - 1</code>). This special safer value is exposed as <code>Number.MAX_SAFE_INTEGER</code>:</p> <pre><code>maxInt = Number.MAX_SAFE_INTEGER;\nmaxInt;             // 9007199254740991\nmaxInt + 1;         // 9007199254740992\nmaxInt + 2;         // 9007199254740992\n</code></pre> <p>We've seen that integers larger than <code>9007199254740991</code> can show up. However, those larger integers are not \"safe\", in that the precision/accuracy start to break down when you do operations with them. As shown above, the <code>maxInt + 1</code> and <code>maxInt + 2</code> expressions both errantly give the same result, illustrating the hazard when exceeding the <code>Number.MAX_SAFE_INTEGER</code> limit.</p> <p>But what's the smallest safe integer?</p> <p>Depending on how you interpret \"smallest\", you could either answer <code>0</code> or... <code>Number.MIN_SAFE_INTEGER</code>:</p> <pre><code>Number.MIN_SAFE_INTEGER;    // -9007199254740991\n</code></pre> <p>And JS provides a utiltity to determine if a value is an integer in this safe range (<code>-2^53 + 1</code> - <code>2^53 - 1</code>):</p> <pre><code>Number.isSafeInteger(2 ** 53);      // false\nNumber.isSafeInteger(2 ** 53 - 1);  // true\n</code></pre>"},{"location":"types-grammar/ch1/#double-zeros","title":"Double Zeros","text":"<p>It may surprise you to learn that JS has two zeros: <code>0</code>, and <code>-0</code> (negative zero). But what on earth is a \"negative zero\"? 5 A mathematician would surely balk at such a notion.</p> <p>This isn't just a funny JS quirk; it's mandated by the IEEE-7543 specification. All floating point numbers are signed, including zero. And though JS does kind of hide the existence of <code>-0</code>, it's entirely possible to produce it and to detect it:</p> <pre><code>function isNegZero(v) {\nreturn v == 0 &amp;&amp; (1 / v) == -Infinity;\n}\nregZero = 0 / 1;\nnegZero = 0 / -1;\nregZero === negZero;        // true -- oops!\nObject.is(-0,regZero);      // false -- phew!\nObject.is(-0,negZero);      // true\nisNegZero(regZero);         // false\nisNegZero(negZero);         // true\n</code></pre> <p>You may wonder why we'd ever need such a thing as <code>-0</code>. It can be useful when using numbers to represent both the magnitude of movement (speed) of some item (like a game character or an animation) and also its direction (e.g., negative = left, positive = right).</p> <p>Without having a signed zero value, you couldn't tell which direction such an item was pointing at the moment it came to rest.</p> NOTE: While JS defines a signed zero in the <code>number</code> type, there is no corresponding signed zero in the <code>bigint</code> number type. As such, <code>-0n</code> is just interpreted as <code>0n</code>, and the two are indistinguishable."},{"location":"types-grammar/ch1/#invalid-number","title":"Invalid Number","text":"<p>Mathematical operations can sometimes produce an invalid result. For example:</p> <pre><code>42 / \"Kyle\";            // NaN\n</code></pre> <p>It's probably obvious, but if you try to divide a number by a string, that's an invalid mathematical operation.</p> <p>Another type of invalid numeric operation is trying to coercively-convert a non-numeric resembling value to a <code>number</code>. As discussed earlier, we can do so with either the <code>Number(..)</code> function or the unary <code>+</code> operator:</p> <pre><code>myAge = Number(\"just a number\");\nmyAge;                  // NaN\n+undefined;             // NaN\n</code></pre> <p>All such invalid operations (mathematical or coercive/numeric) produce the special <code>number</code> value called <code>NaN</code>.</p> <p>The historical root of \"NaN\" (from the IEEE-7543 specification) is as an acronym for \"Not a Number\". Technically, there are about 9 quadrillion values in the 64-bit IEEE-754 number space designated as \"NaN\", but JS treats all of them indistinguishably as the single <code>NaN</code> value.</p> <p>Unfortunately, that not a number meaning produces confusion, since <code>NaN</code> is absolutely a <code>number</code>.</p> TIP: Why is <code>NaN</code> a <code>number</code>?!? Think of the opposite: what if a mathematical/numeric operation, like <code>+</code> or <code>/</code>, produced a non-<code>number</code> value (like <code>null</code>, <code>undefined</code>, etc)? Wouldn't that be really strange and unexpected? What if they threw exceptions, so that you had to <code>try..catch</code> all your math? The only sensible behavior is, numeric/mathematical operations should always produce a <code>number</code>, even if that value is invalid because it came from an invalid operation. <p>To avoid such confusion, I strongly prefer to define \"NaN\" as any of the following instead:</p> <ul> <li>\"iNvalid Number\"</li> <li>\"Not actual Number\"</li> <li>\"Not available Number\"</li> <li>\"Not applicable Number\"</li> </ul> <p><code>NaN</code> is a special value in JS, in that it's the only value in the language that lacks the identity property -- it's never equal to itself.</p> <pre><code>NaN === NaN;            // false\n</code></pre> <p>So unfortunately, the <code>===</code> operator cannot check a value to see if it's <code>NaN</code>. But there are some ways to do so:</p> <pre><code>politicianIQ = \"nothing\" / Infinity;\nNumber.isNaN(politicianIQ);         // true\nObject.is(NaN,politicianIQ);        // true\n[ NaN ].includes(politicianIQ);     // true\n</code></pre> <p>Here's a fact of virtually all JS programs, whether you realize it or not: <code>NaN</code> happens. Seriously, almost all programs that do any math or numeric conversions are subject to <code>NaN</code> showing up.</p> <p>If you're not properly checking for <code>NaN</code> in your programs where you do math or numeric conversions, I can say with some degree of certainty: you probably have a number bug in your program somewhere, and it just hasn't bitten you yet (that you know of!).</p> WARNING: JS originally provided a global function called <code>isNaN(..)</code> for <code>NaN</code> checking, but it unfortunately has a long-standing coercion bug. <code>isNaN(\"Kyle\")</code> returns <code>true</code>, even though the string value <code>\"Kyle\"</code> is most definitely not the <code>NaN</code> value. This is because the global <code>isNaN(..)</code> function forces any non-<code>number</code> argument to coerce to a <code>number</code> first, before checking for <code>NaN</code>. Coercing <code>\"Kyle\"</code> to a <code>number</code> produces <code>NaN</code>, so now the function sees a <code>NaN</code> and returns <code>true</code>! This buggy global <code>isNaN(..)</code> still exists in JS, but should never be used. When <code>NaN</code> checking, always use <code>Number.isNaN(..)</code>, <code>Object.is(..)</code>, etc."},{"location":"types-grammar/ch1/#biginteger-values","title":"BigInteger Values","text":"<p>As the maximum safe integer in JS <code>number</code>s is <code>9007199254740991</code> (see above), such a relatively low limit can present a problem if a JS program needs to perform larger integer math, or even just hold values like 64-bit integer IDs (e.g., Twitter Tweet IDs).</p> <p>For that reason, JS provides the alternate <code>bigint</code> type (BigInteger), which can store arbitrarily large (theoretically not limited, except by finite machine memory and/or JS implementation) integers.</p> <p>To distinguish a <code>bigint</code> from a whole (integer) <code>number</code> value, which would otherwise both look the same (<code>42</code>), JS requires an <code>n</code> suffix on <code>bigint</code> values:</p> <pre><code>myAge = 42n;        // this is a bigint, not a number\nmyKidsAge = 11;     // this is a number, not a bigint\n</code></pre> <p>Let's illustrate the upper un-boundedness of <code>bigint</code>:</p> <pre><code>Number.MAX_SAFE_INTEGER;        // 9007199254740991\nNumber.MAX_SAFE_INTEGER + 2;    // 9007199254740992 -- oops!\nmyBigInt = 9007199254740991n;\nmyBigInt + 2n;                  // 9007199254740993n -- phew!\nmyBigInt ** 2n;                 // 81129638414606663681390495662081n\n</code></pre> <p>As you can see, the <code>bigint</code> value-type is able to do precise arithmetic above the integer limit of the <code>number</code> value-type.</p> WARNING: Notice that the <code>+</code> operator required <code>.. + 2n</code> instead of just <code>.. + 2</code>? You cannot mix <code>number</code> and <code>bigint</code> value-types in the same expression. This restriction is annoying, but it protects your program from invalid mathematical operations that would give non-obvious unexpected results. <p>A <code>bigint</code> value can also be created with the <code>BigInt(..)</code> function; for example, to convert a whole (integer) <code>number</code> value to a <code>bigint</code>:</p> <pre><code>myAge = 42n;\ninc = 1;\nmyAge += BigInt(inc);\nmyAge;              // 43n\n</code></pre> WARNING: Though it may seem counter-intuitive to some readers, <code>BigInt(..)</code> is always called without the <code>new</code> keyword. If <code>new</code> is used, an exception will be thrown. <p>That's definitely one of the most common usages of the <code>BigInt(..)</code> function: to convert <code>number</code>s to <code>bigint</code>s, for mathematical operation purposes.</p> <p>But it's not that uncommon to represent large integer values as strings, especially if those values are coming to the JS environment from other language environments, or via certain exchange formats, which themselves do not support <code>bigint</code>-style values.</p> <p>As such, <code>BigInt(..)</code> is useful to coerce those string values to <code>bigint</code>s:</p> <pre><code>myBigInt = BigInt(\"12345678901234567890\");\nmyBigInt;                       // 12345678901234567890n\n</code></pre> <p>Unlike <code>parseInt(..)</code>, if any character in the string is non-numeric (<code>0-9</code> digits or <code>-</code>), including <code>.</code> or even a trailing <code>n</code> suffix character, an exception will be thrown. In other words, <code>BigInt(..)</code> is an all-or-nothing coercion-conversion, not a parsing-conversion.</p> NOTE: I think it's absurd that <code>BigInt(..)</code> won't accept the trailing <code>n</code> character while string coercing (and thus effectively ignore it). I lobbied vehemently for that behavior, in the TC39 process, but was ultimately denied. In my opinion, it's now a tiny little gotcha wart on JS, but a wart nonetheless."},{"location":"types-grammar/ch1/#symbol-values","title":"Symbol Values","text":"<p>The <code>symbol</code> type contains special opaque values called \"symbols\". These values can only be created by the <code>Symbol(..)</code> function:</p> <pre><code>secret = Symbol(\"my secret\");\n</code></pre> WARNING: Just as with <code>BigInt(..)</code>, the <code>Symbol(..)</code> function must be called without the <code>new</code> keyword. <p>The <code>\"my secret\"</code> string passed into the <code>Symbol(..)</code> function call is not the symbol value itself, even though it seems that way. It's merely an optional descriptive label, used only for debugging purposes for the benefit of the developer.</p> <p>The underlying value returned from <code>Symbol(..)</code> is a special kind of value that resists the program/developer inspecting anything about its underlying representation. That's what I mean by \"opaque\".</p> NOTE: You could think of symbols as if they are monotonically incrementing integer numbers -- indeed, that's similar to how at least some JS engines implement them. But the JS engine will never expose any representation of a symbol's underlying value in any way that you or the program can see. <p>Symbols are guaranteed by the JS engine to be unique (only within the program itself), and are unguessable. In other words, a duplicate symbol value can never be created in a program.</p> <p>You might be wondering at this point what symbols are used for?</p> <p>One typical usage is as \"special\" values that the developer distinguishes from any other values that could accidentally collide. For example:</p> <pre><code>EMPTY = Symbol(\"not set yet\");\nmyNickname = EMPTY;\n// later:\nif (myNickname == EMPTY) {\n// ..\n}\n</code></pre> <p>Here, I've defined a special <code>EMPTY</code> value and initialized <code>myNickname</code> to it. Later, I check to see if it's still that special value, and then perform some action if so. I might not want to have used <code>null</code> or <code>undefined</code> for such purposes, as another developer might be able to pass in one of those common built-in values. <code>EMPTY</code> by contrast here is a unique, unguessable value that only I've defined and have control over and access to.</p> <p>Perhaps even more commonly, symbols are often used as special (meta-) properties on objects:</p> <pre><code>myInfo = {\nname: \"Kyle Simpson\",\nnickname: \"getify\",\nage: 42\n};\n// later:\nPRIVATE_ID = Symbol(\"private unique ID, don't touch!\");\nmyInfo[PRIVATE_ID] = generateID();\n</code></pre> <p>It's important to note that symbol properties are still publicly visible on any object; they're not actually private. But they're treated as special and set-apart from the normal collection of object properties. It's similar to if I had done instead:</p> <pre><code>Object.defineProperty(myInfo,\"__private_id_dont_touch\",{\nvalue: generateID(),\nenumerable: false,\n});\n</code></pre> <p>By convention only, most developers know that if a property name is prefixed with <code>_</code> (or even moreso, <code>__</code>!), that means it's \"pseudo-private\" and to leave it alone unless they're really supposed to access it.</p> <p>Symbols basically serve the same use-case, but a bit more ergonomically than the prefixing approach.</p>"},{"location":"types-grammar/ch1/#well-known-symbols-wks","title":"Well-Known Symbols (WKS)","text":"<p>JS pre-defines a set of symbols, referred to as well-known symbols (WKS), that represent certain special meta-programming hooks on objects. These symbols are stored as static properties on the <code>Symbol</code> function object. For example:</p> <pre><code>myInfo = {\n// ..\n};\nString(myInfo);         // [object Object]\nmyInfo[Symbol.toStringTag] = \"my-info\";\nString(myInfo);         // [object my-info]\n</code></pre> <p><code>Symbol.toStringTag</code> is a well-known symbol for accessing and overriding the default string representation of a plain object (<code>\"[object Object]\"</code>), replacing the <code>\"Object\"</code> part with a different value (e.g., <code>\"my-info\"</code>).</p> <p>See the \"Objects &amp; Classes\" book of this series for more information about Well-Known Symbols and metaprogramming.</p>"},{"location":"types-grammar/ch1/#global-symbol-registry","title":"Global Symbol Registry","text":"<p>Often, you want to keep symbol values private, such as inside a module scope. But occasionally, you want to expose them so they're accessible globally throughout all the files in a JS program.</p> <p>Instead of just attaching them as global variables (i.e., properties on the <code>globalThis</code> object), JS provides an alternate global namespace to register symbols in:</p> <pre><code>// retrieve if already registered,\n// otherwise register\nPRIVATE_ID = Symbol.for(\"private-id\");\n// elsewhere:\nprivateIDKey = Symbol.keyFor(PRIVATE_ID);\nprivateIDKey;           // \"private-id\"\n// elsewhere:\n// retrieve symbol from registry undeer\n// specified key\nprivateIDSymbol = Symbol.for(privateIDKey);\n</code></pre> <p>The value passed to <code>Symbol.for(..)</code> is not the same as passed to <code>Symbol(..)</code>. <code>Symbol.for(..)</code> expects a unique key for the symbol to be registered under in the global registry, whereas <code>Symbol(..)</code> optionally accepts a descriptive label (not necessarily unique).</p> <p>If the registry doesn't have a symbol under that specified key, a new symbol (with no descriptive label) is created and automatically registered there. Otherwise, <code>Symbol.for(..)</code> returns whatever previously registered symbol is under that key.</p> <p>Going in the opposite direction, if you have the symbol value itself, and want to retrieve the key it's registered under, <code>Symbol.keyFor(..)</code> takes the symbol itself as input, and returns the key (if any). That's useful in case it's more convenient to pass around the key string value than the symbol itself.</p>"},{"location":"types-grammar/ch1/#object-or-primitive","title":"Object or Primitive?","text":"<p>Unlike other primitives like <code>42</code>, where you can create multiple copies of the same value, symbols do act more like specific object references in that they're always completely unique (for purposes of value assignment and equality comparison). The specification also categorizes the <code>Symbol()</code> function under the \"Fundamental Objects\" section, calling the function a \"constructor\", and even defining its <code>prototype</code> property.</p> <p>However, as mentioned earlier, <code>new</code> cannot be used with <code>Symbol(..)</code>; this is similar to the <code>BigInt()</code> \"constructor\". We clearly know <code>bigint</code> values are primitives, so <code>symbol</code> values seem to be of the same kind.</p> <p>And in the specification's \"Terms and Definitions\", it lists symbol as a primitive value. 1 Moreover, the values themselves are used in JS programs as primitives rather than objects. For example, symbols are primarily used as keys in objects -- we know objects cannot use other object values as keys! -- along with strings, which are also primitives.</p> <p>As mentioned earlier, some JS engines even internally implement symbols as unique, monotonically incrementing integers (primitives!).</p> <p>Finally, as explained at the top of this chapter, we know primitive values are not allowed to have properties set on them, but are auto-boxed (see \"Automatic Objects\" in Chapter 3) internally to the corresponding object-wrapper type to facilitate property/method access. Symbols follow all these exact behaviors, the same as all the other primitives.</p> <p>All this considered, I think symbols are much more like primitives than objects, so that's how I present them in this book.</p>"},{"location":"types-grammar/ch1/#primitives-are-built-in-types","title":"Primitives Are Built-In Types","text":"<p>We've now dug deeply into the seven primitive (non-object) value types that JS provides automatically built-in.</p> <p>Before we move on to discussing JS's built-in object value type, we want to take a closer look at the kinds of behaviors we can expect from JS values. We'll do so in-depth, in the next chapter.</p> <ol> <li> <p>\"4.4.5 primitive value\", ECMAScript 2022 Language Specification; https://tc39.es/ecma262/#sec-primitive-value ; Accessed August 2022\u00a0\u21a9\u21a9</p> </li> <li> <p>\"JavaScript\u2019s internal character encoding: UCS-2 or UTF-16?\"; Mathias Bynens; January 20 2012; https://mathiasbynens.be/notes/javascript-encoding ; Accessed July 2022\u00a0\u21a9</p> </li> <li> <p>\"IEEE-754\"; https://en.wikipedia.org/wiki/IEEE_754 ; Accessed July 2022\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>\"6.1.6.1 The Number Type\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-ecmascript-language-types-number-type ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"Signed Zero\", Wikipedia; https://en.wikipedia.org/wiki/Signed_zero ; Accessed August 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"types-grammar/ch2/","title":"Chapter 2: Primitive Behaviors","text":"NOTE: Work in progress <p>So far, we've explored seven built-in primitive value types in JS: <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>string</code>, <code>number</code>, <code>bigint</code>, and <code>symbol</code>.</p> <p>Chapter 1 was quite a lot to take in, much more involved than I bet most readers expected. If you're still catching your breath after reading all that, don't worry about taking a bit of a break before continuing on here!</p> <p>Once you're clear headed and ready to move on, let's dig into certain behaviors implied by value types for all their respective values. We'll take a careful and  closer look at all of these various behaviors.</p>"},{"location":"types-grammar/ch2/#primitive-immutability","title":"Primitive Immutability","text":"<p>All primitive values are immutable, meaning nothing in a JS program can reach into the contents of the value and modify it in any way.</p> <pre><code>myAge = 42;\n// later:\nmyAge = 43;\n</code></pre> <p>The <code>myAge = 43</code> statement doesn't change the value. It reassigns a different value <code>43</code> to <code>myAge</code>, completely replacing the previous value of <code>42</code>.</p> <p>New values are also created through various operations, but again these do not modify the original value:</p> <pre><code>42 + 1;             // 43\n\"Hello\" + \"!\";      // \"Hello!\"\n</code></pre> <p>The values <code>43</code> and <code>\"Hello!\"</code> are new, distinct values from the previous <code>42</code> and <code>\"Hello\"</code> values, respectively.</p> <p>Even a string value, which looks like merely an array of characters -- and array contents are typically mutable -- is immutable:</p> <pre><code>greeting = \"Hello.\";\ngreeting[5] = \"!\";\nconsole.log(greeting);      // Hello.\n</code></pre> WARNING: In non-strict mode, assigning to a read-only property (like <code>greeting[5] = ..</code>) silently fails. In strict-mode, the disallowed assignment will throw an exception. <p>The nature of primitive values being immutable is not affected in any way by how the variable or object property holding the value is declared. For example, whether <code>const</code>, <code>let</code>, or <code>var</code> are used to declare the <code>greeting</code> variable above, the string value it holds is immutable.</p> <p><code>const</code> doesn't create immutable values, it declares variables that cannot be reassigned (aka, immutable assignments) -- see the \"Scope &amp; Closures\" title of this series for more information.</p> <p>A property on an object may be marked as read-only -- with the <code>writable: false</code> descriptor attribute, as discussed in the \"Objects &amp; Classes\" title of this series. But that still has no affect on the nature of the value, only on preventing the reassignment of the property.</p>"},{"location":"types-grammar/ch2/#primitives-with-properties","title":"Primitives With Properties?","text":"<p>Additionally, properties cannot be added to any primitive values:</p> <pre><code>greeting = \"Hello.\";\ngreeting.isRendered = true;\ngreeting.isRendered;        // undefined\n</code></pre> <p>This snippet looks like it's adding a property <code>isRendered</code> to the value in <code>greeting</code>, but this assignment silently fails (even in strict-mode).</p> <p>Property access is not allowed in any way on nullish primitive values <code>null</code> and <code>undefined</code>. But properties can be accessed on all other primitive values -- yes, that sounds counter-intuitive.</p> <p>For example, all string values have a read-only <code>length</code> property:</p> <pre><code>greeting = \"Hello.\";\ngreeting.length;            // 6\n</code></pre> <p><code>length</code> can not be set, but it can be accesses, and it exposes the number of code-units stored in the value (see \"JS Character Encodings\" in Chapter 1), which often means the number of characters in the string.</p> NOTE: Sort of. For most standard characters, that's true; one character is one code-point, which is one code-unit. However, as explained in Chapter 1, extended Unicode characters above code-point <code>65535</code> will be stored as two code-units (surrogate halves). Thus, for each such character, <code>length</code> will include <code>2</code> in its count, even though the character visually prints as one symbol. <p>Non-nullish primitive values also have a couple of standard built-in methods that can be accessed:</p> <pre><code>greeting = \"Hello.\";\ngreeting.toString();    // \"Hello.\" &lt;-- redundant\ngreeting.valueOf();     // \"Hello.\"\n</code></pre> <p>Additionally, most of the primitive value-types define their own methods with specific behaviors inherent to that type. We'll cover these later in this chapter.</p> NOTE: As already briefly mentioned in Chapter 1, technically, these sorts of property/method accesses on primitive values are facilitated by an implicit coercive behavior called auto-boxing. We'll cover this in detail in \"Automatic Objects\" in Chapter 3."},{"location":"types-grammar/ch2/#primitive-assignments","title":"Primitive Assignments","text":"<p>Any assignment of a primitive value from one variable/container to another is a value-copy:</p> <pre><code>myAge = 42;\nyourAge = myAge;        // assigned by value-copy\nmyAge;                  // 42\nyourAge;                // 42\n</code></pre> <p>Here, the <code>myAge</code> and <code>yourAge</code> variables each have their own copy of the number value <code>42</code>.</p> NOTE: Inside the JS engine, it may be the case that only one <code>42</code> value exists in memory, and the engine points both <code>myAge</code> and <code>yourAge</code> variables at the shared value. Since primitive values are immutable, there's no danger in a JS engine doing so. But what's important to us as JS developers is, in our programs, <code>myAge</code> and <code>yourAge</code> act as if they have their own copy of that value, rather than sharing it. <p>If we later reassign <code>myAge</code> to <code>43</code> (when I have a birthday), it doesn't affect the <code>42</code> that's still assigned to <code>yourAge</code>:</p> <pre><code>myAge++;            // sort of like: myAge = myAge + 1\nmyAge;              // 43\nyourAge;            // 42 &lt;-- unchanged\n</code></pre>"},{"location":"types-grammar/ch2/#string-behaviors","title":"String Behaviors","text":"<p>String values have a number of specific behaviors that every JS developer should be aware of.</p>"},{"location":"types-grammar/ch2/#string-character-access","title":"String Character Access","text":"<p>Though strings are not actually arrays, JS allows <code>[ .. ]</code> array-style access of a character at a numeric (<code>0</code>-based) index:</p> <pre><code>greeting = \"Hello!\";\ngreeting[4];            // \"o\"\n</code></pre> <p>If the value/expression between the <code>[ .. ]</code> doesn't resolve to a number, the value will be implicitly coerced to its whole/integer numeric representation (if possible).</p> <pre><code>greeting[\"4\"];          // \"o\"\n</code></pre> <p>If the value/expression resolves to a number outside the integer range of <code>0</code> - <code>length - 1</code> (or <code>NaN</code>), or if it's not a <code>number</code> value-type, the access will instead be treated as a property access with the string equivalent property name. If the property access thus fails, the result is <code>undefined</code>.</p> NOTE: We'll cover coercion in-depth later in the book."},{"location":"types-grammar/ch2/#character-iteration","title":"Character Iteration","text":"<p>Strings are not arrays, but they certainly mimick arrays closely in many ways. One such behavior is that, like arrays, strings are iterables. This means that the characters (code-units) of a string can be iterated individually:</p> <pre><code>myName = \"Kyle\";\nfor (let char of myName) {\nconsole.log(char);\n}\n// K\n// y\n// l\n// e\nchars = [ ...myName ];\nchars;\n// [ \"K\", \"y\", \"l\", \"e\" ]\n</code></pre> <p>Values, such as strings and arrays, are iterables (via <code>...</code>, <code>for..of</code>, and <code>Array.from(..)</code>), if they expose an iterator-producing method at the special symbol property location <code>Symbol.iterator</code> (see \"Well-Known Symbols\" in Chapter 1):</p> <pre><code>myName = \"Kyle\";\nit = myName[Symbol.iterator]();\nit.next();      // { value: \"K\", done: false }\nit.next();      // { value: \"y\", done: false }\nit.next();      // { value: \"l\", done: false }\nit.next();      // { value: \"e\", done: false }\nit.next();      // { value: undefined, done: true }\n</code></pre> NOTE: The specifics of the iterator protocol, including the fact that the <code>{ value: \"e\" .. }</code> result still shows <code>done: false</code>, are covered in detail in the \"Sync &amp; Async\" title of this series."},{"location":"types-grammar/ch2/#length-computation","title":"Length Computation","text":"<p>As mentioned in Chapter 1, string values have a <code>length</code> property that automatically exposes the length of the string; this property can only be accessed; attempts to set it are silently ignored.</p> <p>The reported <code>length</code> value somewhat corresponds to the number of characters in the string (actually, code-units), but as we saw in Chapter 1, it's more complex when Unicode characters are involved.</p> <p>Most people visually distinguish symbols as separate characters; this notion of an independent visual symbol is referred to as a grapheme, or a grapheme cluster. So when counting the \"length\" of a string, we typically mean that we're counting the number of graphemes.</p> <p>But that's not how the computer deals with characters.</p> <p>In JS, each character is a code-unit (16 bits), with a code-point value at or below <code>65535</code>. The <code>length</code> property of a string always counts the number of code-units in the string value, not code-points. A code-unit might represent a single character by itself, or it may be part of a surrogate pair, or it may be combined with an adjacent combining symbol, or part of a grapheme cluster. As such, <code>length</code> doesn't match the typical notion of counting visual characters/graphemes.</p> <p>To get closer to an expected/intuitive grapheme length for a string, the string value first needs to be normalized with <code>normalize(\"NFC\")</code> (see \"Normalizing Unicode\" in Chapter 1) to produce any composed code-units (where possible), in case any characters were originally stored decomposed as separate code-units.</p> <p>For example:</p> <pre><code>favoriteItem = \"tele\u0301fono\";\nfavoriteItem.length;            // 9 -- uh oh!\nfavoriteItem = favoriteItem.normalize(\"NFC\");\nfavoriteItem.length;            // 8 -- phew!\n</code></pre> <p>Unfortunately, as we saw in Chapter 1, we'll still have the possibility of characters of code-point greater the <code>65535</code>, and thus needing a surrogate pair to be represented. Such characters will count double in the <code>length</code>:</p> <pre><code>// \"\u260e\" === \"\\u260E\"\noldTelephone = \"\u260e\";\noldTelephone.length;            // 1\n// \"\ud83d\udcf1\" === \"\\u{1F4F1}\" === \"\\uD83D\\uDCF1\"\ncellphone = \"\ud83d\udcf1\";\ncellphone.length;               // 2 -- oops!\n</code></pre> <p>So what do we do?</p> <p>One fix is to use character iteration (via <code>...</code> operator) as we saw in the previous section, since it automatically returns each combined character from a surrogate pair:</p> <pre><code>cellphone = \"\ud83d\udcf1\";\ncellphone.length;               // 2 -- oops!\n[ ...cellphone ].length;        // 1 -- phew!\n</code></pre> <p>But, unfortunately, grapheme clusters (as explained in Chapter 1) throw yet another wrench into a string's length computation. For example, if we take the thumbs down emoji (<code>\"\\u{1F44E}\"</code> and add to it the skin-tone modifier for medium-dark skin (<code>\"\\u{1F3FE}\"</code>), we get:</p> <pre><code>// \"\ud83d\udc4e\ud83c\udffe\" = \"\\u{1F44E}\\u{1F3FE}\"\nthumbsDown = \"\ud83d\udc4e\ud83c\udffe\";\nthumbsDown.length;              // 4 -- oops!\n[ ...thumbsDown ].length;       // 2 -- oops!\n</code></pre> <p>As you can see, these are two distinct code-points (not a surrogate pair) that, by virtue of their ordering and adjacency, cause the computer's Unicode rendering to draw the thumbs-down symbol but with a darker skin tone than its default. The computed string length is thus <code>2</code>.</p> <p>It would take replicating most of a platform's complex Unicode rendering logic to be able to recognize such clusters of code-points as a single \"character\" for length-counting sake. There are libraries that purport to do so, but they're not necessarily perfect, and they come at a hefty cost in terms of extra code.</p> NOTE: As a Twitter user, you might expect to be able to put 280 thumbs-down emojis into a single tweet, since it looks like a single character. Twitter counts the <code>\"\ud83d\udc4e\"</code> (default thumbs-down), the <code>\"\ud83d\udc4e\ud83c\udffe\"</code> (medium-dark-skintone thumbs-down), and even the <code>\"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66\"</code> (family emoji grapheme cluster) all as 2 characters each, even though their respective string lengths (from JS's perspective) are <code>2</code>, <code>4</code>, and <code>7</code>; thus, you can only fit half the number of emojis (140 instead of 280) in a tweet. In fact, Twitter implemented this change in 2018 to specifically level the counting of all Unicode characters, at 2 characters per symbol. 1 That was a welcomed change for Twitter users, especially those who want to use emoji characters that are most representative of intended gender, skintone, etc. Still, it is curious that Twitter chose to count all Unicode/emoji symbols as 2 characters each, instead of the more intuitive 1 character (grapheme) each. <p>Counting the length of a string to match our human intuitions is a remarkably challenging task, perhaps more of an art than a science. We can get acceptable approximations in many cases, but there's plenty of other cases that may confound our programs.</p>"},{"location":"types-grammar/ch2/#internationalization-i18n-and-localization-l10n","title":"Internationalization (i18n) and Localization (l10n)","text":"<p>To serve the growing need for JS programs to operate as expected in any international language/culture context, the ECMAScript committee also publishes the ECMAScript Internationalization API. 2</p> <p>A JS program defaults to a locale/language according to the environment running the program (web browser page, Node instance, etc). The in-effect locale affects sorting (and value comparisons), formatting, and several other assumed behaviors. Such altered behaviors are perhaps a bit more obvious with strings, but they can also be seen with numbers (and dates!).</p> <p>But string characters also can have language/locale information embedded in them, which takes precedence over the environment default. If the string character is ambiguous/shared in terms of its language/locale (such as <code>\"a\"</code>), the default environment setting is used.</p> <p>Depending on the contents of the string, it may be interpreted as being ordered from left-to-right (LTR) or right-to-left (RTL). As such, many of the string methods we'll cover later use logical descriptors in their names, like \"start\", \"end\", \"begin\", \"end\", and \"last\", rather than directional terms like \"left\" and \"right\".</p> <p>For example, Hebrew and Arabic are both common RTL languages:</p> <pre><code>hebrewHello = \"\\u{5e9}\\u{5dc}\\u{5d5}\\u{5dd}\";\nconsole.log(hebrewHello);                       // \u05e9\u05dc\u05d5\u05dd\n</code></pre> <p>Notice that the first listed character in the string literal (<code>\"\\u{5e9}\"</code>) is actually the right-most character when the string is rendered?</p> <p>Even though Hebrew is an RTL language, you don't actually type the characters in the string literal in reversed (RTL) order the way they should be rendered. You enter the characters in logical order, where position <code>0</code> is the first character, position <code>1</code> is the second character, etc. The rendering layer is where RTL characters are reversed to be shown in their correct order.</p> <p>That also means that if you access <code>hebrewHello[0]</code> (or <code>hebrewHello.charAt(0)</code>) -- to get the character as position <code>0</code> -- you get <code>\"\u05e9\"</code> because that's logically the first character of the string, not <code>\"\u05dd\"</code> (logically the last character of the string). Index-positional access follows the logical position, not the rendered position.</p> <p>Here's the same example in another RTL language, Arabic:</p> <pre><code>arabicHello = \"\\u{631}\\u{62d}\\u{628}\\u{627}\";\nconsole.log(arabicHello);                       // \u0631\u062d\u0628\u0627\nconsole.log(arabicHello[0]);                    // \u0631\n</code></pre> <p>JS programs can force a specific language/locale, using various <code>Intl</code> APIs such as <code>Intl.Collator</code>: 3</p> <pre><code>germanStringSorter = new Intl.Collator(\"de\");\nlistOfGermanWords = [ /* .. */ ];\ngermanStringSorter.compare(\"Hallo\",\"Welt\");\n// -1 (or negative number)\n// examples adapted from MDN:\n//\ngermanStringSorter.compare(\"Z\",\"z\");\n// 1 (or positive number)\ncaseFirstSorter = new Intl.Collator(\"de\",{ caseFirst: \"upper\", });\ncaseFirstSorter.compare(\"Z\",\"z\");\n// -1 (or negative number)\n</code></pre> <p>Multiple-word strings can be segmented using <code>Intl.Segmenter</code>: 4</p> <pre><code>arabicHelloWorld = \"\\u{645}\\u{631}\\u{62d}\\u{628}\\u{627} \\\n\\u{628}\\u{627}\\u{644}\\u{639}\\u{627}\\u{644}\\u{645}\";\nconsole.log(arabicHelloWorld);      // \u0645\u0631\u062d\u0628\u0627 \u0628\u0627\u0644\u0639\u0627\u0644\u0645\narabicSegmenter = new Intl.Segmenter(\"ar\",{ granularity: \"word\" });\nfor (\nlet { segment: word, isWordLike } of\narabicSegmenter.segment(arabicHelloWorld)\n) {\nif (isWordLike) {\nconsole.log(word);\n}\n}\n// \u0645\u0631\u062d\u0628\u0627\n//\u0644\u0639\u0627\u0644\u0645\n</code></pre> NOTE: The <code>segment(..)</code> method (from instances of<code>Intl.Segmenter</code>) returns a standard JS iterator, which the <code>for..of</code> loop here consumes. More on iteration protocols in the \"Sync &amp; Async\" title of this series."},{"location":"types-grammar/ch2/#string-comparison","title":"String Comparison","text":"<p>String values can be compared (for both equality and relational ordering) to other string values, using various built-in operators. It's important to keep in mind that such comparisons are sensitive to the actual string contents, including especially the underlying code-points from non-BPM Unicode characters.</p> <p>Both equality and relational comparison are case-sensitive, for any characters where uppercase and lowercase are well-defined. To make case-insensitive comparisons, normalize the casing of both values first (with <code>toUpperCase()</code> or <code>toLowerCase()</code>).</p>"},{"location":"types-grammar/ch2/#string-equality","title":"String Equality","text":"<p>The <code>===</code> and <code>==</code> operators (along with their negated counterparts <code>!==</code> and <code>!=</code>, respectively) are the most common way equality comparisons are made for primitive values, including string values:</p> <pre><code>\"my name\" === \"my n\\x61me\";               // true\n\"my name\" !== String.raw`my n\\x61me`;     // true\n</code></pre> <p>The <code>===</code> operator5 -- often referred to as \"strict equality\" -- first checks to see if the types match, and if not, returns <code>false</code> right away. If the types match, then it checks to see if the values are the same; for strings, this is a per-code-unit comparison, from start to end.</p> <p>Despite the \"strict\" naming, there are nuances to <code>===</code> (such as <code>-0</code> and <code>NaN</code> handling), but we'll cover those later.</p>"},{"location":"types-grammar/ch2/#coercive-equality","title":"Coercive Equality","text":"<p>By contrast, the <code>==</code> operator6 -- often referred to as \"loose equality\" -- performs coercive equality: if the value-types of the two operands do not match, <code>==</code> first coerces one or both operands until the value-types do match, and then it hands off the comparison internally to <code>===</code>.</p> <p>Coercion is an extremely important topic -- it's an inherent part of the JS types system, one of the language's 3 pillars -- but we're only going to briefly introduce it here in this chapter, and revisit it in detail later.</p> NOTE: You may have heard the oft-quoted, but nevertheless inaccurate, explanation that the difference between <code>==</code> and <code>===</code> is that <code>==</code> compares the values while <code>==</code> compares both the values and the types. Not true, and you can read the spec yourself to verify -- both <code>isStrictlyEqual(..)</code> and <code>isLooselyEqual(..)</code> specification algorithms are linked as footnotes in the preceding paragraphs. To summarize, though: both <code>==</code> and <code>===</code> are aware of and sensitive to the types of the operands. If the operand types are the same, both operators do literally the exact same thing; if the types differ, <code>==</code> forces coercion until the types match, whereas <code>===</code> returns <code>false</code> immediately. <p>It's extremely common for developers to assert that the <code>==</code> operator is confusing and too hard to use without surprises (thus the near universal preference for <code>===</code>). I think that's totally bogus, and in fact, JS developers should be defaulting to <code>==</code> (and avoiding <code>===</code> if possible). But we need a lot more discussion to back such a controversial statement; hold onto your objections until we revisit it later.</p> <p>For now, to gain some intuition about the coercive nature of <code>==</code>, the most illuminating observation is that if the types don't match, <code>==</code> prefers numeric comparison. That means it will attempt to convert both operands to numbers, and then perform the equality check (the same as <code>===</code>).</p> <p>So, as it relates to our present discussion, actual string equality can only be checked if both operands are already strings:</p> <pre><code>// actual string equality check (via === internally):\n\"42\" == \"42\";           // true\n</code></pre> <p><code>==</code> does not really perform string equality checks itself. If the operand value-types are both strings, <code>==</code> just hands off the comparison to <code>===</code>. If they're not both strings, the coercive steps in <code>==</code> will reduce the comparison matching to numeric instead of string:</p> <pre><code>// numeric (not string!) equality check:\n42 == \"42\";             // true\n</code></pre> <p>We'll cover numeric equality later in this chapter.</p>"},{"location":"types-grammar/ch2/#really-strict-equality","title":"Really Strict Equality","text":"<p>In addition to <code>==</code> and <code>===</code>, JS provides the <code>Object.is(..)</code> utility, which returns <code>true</code> if both arguments are exactly identical, and <code>false</code> otherwise (no exceptions or nuances):</p> <pre><code>Object.is(\"42\",42);             // false\nObject.is(\"42\",\"\\x34\\x32\");     // true\n</code></pre> <p>Since <code>===</code> adds a <code>=</code> onto the end of <code>==</code> to make it more strict in behavior, I kind of half-joke that the <code>Object.is(..)</code> utility is like a <code>====</code> (a fourth <code>=</code> added) operator, for the really-truly-strict-no-exceptions kind of equality checking!</p> <p>That said, <code>===</code> (and <code>==</code> by virtue of its internal delegation to <code>===</code>) are extremely predictable, with no weird exceptions, when it comes to comparing two actually-already-string values. I strongly recommend using <code>==</code> for such checks (or <code>===</code>), and reserve <code>Object.is(..)</code> for the corner cases (which are numeric).</p>"},{"location":"types-grammar/ch2/#string-relational-comparisons","title":"String Relational Comparisons","text":"<p>In addition to equality checks between strings, JS supports relational comparisons between primitive values, like strings: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p> <p>The <code>&lt;</code> (less-than) and <code>&gt;</code> (greater-than) operations compare two string values lexicographically -- like you would sort words in a dictionary -- and should thus be fairly self explanatory:</p> <pre><code>\"hello\" &lt; \"world\";          // true\n</code></pre> NOTE: As mentioned earlier, the running JS program has a default locale, and these operators compare according to that locale. <p>Like <code>==</code>, the <code>&lt;</code> and <code>&gt;</code> operators are numerically coercive. Any non-number values are coerced to numbers. So the only way to do a relational comparison with strings is to ensure both operands are already string values.</p> <p>Perhaps somewhat surprisingly, the <code>&lt;</code> and <code>&gt;</code> have no strict-comparison equivalent, the way <code>===</code> avoids the coercion of <code>==</code>. These operators are always coercive (when the types don't match), and there's no way in JS to avoid that.</p> <p>So what happens when both values are numeric-looking strings?</p> <pre><code>\"100\" &lt; \"11\";               // true\n</code></pre> <p>Numerically, of course, <code>100</code> should not be less than <code>11</code>.</p> <p>But relational comparisons between two strings use the lexicographic ordering. So the second <code>\"0\"</code> character (in <code>\"100\"</code>) is less than the second <code>\"1\"</code> (in <code>\"11\"</code>), and thus <code>\"100\"</code> would be sorted in a dictionary before <code>\"11\"</code>. The relational operators only coerce to numbers if the operand types are not already strings.</p> <p>The <code>&lt;=</code> (less-than-or-equal) and <code>&gt;=</code> (greater-than-or-equal) operators are effectively a shorthand for a compound check.</p> <pre><code>\"hello\" &lt;= \"hello\";                             // true\n(\"hello\" &lt; \"hello\") || (\"hello\" == \"hello\");    // true\n\"hello\" &gt;= \"hello\";                             // true\n(\"hello\" &gt; \"hello\") || (\"hello\" == \"hello\");    // true\n</code></pre> NOTE: Here's an interesting bit of specification nuance: JS doesn't actually define the underlying greater-than (for <code>&gt;</code>) or greater-than-or-equal (for <code>&gt;=</code>) operations. Instead, it defines them by reversing the arguments to their less-than complement counterparts. So <code>x &gt; y</code> is treated by JS essentially as <code>y &lt;= x</code>, and <code>x &gt;= y</code> is treated by JS essentially as <code>y &lt; x</code>. So JS only needs to specify how <code>&lt;</code> and <code>==</code> work, and thus gets <code>&gt;</code> and <code>&gt;=</code> for free!"},{"location":"types-grammar/ch2/#locale-aware-relational-comparisons","title":"Locale-Aware Relational Comparisons","text":"<p>As I mentioned a moment ago, the relational operators assume and use the current in-effect locale. However, it can sometimes be useful to force a specific locale for comparisons (such as when sorting a list of strings).</p> <p>JS provides the method <code>localCompare(..)</code> on JS strings for this purpose:</p> <pre><code>\"hello\".localeCompare(\"world\");\n// -1 (or negative number)\n\"world\".localeCompare(\"hello\",\"en\");\n// 1 (or positive number)\n\"hello\".localeCompare(\"hello\",\"en\",{ ignorePunctuation: true });\n// 0\n// examples from MDN:\n//\n// in German, \u00e4 sorts before z\n\"\u00e4\".localeCompare(\"z\",\"de\");\n// -1 (or negative number) // a negative value\n// in Swedish, \u00e4 sorts after z\n\"\u00e4\".localeCompare(\"z\",\"sv\");\n// 1 (or positive number)\n</code></pre> <p>The optional second and third arguments to <code>localeCompare(..)</code> control which locale to use, via the <code>Intl.Collator</code> API[^INTLCollatorApi], as covered earlier.</p> <p>You might use <code>localeCompare(..)</code> when sorting an array of strings:</p> <pre><code>studentNames = [\n\"Lisa\",\n\"Kyle\",\n\"Jason\"\n];\n// Array::sort() mutates the array in place\nstudentNames.sort(function alphabetizeNames(name1,name2){\nreturn name1.localeCompare(name2);\n});\nstudentNames;\n// [ \"Jason\", \"Kyle\", \"Lisa\" ]\n</code></pre> <p>But as discussed earlier, a more straightforward way (and slightly more performant when sorting many strings) is using <code>Intl.Collator</code> directly:</p> <pre><code>studentNames = [\n\"Lisa\",\n\"Kyle\",\n\"Jason\"\n];\nnameSorter = new Intl.Collator(\"en\");\n// Array::sort() mutates the array in place\nstudentNames.sort(nameSorter.compare);\nstudentNames;\n// [ \"Jason\", \"Kyle\", \"Lisa\" ]\n</code></pre>"},{"location":"types-grammar/ch2/#string-concatenation","title":"String Concatenation","text":"<p>Two or more string values can be concatenated (combined) into a new string value, using the <code>+</code> operator:</p> <pre><code>greeting = \"Hello, \" + \"Kyle!\";\ngreeting;               // Hello, Kyle!\n</code></pre> <p>The <code>+</code> operator will act as a string concatenation if either of the two operands (values on left or right sides of the operator) are already a string (even an empty string <code>\"\"</code>).</p> <p>If one operand is a string and the other is not, the one that's not a string will be coerced to its string representation for the purposes of the concatenation:</p> <pre><code>userCount = 7;\nstatus = \"There are \" + userCount + \" users online\";\nstatus;         // There are 7 users online\n</code></pre> <p>String concatenation of this sort is essentially interpolation of data into the string, which is the main purpose of template literals (see Chapter 1). So the following code will have the same outcome but is generally considered to be the more preferred approach:</p> <pre><code>userCount = 7;\nstatus = `There are ${userCount} users online`;\nstatus;         // There are 7 users online\n</code></pre> <p>Other options for string concatenation include <code>\"one\".concat(\"two\",\"three\")</code> and <code>[ \"one\", \"two\", \"three\" ].join(\"\")</code>, but these kinds of approaches are only preferable when the number of strings to concatenate is dependent on runtime conditions/computation. If the string has a fixed/known set of content, as above, template literals are the better option.</p>"},{"location":"types-grammar/ch2/#string-value-methods","title":"String Value Methods","text":"<p>String values provide a whole slew of additional string-specific methods (as properties):</p> <ul> <li> <p><code>charAt(..)</code>: produces a new string value at the numeric index, similar to <code>[ .. ]</code>; unlike <code>[ .. ]</code>, the result is always a string, either the character at position <code>0</code> (if a valid number outside the indices range), or the empty string <code>\"\"</code> (if missing/invalid index)</p> </li> <li> <p><code>at(..)</code> is similar to <code>charAt(..)</code>, but negative indices count backwards from the end of the string</p> </li> <li> <p><code>charCodeAt(..)</code>: returns the numeric code-unit (see \"JS Character Encodings\" in Chapter 1) at the specified index</p> </li> <li> <p><code>codePointAt(..)</code>: returns the whole code-point starting at the specified index; if a surrogate pair is found there, the whole character (code-point) s returned</p> </li> <li> <p><code>substr(..)</code> / <code>substring(..)</code> / <code>slice(..)</code>: produces a new string value that represents a range of characters from the original string; these differ in how the range's start/end indices are specified or determined</p> </li> <li> <p><code>toUpperCase()</code>: produces a new string value that's all uppercase characters</p> </li> <li> <p><code>toLowerCase()</code>: produces a new string value that's all lowercase characters</p> </li> <li> <p><code>toLocaleUpperCase()</code> / <code>toLocaleLowerCase()</code>: uses locale mappings for uppercase or lowercase operations</p> </li> <li> <p><code>concat(..)</code>: produces a new string value that's the concatenation of the original string and all of the string value arguments passed in</p> </li> <li> <p><code>indexOf(..)</code>: searches for a string value argument in the original string, optionally starting from the position specified in the second argument; returns the <code>0</code>-based index position if found, or <code>-1</code> if not found</p> </li> <li> <p><code>lastIndexOf(..)</code>: like <code>indexOf(..)</code> but, from the end of the string (right in LTR locales, left in RTL locales)</p> </li> <li> <p><code>includes(..)</code>: similar to <code>indexOf(..)</code> but returns a boolean result</p> </li> <li> <p><code>search(..)</code>: similar to <code>indexOf(..)</code> but with a regular-expression matching as specified</p> </li> <li> <p><code>trimStart()</code> / <code>trimEnd()</code> / <code>trim()</code>: produces a new string value with whitespace trimmed from the start of the string (left in LTR locales, right in RTL locales), or the end of the string (right in LTR locales, left in RTL locales), or both</p> </li> <li> <p><code>repeat(..)</code>: produces a new string with the original string value repeated the specified number of times</p> </li> <li> <p><code>split(..)</code>: produces an array of string values as split at the specified string or regular-expression boundaries</p> </li> <li> <p><code>padStart(..)</code> / <code>padEnd(..)</code>: produces a new string value with padding (default \" \" whitespace, but can be overriden) applied to either the start (left in LTR locales, right in RTL locales) or the end (right in LTR locales), left in RTL locales), so that the final string result is at least of a specified length</p> </li> <li> <p><code>startsWith(..)</code> / <code>endsWith(..)</code>: checks either the start (left in LTR locales, right in RTL locales) or the end (right in LTR locales) of the original string for the string value argument; returns a boolean result</p> </li> <li> <p><code>match(..)</code> / <code>matchAll(..)</code>: returns an array-like regular-expression matching result against the original string</p> </li> <li> <p><code>replace(..)</code>: returns a new string with a replacement from the original string, of one or more matching occurrences of the specified regular-expression match</p> </li> <li> <p><code>normalize(..)</code>: produces a new string with Unicode normalization (see \"Unicode Normalization\" in Chapter 1) having been performed on the contents</p> </li> <li> <p><code>localCompare(..)</code>: function that compares two strings according to the current locale (useful for sorting); returns a negative number (usually <code>-1</code> but not guaranteed) if the original string value is comes before the argument string value lexicographically, a positive number (usually <code>1</code> but not guaranteed) if the original string value comes after the argument string value lexicographically, and <code>0</code> if the two strings are identical</p> </li> <li> <p><code>anchor()</code>, <code>big()</code>, <code>blink()</code>, <code>bold()</code>, <code>fixed()</code>, <code>fontcolor()</code>, <code>fontsize()</code>, <code>italics()</code>, <code>link()</code>, <code>small()</code>, <code>strike()</code>, <code>sub()</code>, and <code>sup()</code>: historically, these were useful in generating HTML string snippets; they're now deprecated and should be avoided</p> </li> </ul> WARNING: Many of the methods described above rely on position indices. As mentioned earlier in the \"Length Computation\" section, these positions are dependent on the internal contents of the string value, which means that if an extended Unicode character is present and takes up two code-unit slots, that will count as two index positions instead of one. Failing to account for decomposed code-units, surrogate pairs, and grapheme cluseters is a common source of bugs in JS string handling. <p>These string methods can all be called directly on a literal value, or on a variable/property that's holding a string value. When applicable, they produce a new string value rather than modifying the existing string value (since strings are immutable):</p> <pre><code>\"all these letters\".toUpperCase();      // ALL THESE LETTERS\ngreeting = \"Hello!\";\ngreeting.repeat(2);                     // Hello!Hello!\ngreeting;                               // Hello!\n</code></pre>"},{"location":"types-grammar/ch2/#static-string-helpers","title":"Static <code>String</code> Helpers","text":"<p>The following string utility functions are proviced directly on the <code>String</code> object, rather than as methods on individual string values:</p> <ul> <li> <p><code>String.fromCharCode(..)</code> / <code>String.fromCodePoint(..)</code>: produce a string from one or more arguments representing the code-units (<code>fromCharCode(..)</code>) or whole code-points (<code>fromCodePoint(..)</code>)</p> </li> <li> <p><code>String.raw(..)</code>: a default template-tag function that allows interpolation on a template literal but prevents character escape sequences from being parsed, so they remain in their raw individual input characters from the literal</p> </li> </ul> <p>Moreover, most values (especially primitives) can be explicitly coerced to their string equivalent by passing them to the <code>String(..)</code> function (no <code>new</code> keyword). For example:</p> <pre><code>String(true);           // \"true\"\nString(42);             // \"42\"\nString(Infinity);       // \"Infinity\"\nString(undefined);      // \"undefined\"\n</code></pre> <p>We'll cover much more detail about such type coercions in a later chapter.</p>"},{"location":"types-grammar/ch2/#number-behaviors","title":"Number Behaviors","text":"<p>Numbers are used for a variety of tasks in our programs, but mostly for mathematical computations. Pay close attention to how JS numbers behave, to ensure the outcomes are as expected.</p>"},{"location":"types-grammar/ch2/#floating-point-imprecision","title":"Floating Point Imprecision","text":"<p>We need to revisit our discussion of IEEE-754 from Chapter 1.</p> <p>One of the classic gotchas of any IEEE-754 number system in any programming language -- NOT UNIQUELY JS! -- is that not all operations and values can fit neatly into the IEEE-754 representations.</p> <p>The most common illustration is:</p> <pre><code>point3a = 0.1 + 0.2;\npoint3b = 0.3;\npoint3a;                        // 0.30000000000000004\npoint3b;                        // 0.3\npoint3a === point3b;            // false &lt;-- oops!\n</code></pre> <p>The operation <code>0.1 + 0.2</code> ends up creating floating-point error (drift), where the value stored is actually <code>0.30000000000000004</code>.</p> <p>The respective bit representations are:</p> <pre><code>// 0.30000000000000004\n00111111110100110011001100110011\n00110011001100110011001100110100\n\n// 0.3\n00111111110100110011001100110011\n00110011001100110011001100110011\n</code></pre> <p>If you look closely at those bit patterns, only the last 2 bits differ, from <code>00</code> to <code>11</code>. But that's enough for those two numbers to be unequal!</p> <p>Again, just to reinforce: this behavior is NOT IN ANY WAY unique to JS. This is exactly how any IEEE-754 conforming programming language will work in the same scenario. As I asserted above, the majority of all programming languages use IEEE-754, and thus they will all suffer this same fate.</p> <p>The temptation to make fun of JS for <code>0.1 + 0.2 !== 0.3</code> is strong, I know. But here it's completely bogus.</p> NOTE: Pretty much all programmers need to be aware of IEEE-754 and make sure they are careful about these kinds of gotchas. It's somewhat amazing, in a disappointing way, how few of them have any idea how IEEE-754 works. If you've taken your time reading and understanding these concepts so far, you're now in that rare tiny percentage who actually put in the effort to understand the numbers in their programs!"},{"location":"types-grammar/ch2/#epsilon-threshold","title":"Epsilon Threshold","text":"<p>A common piece of advice to work around such floating-point imprecision uses this very small <code>number</code> value defined by JS:</p> <pre><code>Number.EPSILON;                 // 2.220446049250313e-16\n</code></pre> <p>Epsilon is the smallest difference JS can represent between <code>1</code> and the next value greater than <code>1</code>. While this value is technically implementation/platform dependent, it's generally about <code>2.2E-16</code>, or <code>2^-52</code>.</p> <p>To those not paying close enough attention to the details here -- including my past self! -- it's generally assumed that any skew in floating point precision from a single operation should never be greater than <code>Number.EPSILON</code>. Thus, in theory, we can use <code>Number.EPSILON</code> as a very small tolerance value to ensure number equality comparisons are safe:</p> <pre><code>function safeNumberEquals(a,b) {\nreturn Math.abs(a - b) &lt; Number.EPSILON;\n}\npoint3a = 0.1 + 0.2;\npoint3b = 0.3;\n// are these safely \"equal\"?\nsafeNumberEquals(point3a,point3b);      // true\n</code></pre> WARNING: In the first edition \"Types &amp; Grammar\" book, I indeed recommended exactly this approach. I was wrong. I should have researched the topic more closely. <p>But, it turns out, this approach isn't safe at all:</p> <pre><code>point3a = 10.1 + 0.2;\npoint3b = 10.3;\nsafeNumberEquals(point3a,point3b);      // false :(\n</code></pre> <p>Well... that's a bummer!</p> <p>Unfortunately, <code>Number.EPSILON</code> only works as a \"safely equal\" error threshold for certain small numbers/operations, and in other cases, it's far too small, and yields false negatives.</p> <p>You could scale <code>Number.EPSILON</code> by some factor to produce a larger threshold that avoids false negatives but still filters out all the floating point skew in your program. But what factor to use is entirely a manual judgement call based on what magnitude of values, and operations on them, your program will entail. There's no automatic way to compute a reliable, universal threshold.</p> <p>Unless you really know what you're doing, you should just not use this <code>Number.EPSILON</code> threshold approach at all.</p> TIP: If you'd like to read more details and solid advice on this topic, I highly recommend reading this post. 7 But if we can't use <code>Number.EPSILON</code> to avoid the perils of floating-point skew, what do we do? If you can avoid floating-point altogether by scaling all your numbers up so they're all whole number integers (or bigints) while performing math, do so. Only deal with decimal values when you have to output/represent a final value after all the math is done. If that's not possible/practical, use an arbitrary precision decimal emulation library and avoid <code>number</code> values entirely. Or do your math in another external programming environment that's not based on IEEE-754."},{"location":"types-grammar/ch2/#numeric-comparison","title":"Numeric Comparison","text":"<p>Like strings, number values can be compared (for both equality and relational ordering) using the same operators.</p> <p>Remember that no matter what form the number value takes when being specified as a literal (base-10, octal, hexadecimal, exponential, etc), the underlying value stored is what will be compared. Also keep in mind the floating point imprecision issues discussed in the previous section, as the comparisons will be sensitive to the exact binary contents.</p>"},{"location":"types-grammar/ch2/#numeric-equality","title":"Numeric Equality","text":"<p>Just like strings, equality comparisons for numbers use either the <code>==</code> / <code>===</code> operators or <code>Object.is(..)</code>. Also recall that if the types of both operands are the same, <code>==</code> performs identically to <code>===</code>.</p> <pre><code>42 == 42;                   // true\n42 === 42;                  // true\n42 == 43;                   // false\n42 === 43;                  // false\nObject.is(42,42);           // true\nObject.is(42,43);           // false\n</code></pre> <p>For <code>==</code> coercive equality (when the operand types don't match), if either operand is not a string value, <code>==</code> prefers a numeric equality check (meaning both operands are coerced to numbers).</p> <pre><code>// numeric (not string!) comparison\n42 == \"42\";                 // true\n</code></pre> <p>In this snippet, the coercive equality coerces <code>\"42\"</code> to <code>42</code>, not vice versa (<code>42</code> to <code>\"42\"</code>). Once both types are <code>number</code>, then their values are compared for exact equality, the same as <code>===</code> would.</p> <p>Recall that JS doesn't distinguish between values like <code>42</code>, <code>42.0</code>, and <code>42.000000</code>; under the covers, they're all the same. Unsurpisingly, the <code>==</code> and <code>===</code> equality checks verify that:</p> <pre><code>42 == 42.0;                 // true\n42.0 == 42.00000;           // true\n42.00 === 42.000;           // true\n</code></pre> <p>The intuition you likely have is, if two numbers are literally the same, they're equal. And that's how JS interprets it. But <code>0.3</code> is not literally the same as the result of <code>0.1 + 0.2</code>, because (as we saw earlier), the latter produces an underlying value that's very close to <code>0.3</code>, but is not exactly identical.</p> <p>What's interesting is, the two values are so close that their difference is less than the <code>Number.EPSILON</code> threshold, so JS can't actually represent that difference accurately.</p> <p>You might then think, at least informally, that such JS numbers should be \"equal\", since the difference between them is too small to represent. But notice: JS can represent that there is a difference, which is why you see that <code>4</code> at the very end of the decimal when JS evaluates <code>0.1 + 0.2</code>. And you could type out the number literal <code>0.00000000000000004</code> (aka, <code>4e-17</code>), being that difference between <code>0.3</code> and <code>0.1 + 0.2</code>.</p> <p>What JS cannot do, with its IEEE-754 floating point numbers, is represent a number that small in an accurate enough way that operations on it produce expected results. It's too small to be fully and properly represented in the <code>number</code> type JS provides.</p> <p>So <code>0.1 + 0.2 == 0.3</code> resolves to <code>false</code>, because there's a difference between the two values, even though JS can't accurately represent or do anything with a value as small as that difference.</p> <p>Also like we saw with strings, the <code>!=</code> (coercive not-equal) and <code>!==</code> (strict-not-equal) operators work with numbers. <code>x != y</code> is basically <code>!(x == y)</code>, and <code>x !== y</code> is basically <code>!(x === y)</code>.</p> <p>There are two frustrating exceptions in numeric equality (whether you use <code>==</code> or <code>===</code>):</p> <pre><code>NaN === NaN;                // false -- ugh!\n-0 === 0;                   // true -- ugh!\n</code></pre> <p><code>NaN</code> is never equal to itself (even with <code>===</code>), and <code>-0</code> is always equal to <code>0</code> (even with <code>===</code>). It sometimes surprises folks that even <code>===</code> has these two exceptions in it.</p> <p>However, the <code>Object.is(..)</code> equality check has neither of these exceptions, so for equality comparisons with <code>NaN</code> and <code>-0</code>, avoid the <code>==</code> / <code>===</code> operators and use <code>Object.is(..)</code> -- or for <code>NaN</code> specifically, <code>Number.isNaN(..)</code>.</p>"},{"location":"types-grammar/ch2/#numeric-relational-comparisons","title":"Numeric Relational Comparisons","text":"<p>Just like with string values, the JS relational operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>) operate with numbers. The <code>&lt;</code> (less-than) and <code>&gt;</code> (greater-than) operations should be fairly self explanatory:</p> <pre><code>41 &lt; 42;                    // true\n0.1 + 0.2 &gt; 0.3;            // true (ugh, IEEE-754)\n</code></pre> <p>Remember: just like <code>==</code>, the <code>&lt;</code> and <code>&gt;</code> operators are also coercive, meaning that any non-number values are coerced to numbers -- unless both operands are already strings, as we saw earlier. There are no strict relational comparison operators.</p> <p>If you're doing relational comparisons between numbers, the only way to avoid coercion is to ensure that the comparisons always have two numbers. Otherwise, these operators will do coercive relational comparisons similar to how <code>==</code> performs coercive equality comparisons.</p>"},{"location":"types-grammar/ch2/#mathematical-operators","title":"Mathematical Operators","text":"<p>As I asserted earlier, the main reason to have numbers in a programming language is to perform mathematical operations with them. So let's talk about how we do so.</p> <p>The basic arithmetic operators are <code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication), and <code>/</code> (division). Also available are the operators <code>**</code> (exponentiation) and <code>%</code> (modulo, aka division remainder). There are also <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>**=</code>, and <code>%=</code> forms of the operators, which additionally assign the result back to the left operand -- must be a valid assignment target like a variable or property.</p> NOTE: As we've already seen, the <code>+</code> operator is overloaded to work with both numbers and strings. When one or both operands is a string, the result is a string concatenation (including coercing either operand to a string if necessary). But if neither operand is a string, the result is a numeric addition, as expected. <p>All these mathematical operators are binary, meaning they expect two value operands, one on either side of the operator; they all expect the operands to be number values. If either or both operands are non-numbers, the non-number operand(s) is/are coerced to numbers to perform the operation. We'll cover coercion in detail in a later chapter.</p> <p>Consider:</p> <pre><code>40 + 2;                 // 42\n44 - 2;                 // 42\n21 * 2;                 // 42\n84 / 2;                 // 42\n7 ** 2;                 // 49\n49 % 2;                 // 1\n40 + \"2\";               // \"402\" (string concatenation)\n44 - \"2\";               // 42 (because \"2\" is coerced to 2)\n21 * \"2\";               // 42 (..ditto..)\n84 / \"2\";               // 42 (..ditto..)\n\"7\" ** \"2\";             // 49 (both operands are coerced to numbers)\n\"49\" % \"2\";             // 1 (..ditto..)\n</code></pre> <p>The <code>+</code> and <code>-</code> operators also come in a unary form, meaning they only have one operand; again, the operand is expected to be a number, and coerced to a number if not:</p> <pre><code>+42;                    // 42\n-42;                    // -42\n+\"42\";                  // 42\n-\"42\";                  // -42\n</code></pre> <p>You might have noticed that <code>-42</code> looks like it's just a \"negative forty-two\" numeric literal. That's not quite right. A nuance of JS syntax is that it doesn't recognize negative numeric literals. Instead, JS treats this as a positive numeric literal <code>42</code> that's preceded, and negated, by the unary <code>-</code> operator in front of it.</p> <p>Somewhat surprisingly, then:</p> <pre><code>-42;                    // -42\n- 42;                   // -42\n-\n42;                 // -42\n</code></pre> <p>As you can see, whitespace (and even new lines) are allowed between the <code>-</code> unary operator and its operand; actually, this is true of all operators and operands.</p>"},{"location":"types-grammar/ch2/#increment-and-decrement","title":"Increment and Decrement","text":"<p>There are two other unary numeric operators: <code>++</code> (increment) and <code>--</code> decrement. They both perform their respective operation and then reassign the result to the operand -- must be a valid assignment target like a variable or property.</p> <p>You may sort of think of <code>++</code> as equivalent to <code>+= 1</code>, and <code>--</code> as equivalent to <code>-= 1</code>:</p> <pre><code>myAge = 42;\nmyAge++;\nmyAge;                  // 43\nnumberOfHeadHairs--;\n</code></pre> <p>However, these are special operators in that they can appear in a postfix (after the operand) position, as above, or in a prefix (before the operand) position:</p> <pre><code>myAge = 42;\n++myAge;\nmyAge;                  // 43\n--numberofHeadHairs;\n</code></pre> <p>It may seem peculiar that prefix and postfix positions seem to give the same result (incrementing or decrementing) in such examples. The difference is subtle, and isn't related to the final reassigned result. We'll revisit these particular operators in a later chapter to dig into the positional differences.</p>"},{"location":"types-grammar/ch2/#bitwise-operators","title":"Bitwise Operators","text":"<p>JS provides several bitwise operators to perform bit-level operations on number values.</p> <p>However, these bit operations are not performed against the packed bit-pattern of IEEE-754 numbers (see Chapter 1). Instead, the operand number is first converted to a 32-bit signed integer, the bit operation is performed, and then the result is converted back into an IEEE-754 number.</p> <p>Keep in mind, just like any other primitive operators, these just compute new values, not actually modifying a value in place.</p> <ul> <li> <p><code>&amp;</code> (bitwise AND): Performs an AND operation with each corresponding bit from the two operands; <code>42 &amp; 36 === 32</code> (i.e., <code>0b00...101010 &amp; 0b00...100100 === 0b00..100000</code>)</p> </li> <li> <p><code>|</code> (bitwise OR): Performs an OR operation with each corresponding bit from the two operands; <code>42 | 36 === 46</code> (i.e., <code>0b00...101010 | 0b00...100100 === 0b00...101110</code>)</p> </li> <li> <p><code>^</code> (bitwise XOR): Performs an XOR (eXclusive-OR) operation with each corresponding bit from the two operands; <code>42 ^ 36 === 14</code> (i.e., <code>0b00...101010 ^ 0b00...100100 === 0b00...001110</code>)</p> </li> <li> <p><code>~</code> (bitwise NOT): Performs a NOT operation against the bits of a single operand; <code>~42 === -43</code> (i.e., <code>~0b00...101010 === 0b11...010101</code>); using 2's complement, the signed integer has the first bit set to <code>1</code> meaning negative, and the rest of the bits (when flipped back, according to 2's complement, which is 1's complement bit flipping and then adding <code>1</code>) would be <code>43</code> (<code>0b10...101011</code>); the equivalent of <code>~</code> in decimal number arithmetic is <code>~x === -(x + 1)</code>, so <code>~42 === -43</code></p> </li> <li> <p><code>&lt;&lt;</code> (left shift): Performs a left-shift of the bits of the left operand by the count of bits specified by the right operand; <code>42 &lt;&lt; 3 == 336</code> (i.e., <code>0b00...101010 &lt;&lt; 3 === 0b00...101010000</code>)</p> </li> <li> <p><code>&gt;&gt;</code> (right shift): Performs a sign-propagating right-shift of the bits of the left operand by the count of bits specified by the right operand, discarding the bits that fall off the right side; whatever the leftmost bit is (<code>0</code>, or <code>1</code> is negative) is copied in as bits on the left (thereby preserving the sign of the original value in the result); <code>42 &gt;&gt; 3 === 5</code> (i.e., <code>0b00..101010 &gt;&gt; 3 === 0b00...000101</code>)</p> </li> <li> <p><code>&gt;&gt;&gt;</code> (zero-fill right shift, aka unsigned right shift): Performs the same right-shift as <code>&gt;&gt;</code>, but <code>0</code> fills on the bits shifted in from the left side instead of copying the leftmost bit (thereby ignoring the sign of the original value in the result); <code>42 &gt;&gt;&gt; 3 === 5</code> but <code>-43 &gt;&gt;&gt; 3 === 536870906</code> (i.e., <code>0b11...010101 &gt;&gt;&gt; 3 === 0b0001...111010</code>)</p> </li> <li> <p><code>&amp;=</code>, <code>|=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code> (bitwise operators with assignment): Performs the corresponding bitwise operation, but then assigns the result to the left operand (which must be a valid assignment target, like a variable or property, not just a literal value); note that <code>~=</code> is missing from the list, because there is no such \"binary negate with assignment\" operator</p> </li> </ul> <p>In all honesty, bitwise operations are not very common in JS. But you may sometimes see a statement like:</p> <pre><code>myGPA = 3.54;\nmyGPA | 0;              // 3\n</code></pre> <p>Since the bitwise operators act only on 32-bit integers, the <code>| 0</code> operation truncates (i.e., <code>Math.trunc(..)</code>) any decimal value, leaving only the integer.</p> WARNING: A common misconception is that <code>| 0</code> is like floor (i.e., <code>Math.floor(..)</code>). The result of <code>| 0</code> agrees with <code>Math.floor(..)</code> on positive numbers, but differs on negative numbers, because by standard definition, floor is an operation that rounds-down towards <code>-Infinity</code>. <code>| 0</code> merely discards the decimal bits, which is in fact truncation."},{"location":"types-grammar/ch2/#number-value-methods","title":"Number Value Methods","text":"<p>Number values provide the following methods (as properties) for number-specific operations:</p> <ul> <li> <p><code>toExponential(..)</code>: produces a string representation of the number using scientific notation (e.g., <code>\"4.2e+1\"</code>)</p> </li> <li> <p><code>toFixed(..)</code>: produces a non-scientific-notation string representation of the number with the specified number of decimal places (rounding or zero-padding as necessary)</p> </li> <li> <p><code>toPrecision(..)</code>: like <code>toFixed(..)</code>, except it applies the numeric argument as the number of significant digits (i.e., precision) including both the whole number and decimal places if any</p> </li> <li> <p><code>toLocaleString(..)</code>: produces a string representation of the number according to the current locale</p> </li> </ul> <pre><code>myAge = 42;\nmyAge.toExponential(3);         // \"4.200e+1\"\n</code></pre> <p>One particular nuance of JS syntax is that <code>.</code> can be ambiguous when dealing with number literals and property/method access.</p> <p>If a <code>.</code> comes immediately (no whitespace) after a numeric literal digit, and there's not already a <code>.</code> decimal in the number value, the <code>.</code> is assumed to be a starting the decimal portion of the number. But if the position of the <code>.</code> is unambiguously not part of the numeric literal, then it's always treated as a property access.</p> <pre><code>42 .toExponential(3);           // \"4.200e+1\"\n</code></pre> <p>Here, the whitespace disambiguates the <code>.</code>, designating it as a property/method access. It's perhaps more common/preferred to use <code>(..)</code> instead of whitespace for such disambiguation:</p> <pre><code>(42).toExponential(3);          // \"4.200e+1\"\n</code></pre> <p>An unusual-looking effect of this JS parsing grammar rule:</p> <pre><code>42..toExponential(3);           // \"4.200e+1\"\n</code></pre> <p>So called the \"double-dot\" idiom, the first <code>.</code> in this expression is a decimal, and thus the second <code>.</code> is unambiguously not a decimal, but rather a property/method access.</p> <p>Also, notice there's no digits after the first <code>.</code>; it's perfectly legal syntax to leave a trailing <code>.</code> on a numeric literal:</p> <pre><code>myAge = 41. + 1.;\nmyAge;                          // 42\n</code></pre> <p>Values of <code>bigint</code> type cannot have decimals, so the parsing is unambiguous that a <code>.</code> after a literal (with the trailing <code>n</code>) is always a property access:</p> <pre><code>42n.toString();                 // 42\n</code></pre>"},{"location":"types-grammar/ch2/#static-number-properties","title":"Static <code>Number</code> Properties","text":"<ul> <li> <p><code>Number.EPSILON</code>: The smallest value possible between <code>1</code> and the next highest number</p> </li> <li> <p><code>Number.NaN</code>: The same as the global <code>NaN</code> symbol, the special invalid number</p> </li> <li> <p><code>Number.MIN_SAFE_INTEGER</code> / <code>Number.MAX_SAFE_INTEGER</code>: The positive and negative integers with the largest absolute value (furthest from <code>0</code>)</p> </li> <li> <p><code>Number.MIN_VALUE</code> / <code>Number.MAX_VALUE</code>: The minimum (positive value closest to <code>0</code>) and the maximum (positive value furthest from <code>0</code>) representable by the <code>number</code> type</p> </li> <li> <p><code>Number.NEGATIVE_INFINITY</code> / <code>Number.POSITIVE_INFINITY</code>: Same as global <code>-Infinity</code> and <code>Infinity</code>, the values that represent the largest (non-finite) values furthest from <code>0</code></p> </li> </ul>"},{"location":"types-grammar/ch2/#static-number-helpers","title":"Static <code>Number</code> Helpers","text":"<ul> <li> <p><code>Number.isFinite(..)</code>: returns a boolean indicating if the value is finite -- a <code>number</code> that's not <code>NaN</code>, nor one of the two infinities</p> </li> <li> <p><code>Number.isInteger(..)</code> / <code>Number.isSafeInteger(..)</code>: both return booleans indicating if the value is a whole <code>number</code> with no decimal places, and if it's within the safe range for integers (<code>-2^53 + 1</code> - <code>2^53 - 1</code>)</p> </li> <li> <p><code>Number.isNaN(..)</code>: The bug-fixed version of the global <code>isNaN(..)</code> utility, which identifies if the argument provided is the special <code>NaN</code> value</p> </li> <li> <p><code>Number.parseFloat(..)</code> / <code>Number.parseInt(..)</code>: utilties to parse string values for numeric digits, left-to-right, until the end of the string or the first non-float (or non-integer) character is encountered</p> </li> </ul>"},{"location":"types-grammar/ch2/#static-math-namespace","title":"Static <code>Math</code> Namespace","text":"<p>Since the main usage of <code>number</code> values is for performing mathematical operations, JS includes many standard mathematical constants and operation utilities on the <code>Math</code> namespace.</p> <p>There's a bunch of these, so I'll omit listing every single one. But here's a few for illustration purposes:</p> <pre><code>Math.PI;                        // 3.141592653589793\n// absolute value\nMath.abs(-32.6);                // 32.6\n// rounding\nMath.round(-32.6);              // -33\n// min/max selection\nMath.min(100,Math.max(0,42));   // 42\n</code></pre> <p>Unlike <code>Number</code>, which is also the <code>Number(..)</code> function (for number coercion), <code>Math</code> is just an object that holds these properties and static function utilities; it cannot be called as a function.</p> WARNING: One peculiar member of the <code>Math</code> namespace is <code>Math.random()</code>, for producing a random floating point value between <code>0</code> and <code>1.0</code>. It's unusual to consider random number generation -- a task that's inherently stateful/side-effect'ing -- as a mathematical operation. It's also long been a footgun security-wise, as the pseudo-random number generator (PRNG) that JS uses is not secure (can be predicted) from a cryptography perspective. The web platform stepped in several years ago with the safer <code>crypto.getRandomValues(..)</code> API (based on a better PRNG), which fills a typed-array with random bits that can be interpreted as one or more integers (of type-specified maximum magnitude). Using <code>Math.random()</code> is universally discouraged now."},{"location":"types-grammar/ch2/#bigints-and-numbers-dont-mix","title":"BigInts and Numbers Don't Mix","text":"<p>As we covered in Chapter 1, values of <code>number</code> type and <code>bigint</code> type cannot mix in the same operations. That can trip you up even if you're doing a simple increment of the value (like in a loop):</p> <pre><code>myAge = 42n;\nmyAge + 1;                  // TypeError thrown!\nmyAge += 1;                 // TypeError thrown!\nmyAge + 1n;                 // 43n\nmyAge += 1n;                // 43n\nmyAge++;\nmyAge;                      // 44n\n</code></pre> <p>As such, if you're using both <code>number</code> and <code>bigint</code> values in your programs, you'll need to manually coerce one value-type to the other somewhat regularly. The <code>BigInt(..)</code> function (no <code>new</code> keyword) can coerce a <code>number</code> value to <code>bigint</code>. Vice versa, to go the other direction from <code>bigint</code> to <code>number</code>, use the <code>Number(..)</code> function (again, no <code>new</code> keyword):</p> <pre><code>BigInt(42);                 // 42n\nNumber(42n);                // 42\n</code></pre> <p>Keep in mind though: coercing between these types has some risk:</p> <pre><code>BigInt(4.2);                // RangeError thrown!\nBigInt(NaN);                // RangeError thrown!\nBigInt(Infinity);           // RangeError thrown!\nNumber(2n ** 1024n);        // Infinity\n</code></pre>"},{"location":"types-grammar/ch2/#primitives-are-foundational","title":"Primitives Are Foundational","text":"<p>Over the last two chapters, we've dug deep into how primitive values behave in JS. I bet more than a few readers were, like me, ready to skip over these topics. But now, hopefully, you see the importance of understanding these concepts.</p> <p>The story doesn't end here, though. Far from it! In the next chapter, we'll turn our attention to understanding JS's object types (objects, arrays, etc).</p> <ol> <li> <p>\"New update to the Twitter-Text library: Emoji character count\"; Andy Piper; Oct 2018; https://twittercommunity.com/t/new-update-to-the-twitter-text-library-emoji-character-count/114607 ; Accessed July 2022\u00a0\u21a9</p> </li> <li> <p>ECMAScript 2022 Internationalization API Specification; https://402.ecma-international.org/9.0/ ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"Intl.Collator\", MDN; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"Intl.Segmenter\", MDN; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.2.16 IsStrictlyEqual(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-isstrictlyequal ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.2.15 IsLooselyEqual(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-islooselyequal ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"PLEASE don't follow the code recipe in the accepted answer\", Stack Overflow; Daniel Scott; July 2019; https://stackoverflow.com/a/56967003/228852 ; Accessed August 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"types-grammar/ch3/","title":"Chapter 3: Object Values","text":"NOTE: Work in progress <p>Now that we're comfortable with the built-in primitive types, we turn our attention to the <code>object</code> types in JS.</p> <p>I could write a whole book talking about objects in-depth; in fact, I already did! The \"Objects &amp; Classes\" title of this series covers objects in-depth already, so make sure you've read that before continuing with this chapter.</p> <p>Rather than repeat that book's content, here we'll focus our attention on how the <code>object</code> value-type behaves and interacts with other values in JS.</p>"},{"location":"types-grammar/ch3/#types-of-objects","title":"Types of Objects","text":"<p>The <code>object</code> value-type comprises several sub-types, each with specialized behaviors, including:</p> <ul> <li>plain objects</li> <li>fundamental objects (boxed primitives)</li> <li>built-in objects</li> <li>arrays</li> <li>regular expressions</li> <li>functions (aka, \"callable objects\")</li> </ul> <p>Beyond the specialized behaviors, one shared characteristic is that all objects can act as collections (of properties) holding values (including functions/methods).</p>"},{"location":"types-grammar/ch3/#plain-objects","title":"Plain Objects","text":"<p>The general object value-type is sometimes referred to as plain ol' javascript objects (POJOs).</p> <p>Plain objects have a literal form:</p> <pre><code>address = {\nstreet: \"12345 Market St\",\ncity: \"San Francisco\",\nstate: \"CA\",\nzip: \"94114\"\n};\n</code></pre> <p>This plain object (POJO), as defined with the <code>{ .. }</code> curly braces, is a collection of named properties (<code>street</code>, <code>city</code>, <code>state</code>, and <code>zip</code>). Properties can hold any values, primitives or other objects (including arrays, functions, etc).</p> <p>The same object could also have been defined imperatively using the <code>new Object()</code> constructor:</p> <pre><code>address = new Object();\naddress.street = \"12345 Market St\";\naddress.city = \"San Francisco\";\naddress.state = \"CA\";\naddress.zip = \"94114\";\n</code></pre> <p>Plain objects are by default <code>[[Prototype]]</code> linked to <code>Object.prototype</code>, giving them delegated access to several general object methods, such as:</p> <ul> <li><code>toString()</code> / <code>toLocaleString()</code></li> <li><code>valueOf()</code></li> <li><code>isPrototypeOf(..)</code></li> <li><code>hasOwnProperty(..)</code> (recently deprecated -- alternative: static <code>Object.hasOwn(..)</code> utility)</li> <li><code>propertyIsEnumerable(..)</code></li> <li><code>__proto__</code> (getter function)</li> </ul> <pre><code>address.isPrototypeOf(Object.prototype);    // true\naddress.isPrototypeOf({});                  // false\n</code></pre>"},{"location":"types-grammar/ch3/#fundamental-objects","title":"Fundamental Objects","text":"<p>JS defines several fundamental object types, which are instances of various built-in constructors, including:</p> <ul> <li><code>new String()</code></li> <li><code>new Number()</code></li> <li><code>new Boolean()</code></li> </ul> <p>Note that these constructors must be used with the <code>new</code> keyword to construct instances of the fundamental objects. Otherwise, these functions actually perform type coercion (see Chapter 4).</p> <p>These fundamental object constructors create object value-types instead of a primitives:</p> <pre><code>myName = \"Kyle\";\ntypeof myName;                      // \"string\"\nmyNickname = new String(\"getify\");\ntypeof myNickname;                  // \"object\"\n</code></pre> <p>In other words, an instance of a fundamental object constructor can actually be seen as a wrapper around the corresponding underlying primitive value.</p> WARNING: It's nearly universally regarded as bad practice to ever directly instantiate these fundamental objects. The primitive counterparts are generally more predictable, more performant, and offer auto-boxing (see \"Automatic Objects\" section below) whenever the underlying object-wrapper form is needed for property/method access. <p>The <code>Symbol(..)</code> and <code>BigInt(..)</code> functions are referred to in the specification as \"constructors\", though they're not used with the <code>new</code> keyword, and the values they produce in a JS program are indeed primitives.</p> <p>How, there are internal fundamental objects for these two types, used for prototype delegation and auto-boxing.</p> <p>By contrast, for <code>null</code> and <code>undefined</code> primitive values, there aren't <code>Null()</code> or <code>Undefined()</code> \"constructors\", nor corresponding fundamental objects or prototypes.</p>"},{"location":"types-grammar/ch3/#prototypes","title":"Prototypes","text":"<p>Instances of the fundamental object constructors are <code>[[Prototype]]</code> linked to their constructors' <code>prototype</code> objects:</p> <ul> <li> <p><code>String.prototype</code>: defines <code>length</code> property, as well as string-specific methods, like <code>toUpperCase()</code>, etc.</p> </li> <li> <p><code>Number.prototype</code>: defines number-specific methods, like <code>toPrecision(..)</code>, <code>toFixed(..)</code>, etc.</p> </li> <li> <p><code>Boolean.prototype</code>: defines default <code>toString()</code> and <code>valueOf()</code> methods.</p> </li> <li> <p><code>Symbol.prototype</code>: defines <code>description</code> (getter), as well as default <code>toString()</code> and <code>valueOf()</code> methods.</p> </li> <li> <p><code>BigInt.prototype</code>: defines default <code>toString()</code>, <code>toLocaleString()</code>, and <code>valueOf()</code> methods.</p> </li> </ul> <p>Any direct instance of the built-in constructors have <code>[[Prototype]]</code> delegated access to its respective <code>prototype</code> properties/methods. Moreover, corresponding primitive values also have such delegated access, by way of auto-boxing.</p>"},{"location":"types-grammar/ch3/#automatic-objects","title":"Automatic Objects","text":"<p>I've mentioned auto-boxing several times (including Chapters 1 and 2, and a few times so far in this chapter). It's finally time for us to explain that concept.</p> <p>Accessing a property or method on a value requires that the value be an object. As we've already seen in Chapter 1, primitives are not objects, so JS needs to then temporarily convert/wrap such a primitive to its fundamental object counterpart2 to perform that access.</p> <p>For example:</p> <pre><code>myName = \"Kyle\";\nmyName.length;              // 4\nmyName.toUpperCase();       // \"KYLE\"\n</code></pre> <p>Accessing the <code>length</code> property or the <code>toUpperCase()</code> method, is only allowed on a primitive string value because JS auto-boxes the primitive <code>string</code> into a wrapper fundamental object, an instance of <code>new String(..)</code>. Otherwise, all such accesses would have to fail, since primitives do not have any properties.</p> <p>More importantly, when the primitive value is auto-boxed to its fundamental object counterpart, those internally created objects have access to predefined properties/methods (like <code>length</code> and <code>toUpperCase()</code>) via a <code>[[Prototype]]</code> link to their respective fundamental object's prototype.</p> <p>So an auto-boxed <code>string</code> is an instance of <code>new String()</code>, and is thus linked to <code>String.prototype</code>. Further, the same is true of <code>number</code> (wrapped as an instance of <code>new Number()</code>) and <code>boolean</code> (wrapped as an instance of <code>new Boolean()</code>).</p> <p>Even though the <code>Symbol(..)</code> and <code>BigInt(..)</code> \"constructors\" (used without <code>new</code>produce primitive values, these primitive values can also be auto-boxed to their internal fundamental object wrapper forms, for the purposes of delegated access to properties/methods.</p> NOTE: See the \"Objects &amp; Classes\" book of this series for more on <code>[[Prototype]]</code> linkages and delegated/inherited access to the fundamental object constructors' prototype objects. <p>Since <code>null</code> and <code>undefined</code> have no corresponding fundamental objects, there is no auto-boxing of these values.</p> <p>A subjective question to consider: is auto-boxing a form of coercion? I say it is, though some disagree. Internally, a primitive is converted to an object, meaning a change in value-type has occurred. Yes, it's temporary, but plenty of coercions are temporary. Moreover, the conversion is rather implicit (implied by the property/method access, but only happens internally). We'll revisit the nature of coercion in Chapter 4.</p>"},{"location":"types-grammar/ch3/#other-built-in-objects","title":"Other Built-in Objects","text":"<p>In addition to fundamental object constructors, JS defines a number of other built-in constructors that create further specialized object sub-types:</p> <ul> <li><code>new Date(..)</code></li> <li><code>new Error(..)</code></li> <li><code>new Map(..)</code>, <code>new Set(..)</code>, <code>new WeakMap(..)</code>, <code>new WeakSet(..)</code> -- keyed collections</li> <li><code>new Int8Array(..)</code>, <code>new Uint32Array(..)</code>, etc -- indexed, typed-array collections</li> <li><code>new ArrayBuffer(..)</code>, <code>new SharedArrayBuffer(..)</code>, etc -- structured data collections</li> </ul>"},{"location":"types-grammar/ch3/#arrays","title":"Arrays","text":"<p>Arrays are objects that are specialized to behave as numerically indexed collections of values, as opposed to holding values at named properties like plain objects do.</p> <p>Arrays have a literal form:</p> <pre><code>favoriteNumbers = [ 3, 12, 42 ];\nfavoriteNumbers[2];                 // 42\n</code></pre> <p>The same array could also have been defined imperatively using the <code>new Array()</code> constructor:</p> <pre><code>favoriteNumbers = new Array();\nfavoriteNumbers[0] = 3;\nfavoriteNumbers[1] = 12;\nfavoriteNumbers[2] = 42;\n</code></pre> <p>Arrays are <code>[[Prototype]]</code> linked to <code>Array.prototype</code>, giving them delegated access to a variety of array-oriented methods, such as <code>map(..)</code>, <code>includes(..)</code>, etc:</p> <pre><code>favoriteNumbers.map(v =&gt; v * 2);\n// [ 6, 24, 84 ]\nfavoriteNumbers.includes(42);       // true\n</code></pre> <p>Some of the methods defined on <code>Array.prototype</code> -- for example, <code>push(..)</code>, <code>pop(..)</code>, <code>sort(..)</code>, etc -- behave by modifying the array value in place. Other methods -- for example, <code>concat(..)</code>, <code>map(..)</code>, <code>slice(..)</code> -- behave by creating a new array to return, leaving the original array intact. A third category of array functions -- for example, <code>indexOf(..)</code>, <code>includes(..)</code>, etc -- merely computes and returns a (non-array) result.</p>"},{"location":"types-grammar/ch3/#regular-expressions","title":"Regular Expressions","text":"<p>// TODO</p>"},{"location":"types-grammar/ch3/#functions","title":"Functions","text":"<p>// TODO</p>"},{"location":"types-grammar/ch3/#proposed-recordstuples","title":"Proposed: Records/Tuples","text":"<p>At the time of this writing, a (stage-2) proposal3 exists to add a new set of features to JS, which correspond closely to plain objects and arrays, but with some notable differences.</p> <p>Records are similar to plain objects, but are immutable (sealed, read-only), and (unlike objects) are treated as primitive values, for the purposes of value assignment and equality comparison. The syntax difference is a <code>#</code> before the <code>{ }</code> delimiter. Records can only contain primitive values (including records and tuples).</p> <p>Tuples have exactly the same relationship, but to arrays, including the <code>#</code> before the <code>[ ]</code> delimiters.</p> <p>It's important to note that while these look and seem like objects/arrays, they are indeed primitive (non-object) values.</p> <ol> <li> <p>\"20 Fundamental Objects\", EcamScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-fundamental-objects ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"6.2.4.6 PutValue(V,W)\", Step 5.a, ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-putvalue ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"JavaScript Records &amp; Tuples Proposal\"; Robin Ricard, Rick Button, Nicol\u00f2 Ribaudo; https://github.com/tc39/proposal-record-tuple ; Accessed August 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"types-grammar/ch4/","title":"Chapter 4: Coercing Values","text":"NOTE: Work in progress <p>We've thouroughly covered all of the different types of values in JS. And along the way, more than a few times, we mentioned the notion of converting -- actually, coercing -- from one type of value to another.</p> <p>In this chapter, we'll dive deep into coercion and uncover all its mysteries.</p>"},{"location":"types-grammar/ch4/#coercion-explicit-vs-implicit","title":"Coercion: Explicit vs Implicit","text":"<p>Some developers assert that when you explicitly indicate a type change in an operation, this doesn't qualify as a coercion but just a type-cast or type-conversion. In other words, the claim is that coercion is only implicit.</p> <p>I disagree with this characterization. I use coercion to label any type conversion in a dynamically-typed language, whether it's plainly obvious in the code or not. Here's why: the line between explicit and implicit is not clear and objective, it's fairly subjective. If you think a type conversion is implicit (and thus coercion), but I think it's explicit (and thus not a coercion), the distinction becomes irrelevant.</p> <p>Keep that subjectivity in mind as we explore various explicit and implicit forms of coercion. In fact, here's a spoiler: most of the coercions could be argued as either, so we'll be looking at them with such balanced perspective.</p>"},{"location":"types-grammar/ch4/#implicit-bad-or","title":"Implicit: Bad or ...?","text":"<p>An extremely common opinion among JS developers is that coercion is bad, specifically, that implicit coercion is bad; the rise in popularity of type-aware tooling like TypeScript speaks loudly to this sentiment.</p> <p>But that feeling is not new. 14+ years ago, Douglas Crockford's book \"The Good Parts\" also famously decried implicit coercion as one of the bad parts. Even Brendan Eich, creator of JS, regularly claims that implicit coercion was a mistake1 in the early design of the language that he now regrets.</p> <p>If you've been around JS for more than a few months, you've almost certainly heard these opinions voiced strongly and predominantly. And if you've been around JS for years or more, you probably have your mind already made up.</p> <p>In fact, I think you'd be hard pressed to name hardly any other well-known source of JS teaching that strongly endorses coercion (in virtually all its forms); I do -- and this book definitely does! -- but I feel mostly like a lone voice shouting futilely in the wilderness.</p> <p>However, here's an observation I've made over the years: most of the folks who publicly condemn implicit coercion, actually use implicit coercion in their own code. Hmmmm...</p> <p>Douglas Crockford says to avoid the mistake of implicit coercion2, but his code uses <code>if (..)</code> statements with non-boolean values evaluated. 3 Many have dismissed my pointing that out in the past, with the claim that conversion-to-booelan isn't really coercion. Ummm... ok?</p> <p>Brendan Eich says he regrets implicit coercion, but yet he openly endorses4 idioms like <code>x + \"\"</code> (and others!) to coerce the value in <code>x</code> to a string (we'll cover this later); and that's most definitely an implicit coercion.</p> <p>So what do we make of this dissonance? Is it merely a, \"do as I say, not as I do\" minor self-contradiction? Or is there more to it?</p> <p>I am not going to pass a final judgement here yet, but I want you the reader to deeply ponder that question, as you continue throughout this chapter and book.</p>"},{"location":"types-grammar/ch4/#abstracts","title":"Abstracts","text":"<p>Now that I've challenged you to examine coercion in more depth than you may have ever previously indulged, let's first look at the foundations of how coercion occurs, according to the JS specification.</p> <p>The specification details a number of abstract operations5 that dictate internal conversion from one value-type to another. It's important to be aware of these operations, as coercive mechanics in the language mix and match them in various ways.</p> <p>These operations look as if they're real functions that could be called, such as <code>ToString(..)</code> or <code>ToNumber(..)</code>. But by abstract, we mean they only exist conceptually by these names; they aren't functions we can directly invoke in our programs. Instead, we activate them implicitly/indirectly depending on the statements/expressions in our programs.</p>"},{"location":"types-grammar/ch4/#toboolean","title":"ToBoolean","text":"<p>Decision making (conditional branching) always requires a boolean <code>true</code> or <code>false</code> value. But it's extremely common to want to make these decisions based on non-boolean value conditions, such as whether a string is empty or has anything in it.</p> <p>When non-boolean values are encountered in a context that requires a boolean -- such as the condition clause of an <code>if</code> statement or <code>for</code> loop -- the <code>ToBoolean(..)</code>6 abstract operation is activated to facilitate the coercion.</p> <p>All values in JS are in one of two buckets: truthy or falsy. Truthy values coerce via the <code>ToBoolean()</code> operation to <code>true</code>, whereas falsy values coerce to <code>false</code>:</p> <pre><code>// ToBoolean() is abstract\n\nToBoolean(undefined);               // false\nToBoolean(null);                    // false\nToBoolean(\"\");                      // false\nToBoolean(0);                       // false\nToBoolean(-0);                      // false\nToBoolean(0n);                      // false\nToBoolean(NaN);                     // false\n</code></pre> <p>Simple rule: any other value that's not in the above list is truthy and coerces via <code>ToBoolean()</code> to <code>true</code>:</p> <pre><code>ToBoolean(\"hello\");                 // true\nToBoolean(42);                      // true\nToBoolean([ 1, 2, 3 ]);             // true\nToBoolean({ a: 1 });                // true\n</code></pre> <p>Even values like <code>\"   \"</code> (string with only whitespace), <code>[]</code> (empty array), and <code>{}</code> (empty object), which may seem intuitively like they're more \"false\" than \"true\", nevertheless coerce to <code>true</code>.</p> WARNING: There are narrow, tricky exceptions to this truthy rule. For example, the web platform has deprecated the long-standing <code>document.all</code> collection/array feature, though it cannot be removed entirely -- that would break too many sites. Even where <code>document.all</code> is still defined, it behaves as a \"falsy object\"7 -- <code>undefined</code> which then coerces to <code>false</code>; this means legacy conditional checks like <code>if (document.all) { .. }</code> no longer pass. <p>The <code>ToBoolean()</code> coercion operation is basically a lookup table rather than an algorithm of steps to use in coercions a non-boolean to a boolean. Thus, some developers assert that this isn't really coercion the way other abstract coercion operations are. I think that's bogus. <code>ToBoolean()</code> converts from non-boolean value-types to a boolean, and that's clear cut type coercion (even if it's a very simple lookup instead of an algorithm).</p> <p>Keep in mind: these rules of boolean coercion only apply when <code>ToBoolean()</code> is actually activated. There are constructs/idioms in the JS language that may appear to involve boolean coercion but which don't actually do so. More on these later.</p>"},{"location":"types-grammar/ch4/#toprimitive","title":"ToPrimitive","text":"<p>Any value that's not already a primitive can be reduced to a primitive using the <code>ToPrimitive()</code> (specifically, <code>OrdinaryToPrimitive()</code>8) abstract operation.  Generally, the <code>ToPrimitive()</code> is given a hint to tell it whether a <code>number</code> or <code>string</code> is preferred.</p> <pre><code>// ToPrimitive() is abstract\n\nToPrimitive({ a: 1 },\"string\");          // \"[object Object]\"\n\nToPrimitive({ a: 1 },\"number\");          // NaN\n</code></pre> <p>The <code>ToPrimitive()</code> operation will look on the object provided, for either a <code>toString()</code> method or a <code>valueOf()</code> method; the order it looks for those is controlled by the hint. <code>\"string\"</code> means check in <code>toString()</code> / <code>valueOf()</code> order, whereas <code>\"number\"</code> (or no hint) means check in <code>valueOf()</code> / <code>toString()</code> order.</p> <p>If the method returns a value matching the hinted type, the operation is finished. But if the method doesn't return a value of the hinted type, <code>ToPrimitive()</code> will then look for and invoke the other method (if found).</p> <p>If the attempts at method invocation fail to produce a value of the hinted type, the final return value is forcibly coerced via the corresponding abstract operation: <code>ToString()</code> or <code>ToNumber()</code>.</p>"},{"location":"types-grammar/ch4/#tostring","title":"ToString","text":"<p>Pretty much any value that's not already a string can be coerced to a string representation, via <code>ToString()</code>. 9 This is usually quite intuitive, especially with primitive values:</p> <pre><code>// ToString() is abstract\n\nToString(42.0);                 // \"42\"\nToString(-3);                   // \"-3\"\nToString(Infinity);             // \"Infinity\"\nToString(NaN);                  // \"NaN\"\nToString(42n);                  // \"42\"\n\nToString(true);                 // \"true\"\nToString(false);                // \"false\"\n\nToString(null);                 // \"null\"\nToString(undefined);            // \"undefined\"\n</code></pre> <p>There are some results that may vary from common intuition. As mentioned in Chapter 2, very large or very small numbers will be represented using scientific notation:</p> <pre><code>ToString(Number.MAX_VALUE);     // \"1.7976931348623157e+308\"\nToString(Math.EPSILON);         // \"2.220446049250313e-16\"\n</code></pre> <p>Another counter-intuitive result comes from <code>-0</code>:</p> <pre><code>ToString(-0);                   // \"0\" -- wtf?\n</code></pre> <p>This isn't a bug, it's just an intentional behavior from the earliest days of JS, based on the assumption that developers generally wouldn't want to ever see a negative-zero output.</p> <p>One primitive value-type that is not allowed to be coerced (implicitly, at least) to string is <code>symbol</code>:</p> <pre><code>ToString(Symbol(\"ok\"));         // TypeError exception thrown\n</code></pre> WARNING: Calling the <code>String()</code>11 concrete function (without <code>new</code> operator) is generally thought of as merely invoking the <code>ToString()</code> abstract operation. While that's mostly true, it's not entirely so. <code>String(Symbol(\"ok\"))</code> works, whereas the abstract <code>ToString(Symbol(..))</code> itself throws an exception. More on <code>String(..)</code> later in this chapter."},{"location":"types-grammar/ch4/#default-tostring","title":"Default <code>toString()</code>","text":"<p>When <code>ToString()</code> is activated with an object value-type, it delegates to the <code>ToPrimitive()</code> operation (as explained earlier), with <code>\"string\"</code> as its hinted type:</p> <pre><code>ToString(new String(\"abc\"));        // \"abc\"\nToString(new Number(42));           // \"42\"\n\nToString({ a: 1 });                 // \"[object Object]\"\nToString([ 1, 2, 3 ]);              // \"1,2,3\"\n</code></pre> <p>By virtue of <code>ToPrimitive(..,\"string\")</code> delegation, these objects all have their default <code>toString()</code> method (inherited via <code>[[Prototype]]</code>) invoked.</p>"},{"location":"types-grammar/ch4/#tonumber","title":"ToNumber","text":"<p>Non-number values that resemble numbers, such as numeric strings, can generally be coerced to a numeric representation, using <code>ToNumber()</code>: 12</p> <pre><code>// ToNumber() is abstract\n\nToNumber(\"42\");                     // 42\nToNumber(\"-3\");                     // -3\nToNumber(\"1.2300\");                 // 1.23\nToNumber(\"   8.0    \");             // 8\n</code></pre> <p>If the full value doesn't completely (other than whitespace) resemble a valid number, the result will be <code>NaN</code>:</p> <pre><code>ToNumber(\"123px\");                  // NaN\nToNumber(\"hello\");                  // NaN\n</code></pre> <p>Other primitive values have certain designated numeric equivalents:</p> <pre><code>ToNumber(true);                     // 1\nToNumber(false);                    // 0\n\nToNumber(null);                     // 0\nToNumber(undefined);                // NaN\n</code></pre> <p>There are some rather surprising designations for <code>ToNumber()</code>:</p> <pre><code>ToNumber(\"\");                       // 0\nToNumber(\"       \");                // 0\n</code></pre> NOTE: I call these \"surprising\" because I think it would have made much more sense for them to coerce to <code>NaN</code>, the way <code>undefined</code> does. <p>Some primitive values are not allowed to be coerced to numbers, and result in exceptions rather than <code>NaN</code>:</p> <pre><code>ToNumber(42n);                      // TypeError exception thrown\nToNumber(Symbol(\"42\"));             // TypeError exception thrown\n</code></pre> WARNING: Calling the <code>Number()</code>15 concrete function (without <code>new</code> operator) is generally thought of as merely invoking the <code>ToNumber()</code> abstract operation to coerce a value to a number. While that's mostly true, it's not entirely so. <code>Number(42n)</code> works, whereas the abstract <code>ToNumber(42n)</code> itself throws an exception."},{"location":"types-grammar/ch4/#other-abstract-numeric-conversions","title":"Other Abstract Numeric Conversions","text":"<p>In addition to <code>ToNumber()</code>, the specification defines <code>ToNumeric()</code>, which activates <code>ToPrimitive()</code> on a value, then conditionally delegates to <code>ToNumber()</code> if the value is not already a <code>bigint</code> value-type.</p> <p>There are also a wide variety of abstract operations related to converting values to very specific subsets of the general <code>number</code> type:</p> <ul> <li><code>ToIntegerOrInfinity()</code></li> <li><code>ToInt32()</code></li> <li><code>ToUint32()</code></li> <li><code>ToInt16()</code></li> <li><code>ToUint16()</code></li> <li><code>ToInt8()</code></li> <li><code>ToUint8()</code></li> <li><code>ToUint8Clamp()</code></li> </ul> <p>Other operations related to <code>bigint</code>:</p> <ul> <li><code>ToBigInt()</code></li> <li><code>StringToBigInt()</code></li> <li><code>ToBigInt64()</code></li> <li><code>ToBigUint64()</code></li> </ul> <p>You can probably infer the purpose of these operations from their names, and/or from consulting their algorithms in the specification. For most JS operations, it's more likely that a higher-level operation like <code>ToNumber()</code> is activated, rather than these specific ones.</p>"},{"location":"types-grammar/ch4/#default-valueof","title":"Default <code>valueOf()</code>","text":"<p>When <code>ToNumber()</code> is activated on an object value-type, it instead delegates to the <code>ToPrimitive()</code> operation (as explained earlier), with <code>\"number\"</code> as its hinted type:</p> <pre><code>ToNumber(new String(\"abc\"));        // NaN\nToNumber(new Number(42));           // 42\n\nToNumber({ a: 1 });                 // NaN\nToNumber([ 1, 2, 3 ]);              // NaN\nToNumber([]);                       // 0\n</code></pre> <p>By virtue of <code>ToPrimitive(..,\"number\")</code> delegation, these objects all have their default <code>valueOf()</code> method (inherited via <code>[[Prototype]]</code>) invoked.</p>"},{"location":"types-grammar/ch4/#equality-comparison","title":"Equality Comparison","text":"<p>When JS needs to determine if two values are the same value, it activates the <code>SameValue()</code>16 operation, which delegates to a variety of related sub-operations.</p> <p>This operation is very narrow and strict, and performs no coercion or any other special case exceptions. If two values are exactly the same, the result is <code>true</code>, otherwise it's <code>false</code>:</p> <pre><code>// SameValue() is abstract\n\nSameValue(\"hello\",\"\\x68ello\");          // true\nSameValue(\"\\u{1F4F1}\",\"\\uD83D\\uDCF1\");  // true\nSameValue(42,42);                       // true\nSameValue(NaN,NaN);                     // true\n\nSameValue(\"\\u00e9\",\"\\u0065\\u0301\");     // false\nSameValue(0,-0);                        // false\nSameValue([1,2,3],[1,2,3]);             // false\n</code></pre> <p>A variation of these operations is <code>SameValueZero()</code> and its associated sub-operations. The main difference is that these operations treat <code>0</code> and <code>-0</code> as indistinguishable.</p> <pre><code>// SameValueZero() is abstract\n\nSameValueZero(0,-0);                    // true\n</code></pre> <p>If the values are numeric (<code>number</code> or <code>bigint</code>), <code>SameValue()</code> and <code>SameValueZero()</code> both delegate to sub-operations of the same names, specialized for each <code>number</code> and <code>bigint</code> type, respectively.</p> <p>Otherwise, <code>SameValueNonNumeric()</code> is the sub-operation delegated to if the values being compared are both non-numeric:</p> <pre><code>// SameValueNonNumeric() is abstract\n\nSameValueNonNumeric(\"hello\",\"hello\");   // true\n\nSameValueNonNumeric([1,2,3],[1,2,3]);   // false\n</code></pre>"},{"location":"types-grammar/ch4/#higher-abstracted-equality","title":"Higher-Abstracted Equality","text":"<p>Different from <code>SameValue()</code> and its variations, the specification also defines two important higher-abstraction abstract equality comparison operations:</p> <ul> <li><code>IsStrictlyEqual()</code>17</li> <li><code>IsLooselyEqual()</code>18</li> </ul> <p>The <code>IsStrictlyEqual()</code> operation immediately returns <code>false</code> if the value-types being compared are different.</p> <p>If the value-types are the same, <code>IsStrictlyEqual()</code> delegates to sub-operations for comparing <code>number</code> or <code>bigint</code> values. 19 You might logically expect these delegated sub-operations to be the aforementioned numeric-specialized <code>SameValue()</code> / <code>SameValueZero()</code> operations. However, <code>IsStrictlyEqual()</code> instead delegates to <code>Number:equal()</code>20 or <code>BigInt:equal()</code>21.</p> <p>The difference between <code>Number:SameValue()</code> and <code>Number:equal()</code> is that the latter defines corner cases for <code>0</code> vs <code>-0</code> comparison:</p> <pre><code>// all of these are abstract operations\n\nNumber:SameValue(0,-0);             // false\nNumber:SameValueZero(0,-0);         // true\nNumber:equal(0,-0);                 // true\n</code></pre> <p>These operations also differ in <code>NaN</code> vs <code>NaN</code> comparison:</p> <pre><code>Number:SameValue(NaN,NaN);          // true\nNumber:equal(NaN,NaN);              // false\n</code></pre> WARNING: So in other words, despite its name, <code>IsStrictlyEqual()</code> is not quite as \"strict\" as <code>SameValue()</code>, in that it lies when comparisons of <code>-0</code> or <code>NaN</code> are involved. <p>The <code>IsLooselyEqual()</code> operation also inspects the value-types being compared; if they're the same, it immediately delegates to <code>IsStrictlyEqual()</code>.</p> <p>But if the value-types being compared are different, <code>IsLooselyEqual()</code> performs a variety of coercive equality steps. It's important to note that this algorithm is always trying to reduce the comparison down to where both value-types are the same (and it tends to prefer <code>number</code> / <code>bigint</code>).</p> <p>The steps of the coercive equality portion of the algorithm can roughly be summarized as follows:</p> <ol> <li> <p>If either value is <code>null</code> and the other is <code>undefined</code>, <code>IsLooselyEqual()</code> returns <code>true</code>. In other words, this algorithm applies nullish equality, in that <code>null</code> and <code>undefined</code> are coercively equal to each other (and to no other values).</p> </li> <li> <p>If either value is a <code>number</code> and the other is a <code>string</code>, the <code>string</code> value is coerced to a <code>number</code> via <code>ToNumber()</code>.</p> </li> <li> <p>If either value is a <code>bigint</code> and the other is a <code>string</code>, the <code>string</code> value is coerced to a <code>bigint</code> via <code>StringToBigInt()</code>.</p> </li> <li> <p>If either value is a <code>boolean</code>, it's coerced to a <code>number</code>.</p> </li> <li> <p>If either value is a non-primitive (object, etc), it's coerced to a primitive with <code>ToPrimitive()</code>; though a hint is not explicitly provided, the default behavior will be as if <code>\"number\"</code> was the hint.</p> </li> </ol> <p>Each time a coercion is performed in the above steps, the algorithm is recursively reactivated with the new value(s). That process continues until the types are the same, and then the comparison is delegated to the <code>IsStrictlyEqual()</code> operation.</p> <p>What can we take from this algorithm? First, we see there is a bias toward <code>number</code> (or <code>bigint</code>) comparison; it nevers coerce values to <code>string</code> or <code>boolean</code> value-types.</p> <p>Importantly, we see that both <code>IsLooselyEqual()</code> and <code>IsStrictlyEqual()</code> are type-sensitive. <code>IsStrictlyEqual()</code> immediately bails if the types mismatch, whereas <code>IsLooselyEqual()</code> performs the extra work to coerce mismatching value-types to be the same value-types (again, ideally, <code>number</code> or <code>bigint</code>).</p> <p>Moreover, if/once the types are the same, both operations are identical -- <code>IsLooselyEqual()</code> delegates to <code>IsStrictlyEqual()</code>.</p>"},{"location":"types-grammar/ch4/#relational-comparison","title":"Relational Comparison","text":"<p>When values are compared relationally -- that is, is one value \"less than\" another? -- there's one specific abstract operation that is activated: <code>IsLessThan()</code>. 22</p> <pre><code>// IsLessThan() is abstract\n\nIsLessThan(1,2, /*LeftFirst=*/ true );            // true\n</code></pre> <p>There is no <code>IsGreaterThan()</code> operation; instead, the first two arguments to <code>IsLessThan()</code> can be reversed to accomplish a \"greater than\" comparison. To preserve left-to-right evaluation semantics (in the case of nuanced side-effects), <code>isLessThan()</code> also takes a third argument (<code>LeftFirst</code>); if <code>false</code>, this indicates a comparison was reversed and the second parameter should be evaluated before the first.</p> <pre><code>IsLessThan(1,2, /*LeftFirst=*/ true );            // true\n\n// equivalent of a fictional \"IsGreaterThan()\"\nIsLessThan(2,1, /*LeftFirst=*/ false );          // false\n</code></pre> <p>Similar to <code>IsLooselyEqual()</code>, the <code>IsLessThan()</code> operation is coercive, meaning that it first ensures that the value-types of its two values match, and prefers numeric comparisons. There is no <code>IsStrictLessThan()</code> for non-coercive relational comparison.</p> <p>As an example of coercive relational comparison, if the type of one value is <code>string</code> and the type of the other is <code>bigint</code>, the <code>string</code> is coerced to a <code>bigint</code> with the aforementioned <code>StringToBigInt()</code> operation. Once the types are the same, <code>IsLessThan()</code> proceeds as described in the following sections.</p>"},{"location":"types-grammar/ch4/#string-comparison","title":"String Comparison","text":"<p>When both value are type <code>string</code>, <code>IsLessThan()</code> checks to see if the lefthand value is a prefix (the first n characters23) of the righthand; if so, <code>true</code> is returned.</p> <p>If neither string is a prefix of the other, the first character position (start-to-end direction, not left-to-right) that's different between the two strings, is compared for their respective code-unit (numeric) values; the result is then returned.</p> <p>Generally, code-units follow intuitive lexicographic (aka, dictionary) order:</p> <pre><code>IsLessThan(\"a\",\"b\", /*LeftFirst=*/ true );        // true\n</code></pre> <p>Even digits are treated as characters (not numbers):</p> <pre><code>IsLessThan(\"101\",\"12\", /*LeftFirst=*/ true );     // true\n</code></pre> <p>There's even a bit of embedded humor in the unicode code-unit ordering:</p> <pre><code>IsLessThan(\"\ud83d\udc14\",\"\ud83e\udd5a\", /*LeftFirst=*/ true );      // true\n</code></pre> <p>At least now we've answered the age old question of which comes first?!</p>"},{"location":"types-grammar/ch4/#numeric-comparison","title":"Numeric Comparison","text":"<p>For numeric comparisons, <code>IsLessThan()</code> defers to either the <code>Number:lessThan()</code> or <code>BigInt.lessThan()</code> operation19, respectively:</p> <pre><code>IsLessThan(41,42, /*LeftFirst=*/ true );         // true\n\nIsLessThan(-0,0, /*LeftFirst=*/ true );          // false\n\nIsLessThan(NaN,1 /*LeftFirst=*/ true );          // false\n\nIsLessThan(41n,42n, /*LeftFirst=*/ true );       // true\n</code></pre>"},{"location":"types-grammar/ch4/#concrete-coercions","title":"Concrete Coercions","text":"<p>Now that we've covered all the abstract operations JS defines for handling various coercions, it's time to turn our attention to the concrete statements/expressions we can use in our programs that activate these operations.</p>"},{"location":"types-grammar/ch4/#to-boolean","title":"To Boolean","text":"<p>To coerce a value that's not of type <code>boolean</code> into that type, we need the abstract <code>ToBoolean()</code> operation, as described earlier in this chapter.</p> <p>Before we explore how to activate it, let's discuss why you would want to force a <code>ToBoolean()</code> coercion.</p> <p>From a code readability perspective, being explicit about type coercions can be preferable (though not universally). But functionally, the most common reason to force a <code>boolean</code> is when you're passing data to an external source -- for example, submitting data as JSON to an API endpoint -- and that location expects <code>true</code> / <code>false</code> without needing to do coercions.</p> <p>There's several ways that <code>ToBoolean()</code> can be activated. Perhaps the most explicit (obvious) is the <code>Boolean(..)</code> function:</p> <pre><code>Boolean(\"hello\");               // true\nBoolean(42);                    // true\nBoolean(\"\");                    // false\nBoolean(0);                     // false\n</code></pre> <p>As mentioned in Chapter 3, keep in mind that <code>Boolean(..)</code> is being called without the <code>new</code> keyword, to activate the <code>ToBoolean()</code> abstract operation.</p> <p>It's not terribly common to see JS developers use the <code>Boolean(..)</code> function for such explicit coercions. More often, developers will use the double-<code>!</code> idiom:</p> <pre><code>!!\"hello\";                      // true\n!!42;                           // true\n!!\"\";                           // false\n!!0;                            // false\n</code></pre> <p>The <code>!!</code> is not its own operator, even though it seems that way. It's actually two usages of the unary <code>!</code> operator. This operator first coerces any non-<code>boolean</code>, then negates it. To undo the negation, the second <code>!</code> flips it back.</p> <p>So... which of the two, <code>Boolean(..)</code> or <code>!!</code>, do you consider to be more of an explicit coercion?</p> <p>Given the flipping that <code>!</code> does, which must then be undone with another <code>!</code>, I'd say <code>Boolean(..)</code> is more explicit -- at the job of coercing a non-<code>boolean</code> to a <code>boolean</code> -- than <code>!!</code> is. But surveying open-source JS code, the <code>!!</code> is used far more often.</p> <p>If we're defining explicit as, \"most directly and obviously perfoming an action\", <code>Boolean(..)</code> edges out <code>!!</code>. But if we're defining explicit as, \"most recognizably performing an action\", <code>!!</code> might have the edge. Is there a definitive answer here?</p> <p>While you're pondering that question, let's look at another JS mechanism that activates <code>ToBoolean()</code> under the covers:</p> <pre><code>specialNumber = 42;\nif (specialNumber) {\n// ..\n}\n</code></pre> <p>The <code>if</code> statement requires a <code>boolean</code> for the conditional to make its control-flow decision. If you pass it a non-<code>boolean</code>, a <code>ToBoolean()</code> coercion is performed.</p> <p>Unlike previous <code>ToBoolean()</code> coercion expressions, like <code>Boolean(..)</code> or <code>!!</code>, this <code>if</code> coercion is ephemeral, in that our JS program never sees the result of the coercion; it's just used internally by the <code>if</code>. Some may feel it's not really coercion if the program doesn't preserve/use the value. But I strongly disagree, because the coercion most definitely affects the program's behavior.</p> <p>Many other statement types also activate the <code>ToBoolean()</code> coercion, including the <code>? :</code> ternary conditional, and <code>for</code> / <code>while</code> loops. We also have <code>&amp;&amp;</code> (logical-AND) and <code>||</code> (logical-OR) operators. For example:</p> <pre><code>isLoggedIn = user.sessionID || req.cookie[\"Session-ID\"];\nisAdmin = isLoggedIn &amp;&amp; (\"admin\" in user.permissions);\n</code></pre> <p>For both operators, the lefthand expression is first evaluated; if it's not already a <code>boolean</code>, a <code>ToBoolean()</code> coercion is activated to produce a value for the conditional decision.</p> NOTE: To briefly explain these operators: for <code>||</code>, if the lefthand expression value (post-coercion, if necessary) is <code>true</code>, the pre-coercion value is returned; otherwise the righthand expression is evaluated and returned (no coercion). For <code>&amp;&amp;</code>, if the lefthand expression value (post-coercion, if necessary) is <code>false</code>, the pre-coercion value is returned; otherwise, the righthand expression is evaluated and returned (no coercion). In other words, both <code>&amp;&amp;</code> and <code>||</code> force a <code>ToBoolean()</code> coercion of the lefthand operand for making the decision, but neither operator's final result is actually coerced to a <code>boolean</code>. <p>In the previous snippet, despite the naming implications, it's unlikely that <code>isLoggedIn</code> will actually be a <code>boolean</code>; and if it's truthy, <code>isAdmin</code> also won't be a <code>boolean</code>. That kind of code is quite common, but it's definitely dangerous that the assumed resultant <code>boolean</code> types aren't actually there. We'll revisit this example, and these operators, in the next chapter.</p> <p>Are these kinds of statements/expressions (e.g., <code>if (..)</code>, <code>||</code>, <code>&amp;&amp;</code>, etc) illustrating explicit coercion or implicit coercion in their conditional decision making?</p> <p>Again, I think it depends on your perspective. The specification dictates pretty explicitly that they only make their decisions with <code>boolean</code> conditional values, requiring coercion if a non-<code>boolean</code> is received. On the other hand, a strong argument can also be made that any internal coercion is a secondary (implicit) effect to the main job of <code>if</code> / <code>&amp;&amp;</code> / etc.</p> <p>Further, as mentioned earlier in the <code>ToBoolean()</code> discussion, some folks don't consider any activation of <code>ToBoolean()</code> to be a coercion.</p> <p>I think that's too much of a stretch, though. My take: <code>Boolean(..)</code> is the most preferable explicit coercion form. I think <code>!!</code>, <code>if</code>, <code>for</code>, <code>while</code>, <code>&amp;&amp;</code>, and <code>||</code> are all implicitly coercing non-<code>boolean</code>s, but I'm OK with that.</p> <p>Since most developers, including famous names like Doug Crockford, also in practice use implicit (<code>boolean</code>) coercions in their code3, I think we can say that at least some forms of implicit coercion are widely acceptable, regardless of the ubiquitous rhetoric to the contrary.</p>"},{"location":"types-grammar/ch4/#to-string","title":"To String","text":"<p>As with <code>ToBoolean()</code>, there are a number of ways to activate the <code>ToString()</code> coercion (as discussed earlier in the chapter). The decision of which approach is similarly subjective.</p> <p>Like the <code>Boolean(..)</code> function, the <code>String(..)</code> function (no <code>new</code> keyword) is a primary way of activating explicit <code>ToString()</code> coercion:</p> <pre><code>String(true);                   // \"true\"\nString(42);                     // \"42\"\nString(-0);                     // \"0\"\nString(Infinity);               // \"Infinity\"\nString(null);                   // \"null\"\nString(undefined);              // \"undefined\"\n</code></pre> <p>However, <code>String(..)</code> is more than just an activation of <code>ToString()</code>. For example:</p> <pre><code>String(Symbol(\"ok\"));           // \"Symbol(ok)\"\n</code></pre> <p>This works, because explicit coercion of <code>symbol</code> values is allowed. But in cases where a symbol is implicitly coerced to a string (e.g., <code>Symbol(\"ok\") + \"\"</code>), the underlying <code>ToString()</code> operation throws an exception. That proves that <code>String(..)</code> is more than just an activation of <code>ToString()</code>. More on implicit string coercion of symbols in a bit.</p> <p>If you call <code>String(..)</code> with an object value (e.g., array, etc), it activates the <code>ToPrimitive()</code> operation (via the <code>ToString()</code> operation), which then looks for an invokes that value's <code>toString()</code> method:</p> <pre><code>String([1,2,3]);                // \"1,2,3\"\nString(x =&gt; x + 1);             // \"x =&gt; x + 1\"\n</code></pre> <p>Aside from <code>String(..)</code>, any primitive, non-nullish value (neither <code>null</code> nor <code>undefined</code>) can be auto-boxed (see Chapter 3) in its respective object wrapper, providing a callable <code>toString()</code> method.</p> <pre><code>true.toString();                // \"true\"\n42..toString();                 // \"42\"\n-0..toString();                 // \"0\"\nInfinity.toString();            // \"Infinity\"\nSymbol(\"ok\").toString();        // \"Symbol(ok)\"\n</code></pre> NOTE: Do keep in mind, these <code>toString()</code> methods do not necessarily activate the <code>ToString()</code> operation, they just define their own rules for how to represent the value as a string. <p>As shown with <code>String(..)</code> just a moment ago, the various object sub-types -- such as arrays, functions, regular expressions, <code>Date</code> and <code>Error</code> instances, etc -- all define their own specific <code>toString()</code> methods, which can be invoked directly:</p> <pre><code>[1,2,3].toString();             // \"1,2,3\"\n(x =&gt; x + 1).toString();        // \"x =&gt; x + 1\"\n</code></pre> <p>Moreover, any plain object that's (by default) <code>[[Prototype]]</code> linked to <code>Object.prototype</code> has a default <code>toString()</code> method available:</p> <pre><code>({ a : 1 }).toString();         // \"[object Object]\"\n</code></pre> <p>Is the <code>toString()</code> approach to coercion explicit or implicit? Again, it depends. It's certainly a self-descriptive mechanism, which leans explicit. But it often relies on auto-boxing, which is itself a fairly implicit coercion.</p> <p>Let's take a look at another common -- and famously endorsed! -- idiom for coercing a value to a string. Recall from \"String Concatenation\" in Chapter 2, the <code>+</code> operator is overloaded to prefer string concatenation if either operand is already a string, and thus coerces non-string operand to a string if necessary.</p> <p>Consider:</p> <pre><code>true + \"\";                      // \"true\"\n42 + \"\";                        // \"42\"\nnull + \"\";                      // \"null\"\nundefined + \"\";                 // \"undefined\"\n</code></pre> <p>The <code>+ \"\"</code> idiom for string coercion takes advantage of the <code>+</code> overloading, without altering the final coerced string value. By the way, all of these work the same with the operands reversed (i.e., <code>\"\" + ..</code>).</p> WARNING: An extremely common misconception is that <code>String(x)</code> and <code>x + \"\"</code> are basically equivalent coercions, respectively just explicit vs implicit in form. But, that's not quite true! We'll revisit this in the \"To Primitive\" section later in this chapter. <p>Some feel this is an explicit coercion, but I think it's clearly more implicit, in that it's taking advantage of the <code>+</code> overloading; further, the <code>\"\"</code> is indirectly used to activate the coercion without modifying it. Moreover, consider what happens when this idiom is applied with a symbol value:</p> <pre><code>Symbol(\"ok\") + \"\";              // TypeError exception thrown\n</code></pre> WARNING: Allowing explicit coercion of symbols (<code>String(Symbol(\"ok\"))</code>, but disallowing implicit coercion (<code>Symbol(\"ok\") + \"\"</code>), is quite intentional by TC39. 24 It was felt that symbols, as primitives often used in places where strings are otherwise used, could too easily be mistaken as strings. As such, they wanted to make sure developers expressed intent to coerce a symbol to a string, hopefully avoiding many of those anticipated confusions. This is one of the extremely rare cases where the language design asserts an opinion on, and actually discriminates between, explicit vs. implicit coercions. <p>Why the exception? JS treats <code>+ \"\"</code> as an implicit coercion, which is why when activated with a symbol, an exception is thrown. I think that's a pretty ironclad proof.</p> <p>Nevertheless, as I mentioned at the start of this chapter, Brendan Eich endorses <code>+ \"\"</code>4 as the best way to coerce values to strings. I think that carries a lot of weight, in terms of him supporting at least a subset of implicit coercion practices. His views on implicit coercion must be a bit more nuanced than, \"it's all bad.\"</p>"},{"location":"types-grammar/ch4/#to-number","title":"To Number","text":"<p>Numeric coercions are a bit more complicated than string coercions, since we can be talking about either <code>number</code> or <code>bigint</code> as the target type. There's also a much smaller set of values that can be validly represented numerically (everything else becomes <code>NaN</code>).</p> <p>Let's start with the <code>Number(..)</code> and <code>BigInt(..)</code> functions (no <code>new</code> keywords):</p> <pre><code>Number(\"42\");                   // 42\nNumber(\"-3.141596\");            // -3.141596\nNumber(\"-0\");                   // -0\nBigInt(\"42\");                   // 42n\nBigInt(\"-0\");                   // 0n\n</code></pre> <p><code>Number</code> coercion which fails (not recognized) results in <code>NaN</code> (see \"Invalid Number\" in Chapter 1), whereas <code>BigInt</code> throws an exception:</p> <pre><code>Number(\"123px\");                // NaN\nBigInt(\"123px\");\n// SyntaxError: Cannot convert 123px to a BigInt\n</code></pre> <p>Moreover, even though <code>42n</code> is valid syntax as a literal <code>bigint</code>, the string <code>\"42n\"</code> is never a recognized string representation of a <code>bigint</code>, by either of the coercive function forms:</p> <pre><code>Number(\"42n\");                  // NaN\nBigInt(\"42n\");\n// SyntaxError: Cannot convert 42n to a BigInt\n</code></pre> <p>However, we can coerce numeric strings with other representations of the numbers than typical base-10 decimals (see Chapter 1 for more information):</p> <pre><code>Number(\"0b101010\");             // 42\nBigInt(\"0b101010\");             // 42n\n</code></pre> <p>Typically, <code>Number(..)</code> and <code>BigInt(..)</code> receive string values, but that's not actually required. For example, <code>true</code> and <code>false</code> coerce to their typical numeric equivalents:</p> <pre><code>Number(true);                   // 1\nNumber(false);                  // 0\nBigInt(true);                   // 1n\nBigInt(false);                  // 0n\n</code></pre> <p>You can also generally coerce between <code>number</code> and <code>bigint</code> types:</p> <pre><code>Number(42n);                    // 42\nNumber(42n ** 1000n);           // Infinity\nBigInt(42);                     // 42n\n</code></pre> <p>We can also use the <code>+</code> unary operator, which is commonly assumed to coerce the same as the <code>Number(..)</code> function:</p> <pre><code>+\"42\";                          // 42\n+\"0b101010\";                    // 42\n</code></pre> <p>Be careful though. If the coercions are unsafe/invalid in certain ways, exceptions are thrown:</p> <pre><code>BigInt(3.141596);\n// RangeError: The number 3.141596 cannot be converted to a BigInt\n+42n;\n// TypeError: Cannot convert a BigInt value to a number\n</code></pre> <p>Clearly, <code>3.141596</code> does not safely coerce to an integer, let alone a <code>bigint</code>.</p> <p>But <code>+42n</code> throwing an exception is an interesting case. By contrast, <code>Number(42n)</code> works fine, so it's a bit surprising that <code>+42n</code> fails.</p> WARNING: That surprise is especially palpable since prepending a <code>+</code> in front of a number is typically assumed to just mean a \"positive number\", the same way <code>-</code> in front a number is assumed to mean a \"negative number\". As explained in Chapter 1, however, JS numeric syntax (<code>number</code> and <code>bigint</code>) recognize no syntax for \"negative values\". All numeric literals are parsed as \"positive\" by default. If a <code>+</code> or <code>-</code> is prepended, those are treated as unary operators applied against the parsed (positive) number. <p>OK, so <code>+42n</code> is parsed as <code>+(42n)</code>. But still... why is <code>+</code> throwing an exception here?</p> <p>You might recall earlier when we showed that JS allows explicit string coercion of symbol values, but disallows implicit string coercions? The same thing is going on here. JS language design interprets unary <code>+</code> in front of a <code>bigint</code> value as an implicit <code>ToNumber()</code> coercion (thus disallowed!), but <code>Number(..)</code> is interpreted as an explicit <code>ToNumber()</code> coercion (thus allowed!).</p> <p>In other words, contrary to popular assumption/assertion, <code>Number(..)</code> and <code>+</code> are not interchangable. I think <code>Number(..)</code> is the safer/more reliable form.</p>"},{"location":"types-grammar/ch4/#mathematical-operations","title":"Mathematical Operations","text":"<p>Mathematical operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, and <code>**</code>) expect their operands to be numeric. If you use a non-<code>number</code> with them, that value will be coerced to a <code>number</code> for the purposes of the mathematical computation.</p> <p>Similar to how <code>x + \"\"</code> is an idiom for coercing <code>x</code> to a string, an expression like <code>x - 0</code> safely coerces <code>x</code> to a number.</p> WARNING: <code>x + 0</code> isn't quite as safe, since the <code>+</code> operator is overloaded to perform string concatenation if either operand is already a string. The <code>-</code> minus operator isn't overloaded like that, so the only coercion will be to <code>number</code>. Of course, <code>x * 1</code>, <code>x / 1</code>, and even <code>x ** 1</code> would also generally be equivalent mathematicaly, but those are much less common, and probably should be avoided as likely confusing to readers of your code. Even <code>x % 1</code> seems like it should be safe, but it can introduce floating-point skew (see \"Floating Point Imprecision\" in Chapter 2). <p>Regardless of what mathematical operator is used, if the coercion fails, a <code>NaN</code> is the result, and all of these operators will propagate the <code>NaN</code> out as their result.</p>"},{"location":"types-grammar/ch4/#bitwise-operations","title":"Bitwise Operations","text":"<p>Bitwise operators (e.g., <code>|</code>, <code>&amp;</code>, <code>^</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, and <code>&lt;&lt;&lt;</code>) all expect number operands, but specifically they clamp these values to 32-bit integers.</p> <p>If you're sure the numbers you're dealing with are safely within the 32-bit integer range, <code>x | 0</code> is another common expression idiom that has the effect of coercing <code>x</code> to a <code>number</code> if necessary.</p> <p>Moreover, since JS engines know these values will be integers, there's potential for them to optimize for integer-only math if they see <code>x | 0</code>. This is one of several recommended \"type annotations\" from the ASM.js25 efforts from years ago.</p>"},{"location":"types-grammar/ch4/#property-access","title":"Property Access","text":"<p>Property access of objects (and index access of arrays) is another place where implicit coercion can occur.</p> <p>Consider:</p> <pre><code>myObj = {};\nmyObj[3] = \"hello\";\nmyObj[\"3\"] = \"world\";\nconsole.log( myObj );\n</code></pre> <p>What do you expect from the contents of this object? Do you expect two different properties, numeric <code>3</code> (holding <code>\"hello\"</code>) and string <code>\"3\"</code> (holding <code>\"world\"</code>)? Or do you think both properties are in the same location?</p> <p>If you try that code, you'll see that indeed we get an object with a single property, and it holds the <code>\"world\"</code> value. That means that JS is internally coercing either the <code>3</code> to <code>\"3\"</code>, or vice versa, when those properties accesses are made.</p> <p>Interestingly, the developer console may very well represent the object sort of like this:</p> <pre><code>console.log( myObj );\n// {3: 'world'}\n</code></pre> <p>Does that <code>3</code> there indicate the property is a numeric <code>3</code>? Not quite. Try adding another property to <code>myObj</code>:</p> <pre><code>myObj.something = 42;\nconsole.log( myObj )\n// {3: 'world', something: 42}\n</code></pre> <p>We can see that this developer console doesn't quote string property keys, so we can't infer anything from <code>3</code> versus if the console had used <code>\"3\"</code> for the key name.</p> <p>Let's instead try consulting the specification for the object value[^ObjectValue], where we find:</p> <p>A property key value is either an ECMAScript String value or a Symbol value. All String and Symbol values, including the empty String, are valid as property keys. A property name is a property key that is a String value.</p> <p>OK! So, in JS, objects only hold string (or symbol) properties. That must mean that the numeric <code>3</code> is coerced to a string <code>\"3\"</code>, right?</p> <p>In the same section of the specification, we further read:</p> <p>An integer index is a String-valued property key that is a canonical numeric String (see 7.1.21) and whose numeric value is either +0\ud835\udd3d or a positive integral Number \u2264 \ud835\udd3d(253 - 1). An array index is an integer index whose numeric value i is in the range +0\ud835\udd3d \u2264 i &lt; \ud835\udd3d(232 - 1).</p> <p>If a property key (like <code>\"3\"</code>) looks like a number, it's treated as an integer index. Hmmm... that almost seems to suggest the opposite of what we just posited, right?</p> <p>Nevertheless, we know from the previous quote that property keys are only strings (or symbols). So it must be that \"integer index\" here is not describing the actual location, but rather the intentional usage of <code>3</code> in JS code, as a developer-expressed \"integer index\"; JS must still then actually store it at the location of the \"canonical numeric String\".</p> <p>Consider attempts to use other value-types, like <code>true</code>, <code>null</code>, <code>undefined</code>, or even non-primitives (other objects):</p> <pre><code>myObj[true] = 100;\nmyObj[null] = 200;\nmyObj[undefined] = 300;\nmyObj[ {a:1} ] = 400;\nconsole.log(myObj);\n// {3: 'world', something: 42, true: 100, null: 200,\n// undefined: 300, [object Object]: 400}\n</code></pre> <p>As you can see, all of those other value-types were coerced to strings for the purposes of object property names.</p> <p>But before we convince ourselves of this interpretation that everything (even numbers) is coerced to strings, let's look at an array example:</p> <pre><code>myArr = [];\nmyArr[3] = \"hello\";\nmyArr[\"3\"] = \"world\";\nconsole.log( myArr );\n// [empty \u00d7 3, 'world']\n</code></pre> <p>The developer console will likely represent an array a bit differently than a plain object. Nevertheless, we still see that this array only has the single <code>\"world\"</code> value in it, at the numeric index position corresponding to <code>3</code>.</p> <p>That kind of output sort of implies the opposite of our previous interpretation: that the values of an array are being stored only at numeric positions. If we add another string property-name to <code>myArr</code>:</p> <pre><code>myArr.something = 42;\nconsole.log( myArr );\n// [empty \u00d7 3, 'world', something: 42]\n</code></pre> <p>Now we see that this developer console represents the numerically indexed positions in the array without the property names (locations), but the <code>something</code> property is named in the output.</p> <p>It's also true that JS engines like v8 tend to, for performance optimization reasons, special-case object properties that are numeric-looking strings as actually being stored in numeric positions as if they were arrays. So even if the JS program acts as if the property name is <code>\"3\"</code>, in fact under the covers, v8 might be treating it as if coerced to <code>3</code>!</p> <p>What can take from all this?</p> <p>The specification clearly tells us that the behavior of object properties is for them to be treated like strings (or symbols). That means we can assume that using <code>3</code> to access a location on an object will have the internal effect of coercing that property name to <code>\"3\"</code>.</p> <p>But with arrays, we observe a sort of opposite semantic: using <code>\"3\"</code> as a property name has the effect of accessing the numerically indexed <code>3</code> position, as if the string was coerced to the number. But that's mostly just an offshot of the fact that arrays always tend to behave as numerically indexed, and/or perhaps a reflection of underlying implementation/optimization details in the JS engine.</p> <p>The important part is, we need to recognize that objects cannot simply use any value as a property name. If it's anything other than a string or a number, we can expect that there will be a coercion of that value.</p> <p>We need to expect and plan for that rather than allowing it to surprise us with bugs down the road!</p>"},{"location":"types-grammar/ch4/#to-primitive","title":"To Primitive","text":"<p>Most operators in JS, including those we've seen with coercions to <code>string</code> and <code>number</code>, are designed to run against primitive values. When any of these operators is used instead against an object value, the abstract <code>ToPrimitive</code> algorithm (as described earlier) is activated to coerce the object to a primitive.</p> <p>Let's set up an object we can use to inspect how different operations behave:</p> <pre><code>spyObject = {\ntoString() {\nconsole.log(\"toString() invoked!\");\nreturn \"10\";\n},\nvalueOf() {\nconsole.log(\"valueOf() invoked!\");\nreturn 42;\n},\n};\n</code></pre> <p>This object defines both the <code>toString()</code> and <code>valueOf()</code> methods, and each one returns a different type of value (<code>string</code> vs <code>number</code>).</p> <p>Let's try some of the coercion operations we've already seen:</p> <pre><code>String(spyObject);\n// toString() invoked!\n// \"10\"\nspyObject + \"\";\n// valueOf() invoked!\n// \"42\"\n</code></pre> <p>Whoa! I bet that surprised a few of you readers; it certainly did me. It's so common for people to assert that <code>String(..)</code> and <code>+ \"\"</code> are equivalent forms of activating the <code>ToString()</code> operation. But they're clearly not!</p> <p>The difference comes down to the hint that each operation provides to <code>ToPrimitive()</code>. <code>String(..)</code> clearly provides <code>\"string\"</code> as the hint, whereas the <code>+ \"\"</code> idiom provides no hint (similar to hinting <code>\"number\"</code>). But don't miss this detail: even though <code>+ \"\"</code> invokes <code>valueOf()</code>, when that returns a <code>number</code> primitive value of <code>42</code>, that value is then coerced to a string (via <code>ToString()</code>), so we get <code>\"42\"</code> instead of <code>42</code>.</p> <p>Let's keep going:</p> <pre><code>Number(spyObject);\n// valueOf() invoked!\n// 42\n+spyObject;\n// valueOf() invoked!\n// 42\n</code></pre> <p>This example implies that <code>Number(..)</code> and the unary <code>+</code> operator both perform the same <code>ToPrimitive()</code> coercion (with hint of <code>\"number\"</code>), which in our case returns <code>42</code>. Since that's already a <code>number</code> as requested, the value comes out without further ado.</p> <p>But what if a <code>valueOf()</code> returns a <code>bigint</code>?</p> <pre><code>spyObject2 = {\nvalueOf() {\nconsole.log(\"valueOf() invoked!\");\nreturn 42n;  // bigint!\n}\n};\nNumber(spyObject2);\n// valueOf() invoked!\n// 42     &lt;--- look, not a bigint!\n+spyObject2;\n// valueOf() invoked!\n// TypeError: Cannot convert a BigInt value to a number\n</code></pre> <p>We saw this difference earlier in the \"To Number\" section. JS allows an explicit coercion of the <code>42n</code> bigint value to the <code>42</code> number value, but it disallows what it considers to be an implicit coercion form.</p> <p>What about the <code>BigInt(..)</code> (no <code>new</code> keyword) coercion function?</p> <pre><code>BigInt(spyObject);\n// valueOf() invoked!\n// 42n    &lt;--- look, a bigint!\nBigInt(spyObject2);\n// valueOf() invoked!\n// 42n\n// *******************************\nspyObject3 = {\nvalueOf() {\nconsole.log(\"valueOf() invoked!\");\nreturn 42.3;\n}\n};\nBigInt(spyObject3);\n// valueOf() invoked!\n// RangeError: The number 42.3 cannot be converted to a BigInt\n</code></pre> <p>Again, as we saw in the \"To Number\" section, <code>42</code> can safely be coerced to <code>42n</code>. On the other hand, <code>42.3</code> cannot safely be coerced to a <code>bigint</code>.</p> <p>We've seen that <code>toString()</code> and <code>valueOf()</code> are invoked, variously, as certain <code>string</code> and <code>number</code> / <code>bigint</code> coercions are performed.</p>"},{"location":"types-grammar/ch4/#no-primitive-found","title":"No Primitive Found?","text":"<p>If <code>ToPrimitive()</code> fails to produce a primitive value, an exception will be thrown:</p> <pre><code>spyObject4 = {\ntoString() {\nconsole.log(\"toString() invoked!\");\nreturn [];\n},\nvalueOf() {\nconsole.log(\"valueOf() invoked!\");\nreturn {};\n}\n};\nString(spyObject4);\n// toString() invoked!\n// valueOf() invoked!\n// TypeError: Cannot convert object to primitive value\nNumber(spyObject4);\n// valueOf() invoked!\n// toString() invoked!\n// TypeError: Cannot convert object to primitive value\n</code></pre> <p>If you're going to define custom to-primitive coercions via <code>toString()</code> / <code>valueOf()</code>, make sure to return a primitive from at least one of them!</p>"},{"location":"types-grammar/ch4/#object-to-boolean","title":"Object To Boolean","text":"<p>What about <code>boolean</code> coercions of objects?</p> <pre><code>Boolean(spyObject);\n// true\n!spyObject;\n// false\nif (spyObject) {\nconsole.log(\"if!\");\n}\n// if!\nresult = spyObject ? \"ternary!\" : \"nope\";\n// \"ternary!\"\nwhile (spyObject) {\nconsole.log(\"while!\");\nbreak;\n}\n// while!\n</code></pre> <p>Each of these are activating <code>ToBoolean()</code>. But if you recall from earlier, that algorithm never delegates to <code>ToPrimitive()</code>; thus, we don't see \"valueOf() invoked!\" being logged out.</p>"},{"location":"types-grammar/ch4/#unboxing-wrapper-to-primitive","title":"Unboxing: Wrapper To Primitive","text":"<p>A special form of objects that are often <code>ToPrimitive()</code> coerced: boxed/wrapped primitives (as seen in Chapter 3). This particular object-to-primitive coercion is often referred to as unboxing.</p> <p>Consider:</p> <pre><code>hello = new String(\"hello\");\nString(hello);                  // \"hello\"\nhello + \"\";                     // \"hello\"\nfortyOne = new Number(41);\nNumber(fortyOne);               // 41\nfortyOne + 1;                   // 42\n</code></pre> <p>The object wrappers <code>hello</code> and <code>fortyOne</code> above have <code>toString()</code> and <code>valueOf()</code> methods configured on them, to behave similarly to the <code>spyObject</code> / etc objects from our previous examples.</p> <p>A special case to be careful of with wrapped-object primitives is with <code>Boolean()</code>:</p> <pre><code>nope = new Boolean(false);\nBoolean(nope);                  // true   &lt;--- oops!\n!!nope;                         // true   &lt;--- oops!\n</code></pre> <p>Remember, this is because <code>ToBoolean()</code> does not reduce an object to its primitive form with <code>ToPrimitive</code>; it merely looks up the value in its internal table, and since normal (non-exotic7) objects are always truthy, <code>true</code> comes out.</p> NOTE: It's a nasty little gotcha. A case could certainly be made that <code>new Boolean(false)</code> should configure itself internally as an exotic \"falsy object\". 7 Unfortunately, that change now, 25 years into JS's history, could easily create breakage in programs. As such, JS has left this gotcha untouched."},{"location":"types-grammar/ch4/#overriding-default-tostring","title":"Overriding Default <code>toString()</code>","text":"<p>As we've seen, you can always define a <code>toString()</code> on an object to have it invoked by the appropriate <code>ToPrimitive()</code> coercion. But another option is to override the <code>Symbol.toStringTag</code>:</p> <pre><code>spyObject5a = {};\nString(spyObject5a);\n// \"[object Object]\"\nspyObject5a.toString();\n// \"[object Object]\"\nspyObject5b = {\n[Symbol.toStringTag]: \"my-spy-object\"\n};\nString(spyObject5b);\n// \"[object my-spy-object]\"\nspyObject5b.toString();\n// \"[object my-spy-object]\"\nspyObject5c = {\nget [Symbol.toStringTag]() {\nreturn `myValue:${this.myValue}`;\n},\nmyValue: 42\n};\nString(spyObject5c);\n// \"[object myValue:42]\"\nspyObject5c.toString();\n// \"[object myValue:42]\"\n</code></pre> <p><code>Symbol.toStringTag</code> is intended to define a custom string value to describe the object whenever its default <code>toString()</code> operation is invoked directly, or implicitly via coercion; in its absence, the value used is <code>\"Object\"</code> in the common <code>\"[object Object]\"</code> output.</p> <p>The <code>get ..</code> syntax in <code>spyObject5c</code> is defining a getter. That means when JS tries to access this <code>Symbol.toStringTag</code> as a property (as normal), this gettter code instead causes the function we specify to be invoked to compute the result. We can run any arbitrary logic inside this getter to dynamically determine a string tag for use by the default <code>toString()</code> method.</p>"},{"location":"types-grammar/ch4/#overriding-toprimitive","title":"Overriding <code>ToPrimitive</code>","text":"<p>You can alternately override the whole default <code>ToPrimitive()</code> operation for any object, by setting the special symbol property <code>Symbol.toPrimitive</code> to hold a function:</p> <pre><code>spyObject6 = {\n[Symbol.toPrimitive](hint) {\nconsole.log(`toPrimitive(${hint}) invoked!`);\nreturn 25;\n},\ntoString() {\nconsole.log(\"toString() invoked!\");\nreturn \"10\";\n},\nvalueOf() {\nconsole.log(\"valueOf() invoked!\");\nreturn 42;\n},\n};\nString(spyObject6);\n// toPrimitive(string) invoked!\n// \"25\"   &lt;--- not \"10\"\nspyObject6 + \"\";\n// toPrimitive(default) invoked!\n// \"25\"   &lt;--- not \"42\"\nNumber(spyObject6);\n// toPrimitive(number) invoked!\n// 25     &lt;--- not 42 or \"25\"\n+spyObject6;\n// toPrimitive(number) invoked!\n// 25\n</code></pre> <p>As you can see, if you define this function on an object, it's used entirely in replacement of the default <code>ToPrimitive()</code> abstract operation. Since <code>hint</code> is still provided to this invoked function (<code>[Symbol.toPrimitive](..)</code>), you could in theory implement your own version of the algorithm, invoking a <code>toString()</code>, <code>valueOf()</code>, or any other method on the object (<code>this</code> context reference).</p> <p>Or you can just manually define a return value as shown above. Regardless, JS will not automatically invoke either <code>toString()</code> or <code>valueOf()</code> methods.</p> WARNING: As discussed prior in \"No Primitive Found?\", if the defined <code>Symbol.toPrimitive</code> function does not actually return a value that's a primitive, an exception will be thrown about being unable to \"...convert object to primitive value\". Make sure to always return an actual primitive value from such a function!"},{"location":"types-grammar/ch4/#equality","title":"Equality","text":"<p>Thus far, the coercions we've seen have been focused on single values. We turn out attention now to equality comparisons, which inherently involve two values, either or both of which may be subject to coercion.</p> <p>Earlier in this chapter, we talked about several abstract operations for value equality comparison.</p> <p>For example, the <code>SameValue()</code> operation16 is the strictest of the equality comparisons, with absolutely no coercion. The most obvious JS operation that relies on <code>SameValue()</code> is:</p> <pre><code>Object.is(42,42);                   // true\nObject.is(-0,-0);                   // true\nObject.is(NaN,NaN);                 // true\nObject.is(0,-0);                    // false\n</code></pre> <p>The <code>SameValueZero()</code> operation -- recall, it only differs from <code>SameValue()</code> by treating <code>-0</code> and <code>0</code> as indistinguishable -- is used in quite a few more places, including:</p> <pre><code>[ 1, 2, NaN ].includes(NaN);        // true\n</code></pre> <p>We can see the <code>0</code> / <code>-0</code> misdirection of <code>SameValueZero()</code> here:</p> <pre><code>[ 1, 2, -0 ].includes(0);           // true  &lt;--- oops!\n(new Set([ 1, 2, 0 ])).has(-0);     // true  &lt;--- ugh\n(new Map([[ 0, \"ok\" ]])).has(-0);   // true  &lt;--- :(\n</code></pre> <p>In these cases, there's a coercion (of sorts!) that treats <code>-0</code> and <code>0</code> as indistinguishable. No, that's not technically a \"coercion\" in that the type is not being changed, but I'm sort of fudging the definition to include this case in our broader discussion of coercion here.</p> <p>Contrast the <code>includes()</code> / <code>has()</code> methods here, which activate <code>SameValueZero()</code>, with the good ol' <code>indexOf(..)</code> array utility, which instead activates <code>IsStrictlyEqual()</code> instead. This algorithm is slightly more \"coercive\" than <code>SameValueZero()</code>, in that it prevents <code>NaN</code> values from ever being treated as equal to each other:</p> <pre><code>[ 1, 2, NaN ].indexOf(NaN);         // -1  &lt;--- not found\n</code></pre> <p>If these nuanced quirks of <code>includes(..)</code> and <code>indexOf(..)</code> bother you, when searching -- looking for an equality match within -- for a value in an array, you can avoid any \"coercive\" quicks and force the strictest <code>SameValue()</code> equality matching, via <code>Object.is(..)</code>:</p> <pre><code>vals = [ 0, 1, 2, -0, NaN ];\nvals.find(v =&gt; Object.is(v,-0));            // -0\nvals.find(v =&gt; Object.is(v,NaN));           // NaN\nvals.findIndex(v =&gt; Object.is(v,-0));       // 3\nvals.findIndex(v =&gt; Object.is(v,NaN));      // 4\n</code></pre>"},{"location":"types-grammar/ch4/#equality-operators-vs","title":"Equality Operators: <code>==</code> vs <code>===</code>","text":"<p>The most obvious place where coercion is involved in equality checks is with the <code>==</code> operator. Despite any pre-conceived notions you may have about <code>==</code>, it behaves extremely predictably, ensuring that both operands match types before performing its equality check.</p> <p>To state something that may or may not be super obvious: the <code>==</code> (and <code>===</code>) operators always return a <code>boolean</code> (<code>true</code> or <code>false</code>), indicating the result of the equality check; they never return anything else, regardless of what coercion may happen.</p> <p>Now, recall and review the steps discussed earlier in the chapter for the <code>IsLooselyEqual()</code> operation. 18 Its behavior, and thus how <code>==</code> acts, can be pragmatically intuited with just these two facts in mind:</p> <ol> <li> <p>If the types of both operands are the same, <code>==</code> has the exact same behavior as <code>===</code> -- <code>IsLooselyEqual()</code> immediately delegates to <code>IsStrictlyEqual()</code>. 17</p> <p>For example, when both operands are object references:</p> <pre><code>myObj = { a: 1 };\nanotherObj = myObj;\nmyObj == anotherObj;                // true\nmyObj === anotherObj;               // true\n</code></pre> <p>Here, <code>==</code> and <code>===</code> determine that both of their respective operands are of the <code>object</code> reference type, so both equality checks behave identically; they compare the object references for equality.</p> </li> <li> <p>But if the operand types differ, <code>==</code> allows coercion until they match, and prefers numeric comparison; it attempts to coerce both operands to numbers, if possible:</p> <pre><code>42 == \"42\";                         // true\n</code></pre> <p>Here, the <code>\"42\"</code> string is coerced to a <code>42</code> number (not vice versa), and thus the comparison is then <code>42 == 42</code>, and must clearly return <code>true</code>.</p> </li> </ol> <p>Armed with this knowledge, we'll now dispell the common myth that only <code>===</code> checks the type and value, while <code>==</code> checks only the value. Not true!</p> <p>In fact, <code>==</code> and <code>===</code> are both type-sensitive, each checking the types of their operands. The <code>==</code> operator allows coercion of mismatched types, whereas <code>===</code> disallows any coercion.</p> <p>It's a nearly universally held opinion that <code>==</code> should be avoided in favor of <code>===</code>. I may be one of the only developers who publicly advocates a clear and straight-faced case for the opposite. I think the main reason people instead prefer <code>===</code>, beyond simply conforming to the status quo, is a lack of taking the time to actually understand <code>==</code>.</p> <p>I'll be revisiting this topic to make the case for preferring <code>==</code> over <code>===</code>, later in this chapter, in \"Type Aware Equality\". All I ask is, no matter how strongly you currently disagree with me, try to keep an open mindset.</p>"},{"location":"types-grammar/ch4/#nullish-coercion","title":"Nullish Coercion","text":"<p>We've already seen a number of JS operations that are nullish -- treating <code>null</code> and <code>undefined</code> as coercively equal to each other, including the <code>?.</code> optional-chaining operator and the <code>??</code> nullish-coalescing operator (see \"Null'ish\" in Chapter 1).</p> <p>But <code>==</code> is the most obvious place that JS exposes nullish coercive equality:</p> <pre><code>null == undefined;              // true\n</code></pre> <p>Neither <code>null</code> nor <code>undefined</code> will ever be coercively equal to any other value in the language, other than to each other. That means <code>==</code> makes it ergonomic to treat these two values as indistinguishable.</p> <p>You might take advantage of this capability as such:</p> <pre><code>if (someData == null) {\n// `someData` is \"unset\" (either null or undefined),\n// so set it to some default value\n}\n// OR:\nif (someData != null) {\n// `someData` is set (neither null nor undefined),\n// so use it somehow\n}\n</code></pre> <p>Remember that <code>!=</code> is the negation of <code>==</code>, whereas <code>!==</code> is the negation of <code>===</code>. Don't match the count of <code>=</code>s unless you want to confuse yourself!</p> <p>Compare these two approaches:</p> <pre><code>if (someData == null) {\n// ..\n}\n// vs:\nif (someData === null || someData === undefined) {\n// ..\n}\n</code></pre> <p>Both <code>if</code> statements will behave exactly identically. Which one would you rather write, and which one would you rather read later?</p> <p>To be fair, some of you prefer the more verbose <code>===</code> equivalent. And that's OK. I disagree, I think the <code>==</code> version of this check is much better. And I also maintain that the <code>==</code> version is more consistent in stylistic spirit with how the other nullish operators like <code>?.</code> and <code>??</code> act.</p> <p>But another minor fact you might consider: in performance benchmarks I've run many times, JS engines can perform the single <code>== null</code> check as shown slightly faster than the combination of two <code>===</code> checks. In other words, there's a tiny but measurable benefit to letting JS's <code>==</code> perform the implicit nullish coercion than in trying to explicitly list out both checks yourself.</p> <p>I'd observe that even many diehard <code>===</code> fans tend to concede that <code>== null</code> is at least one such case where <code>==</code> is preferable.</p>"},{"location":"types-grammar/ch4/#boolean-gotcha","title":"<code>==</code> Boolean Gotcha","text":"<p>Aside from some coercive corner cases we'll address in the next section, probably the biggest gotcha to be aware of with <code>==</code> has to do with booleans.</p> <p>Pay very close attention here, as it's one of the biggest reasons people get bitten by, and then come to despise, <code>==</code>. If you take my simple advice (at the end of this section), you'll never be a victim!</p> <p>Consider the following snippet, and let's assume for a minute that <code>isLoggedIn</code> is not holding a <code>boolean</code> value (<code>true</code> or <code>false</code>):</p> <pre><code>if (isLoggedIn) {\n// ..\n}\n// vs:\nif (isLoggedIn == true) {\n// ..\n}\n</code></pre> <p>We've already covered the first <code>if</code> statement form. We know <code>if</code> expects a <code>boolean</code>, so in this case <code>isLoggedIn</code> will be coerced to a <code>boolean</code> using the lookup table in the <code>ToBoolean()</code> abstract operation. Pretty straightforward to predict, right?</p> <p>But take a look at the <code>isLoggedIn == true</code> expression. Do you think it's going to behave the same way?</p> <p>If your instinct was yes, you've just fallen into a tricky little trap. Recall early in this chapter when I warned that the rules of <code>ToBoolean()</code> coercion only apply if the JS operation is actually activating that algorithm. Here, it seems like JS must be doing so, because <code>== true</code> seems so clearly a \"boolean related\" type of comparison.</p> <p>But nope. Go re-read the <code>IsLooselyEqual()</code> algorithm (for <code>==</code>) earlier in the chapter. Go on, I'll wait. If you don't like my summary, go read the specification algorithm18 itself.</p> <p>OK, do you see anything in there that mentions invoking <code>ToBoolean()</code> under any circumstance?</p> <p>Nope!</p> <p>Remember: when the types of the two <code>==</code> operands are not the same, it prefers to coerce them both to numbers.</p> <p>What might be in <code>isLoggedIn</code>, if it's not a <code>boolean</code>? Well, it could be a string value like <code>\"yes\"</code>, for example. In that form, <code>if (\"yes\") { .. }</code> would clearly pass the conditional check and execute the block.</p> <p>But what's going to happen with the <code>==</code> form of the <code>if</code> conditional? It's going to act like this:</p> <pre><code>// (1)\n\"yes\" == true\n// (2)\n\"yes\" == 1\n// (3)\nNaN == 1\n// (4)\nNaN === 1           // false\n</code></pre> <p>So in other words, if <code>isLoggedIn</code> holds a value like <code>\"yes\"</code>, the <code>if (isLoggedIn) { .. }</code> block will pass the conditional check, but the <code>if (isLoggedIn == true)</code> check will not. Ugh!</p> <p>What if <code>isLoggedIn</code> held the string <code>\"true\"</code>?</p> <pre><code>// (1)\n\"true\" == true\n// (2)\n\"true\" == 1\n// (3)\nNaN == 1\n// (4)\nNaN === 1           // false\n</code></pre> <p>Facepalm.</p> <p>Here's a pop quiz: what value would <code>isLoggedIn</code> need to hold for both forms of the <code>if</code> statement conditional to pass?</p> <p>...</p> <p>...</p> <p>...</p> <p>...</p> <p>What if <code>isLoggedIn</code> was holding the number <code>1</code>? <code>1</code> is truthy, so the <code>if (isLoggedIn)</code> form passes. And the other <code>==</code> form that involves coercion:</p> <pre><code>// (1)\n1 == true\n// (2)\n1 == 1\n// (3)\n1 === 1             // true\n</code></pre> <p>But if <code>isLoggedIn</code> was instead holding the string <code>\"1\"</code>? Again, <code>\"1\"</code> is truthy, but what about the <code>==</code> coercion?</p> <pre><code>// (1)\n\"1\" == true\n// (2)\n\"1\" == 1\n// (3)\n1 == 1\n// (4)\n1 === 1             // true\n</code></pre> <p>OK, so <code>1</code> and <code>\"1\"</code> are two values that <code>isLoggedIn</code> can hold that are safe to coerce along with <code>true</code> in a <code>==</code> equality check. But basically almost no other values are safe for <code>isLoggedIn</code> to hold.</p> <p>We have a similar gotcha if the check is <code>== false</code>. What values are safe in such a comparison? <code>\"\"</code> and <code>0</code> work. But:</p> <pre><code>if ([] == false) {\n// this will run!\n}\n</code></pre> <p><code>[]</code> is a truthy value, but it's also coercively equal to <code>false</code>?! Ouch.</p> <p>What are we to make of these gotchas with <code>== true</code> and <code>== false</code> checks? I have a plain and simple answer.</p> <p>Never, ever, under any circumstances, perform a <code>==</code> check if either side of the comparison is a <code>true</code> or <code>false</code> value. It looks like it's going to behave as a nice <code>ToBoolean()</code> coercion, but it slyly won't, and will instead be ensnared in a variety of coercion corner cases (addressed in the next section). And avoid the <code>===</code> forms, too.</p> <p>When you're dealing with booleans, stick to the implicitly coercive forms that are genuinely activating <code>ToBoolean()</code>, such as <code>if (isLoggedIn)</code>, and stay away from the <code>==</code> / <code>===</code> forms.</p>"},{"location":"types-grammar/ch4/#coercion-corner-cases","title":"Coercion Corner Cases","text":"<p>I've been clear in expressing my pro-coercion opinion thus far. And it is just an opinion, though it's based on interpreting facts gleaned from studying the language specification and observable JS behaviors.</p> <p>That's not to say that coercion is perfect. There's several frustrating corner cases we need to be aware of, so we avoid tripping into those potholes. In case it's not clear, my following characterizations of these corner cases are just more of my opinions. Your mileage may vary.</p>"},{"location":"types-grammar/ch4/#strings","title":"Strings","text":"<p>We already saw that the string coercion of an array looks like this:</p> <pre><code>String([ 1, 2, 3 ]);                // \"1,2,3\"\n</code></pre> <p>I personally find that super annoying, that it doesn't include the surrounding <code>[ ]</code>. In particular, that leads to this absurdity:</p> <pre><code>String([]);                         // \"\"\n</code></pre> <p>So we can't tell that it's even an array, because all we get is an empty string? Great, JS. That's just stupid. Sorry, but it is. And it gets worse:</p> <pre><code>String([ null, undefined ]);        // \",\"\n</code></pre> <p>WAT!? We know that <code>null</code> coerces to the string <code>\"null\"</code>, and <code>undefined</code> coerces to the string <code>\"undefined\"</code>. But if those values are in an array, they magically just disappear as empty strings in the array-to-string coercion. Only the <code>\",\"</code> remains to even hint to us there was anything at all in the array! That's just silly town, right there.</p> <p>What about objects? Almost as aggravating, though in the opposite direction:</p> <pre><code>String({});                         // \"[object Object]\"\nString({ a: 1 });                   // \"[object Object]\"\n</code></pre> <p>Umm... OK. Sure, thanks JS for no help at all in understanding what the object value is.</p>"},{"location":"types-grammar/ch4/#numbers","title":"Numbers","text":"<p>I'm about to reveal what I think is the worst root of all coercion corner case evil. Are you ready for it?!?</p> <pre><code>Number(\"\");                         // 0\nNumber(\"       \");                  // 0\n</code></pre> <p>I'm still shaking my head at this one, and I've known about it for nearly 20 years. I still don't get what Brendan was thinking with this one.</p> <p>The empty string is devoid of any contents; it has nothing in it with which to determine a numeric representation. <code>0</code> is absolutely NOT the numeric equivalent of missing/invalid numeric value. You know what number value we have that is well-suited to communicate that? <code>NaN</code>. Don't even get me started on how whitespace is stripped from strings when coercing to a number, so the very-much-not-empty <code>\"       \"</code> string is still treated the same as <code>\"\"</code> for numeric coercion purposes.</p> <p>Even worse, recall how <code>[]</code> coerces to the string <code>\"\"</code>? By extension:</p> <pre><code>Number([]);                         // 0\n</code></pre> <p>Doh! If <code>\"\"</code> didn't coerce to <code>0</code> -- remember, this is the root of all coercion evil! --, then <code>[]</code> wouldn't coerce to <code>0</code> either.</p> <p>This is just absurd, upside-down universe territory.</p> <p>Much more tame, but still mildly annoying:</p> <pre><code>Number(\"NaN\");                      // NaN  &lt;--- accidental!\nNumber(\"Infinity\");                 // Infinity\nNumber(\"infinity\");                 // NaN  &lt;--- oops, watch case!\n</code></pre> <p>The string <code>\"NaN\"</code> is not parsed as a recognizable numeric value, so the coercion fails, producing (accidentally!) the <code>NaN</code> value. <code>\"Infinity\"</code> is explicitly parseable for the coercion, but any other casing, including <code>\"infinity\"</code>, will fail, again producing <code>NaN</code>.</p> <p>This next example, you may not think is a corner case at all:</p> <pre><code>Number(false);                      // 0\nNumber(true);                       // 1\n</code></pre> <p>It's merely programmer convention, legacy from languages that didn't originally have boolean <code>true</code> and <code>false</code> values, that we treat <code>0</code> as <code>false</code>, and <code>1</code> as <code>true</code>. But does it really make sense to go the other direction?</p> <p>Think about it this way:</p> <pre><code>false + true + false + false + true;        // 2\n</code></pre> <p>Really? I don't think there's any case where treating a <code>boolean</code> as its <code>number</code> equivalent makes any rational sense in a program. I can understand the reverse, for historical reasons: <code>Boolean(0)</code> and <code>Boolean(1)</code>.</p> <p>But I genuniely feel that <code>Number(false)</code> and <code>Number(true)</code> (as well as any implicit coercion forms) should produce <code>NaN</code>, not <code>0</code> / <code>1</code>.</p>"},{"location":"types-grammar/ch4/#coercion-absurdity","title":"Coercion Absurdity","text":"<p>To prove my point, let's take the absurdity up to level 11:</p> <pre><code>[] == ![];                          // true\n</code></pre> <p>How!? That seems beyond credibility that a value could be coercively equal to its negation, right!?</p> <p>But follow down the coercion rabbit hole:</p> <ol> <li><code>[] == ![]</code></li> <li><code>[] == false</code></li> <li><code>\"\" == false</code></li> <li><code>0 == false</code></li> <li><code>0 == 0</code></li> <li><code>0 === 0</code>  -&gt;  <code>true</code></li> </ol> <p>We've got three different absurdities conspiring against us: <code>String([])</code>, <code>Number(\"\")</code>, and <code>Number(false)</code>; if any of these weren't true, this nonsense corner case outcome wouldn't occur.</p> <p>Let me make something absolutely clear, though: none of this is <code>==</code>'s fault. It gets the blame here, of course. But the real culprits are the underlying <code>string</code> and <code>number</code> corner cases.</p>"},{"location":"types-grammar/ch4/#type-awareness","title":"Type Awareness","text":"<p>We've now sliced and diced and examined coercion from every conceivable angle, starting from the abstract internals of the specification, then moving to the concrete expressions and statements that actually trigger the coercions.</p> <p>But what's the point of all this? Is the detail in this chapter, and indeed this whole book up to this point, mostly just trivia? Eh, I don't think so.</p> <p>Let's return to the observations/questions I posed way back at the beginning of this long chapter.</p> <p>There's no shortage of opinions (especially negative) about coercion. The nearly universally held position is that coercion is mostly/entirely a bad part of JS's language design. But inspite of that reality, most every developer, in most every JS program ever written, faces the reality that coercion cannot be avoided.</p> <p>In other words, no matter what you do, you won't be able to get away from the need to be aware of, understand, and manage JS's value-types and the conversions them. Contrary to common assumptions, embracing a dynamically-typed (or even a weakly-typed) language, does not mean being careless or unaware of types.</p> <p>Type-aware programming is always, always better than type ignorant/agnostic programming.</p>"},{"location":"types-grammar/ch4/#uhh-typescript","title":"Uhh... TypeScript?","text":"<p>Surely you're thinking at this moment: \"Why can't I just use TypeScript and declare all my types statically, avoiding all the confusion of dynamic typing and coercion?\"</p> NOTE: I have many more detailed thoughts on TypeScript and the larger role it plays in our ecosystem; I'll save those opinions for the appendix (\"Thoughts on TypeScript\"). <p>Let's start by addressing head on the ways TypeScript does, and does not, aid in type-aware programming, as I'm advocating.</p> <p>TypeScript is both statically-typed (meaning types are declared at author time and checked at compile-time) and strongly-typed (meaning variables/containers are typed, and these associations are enforced; strongly-typed systems also disallow implicit coercion). The greatest strength of TypeScript is that it typically forces both the author of the code, and the reader of the code, to confront the types comprising most (ideally, all!) of a program. That's definitely a good thing.</p> <p>By contrast, JS is dynamically-typed (meaning types are discovered and managed purely at runtime) and weakly-typed (meaning variables/containers are not typed, so there's no associations to enforce, and variables can thus hold any value-types; weakly-typed systems allow any form of coercion).</p> NOTE: I'm hand-waving at a pretty high level here, and intentionally not diving deeply into lots of nuance on the static/dynamic and strong/weak typing spectrums. If you're feeling the urge to \"Well, actually...\" me at this moment, please just hold on a bit and let me lay out my arguments."},{"location":"types-grammar/ch4/#type-awareness-without-typescript","title":"Type-Awareness Without TypeScript","text":"<p>Does a dynamically-typed system automatically mean you're programming with less type-awareness? Many would argue that, but I disagree.</p> <p>I do not at all think that declaring static types (annotations, as in TypeScript) is the only way to accomplish effective type-awareness. Clearly, though, proponents of static-typing believe that is the best way.</p> <p>Let me illustrate type-awareness without TypeScript's static typing. Consider this variable declaration:</p> <pre><code>let API_BASE_URL = \"https://some.tld/api/2\";\n</code></pre> <p>Is that statement in any way type-aware? Sure, there's no <code>: string</code> annotation after <code>API_BASE_URL</code>. But I definitely think it is still type-aware! We clearly see the value-type (<code>string</code>) of the value being assigned to <code>API_BASE_URL</code>.</p> WARNING: Don't get distracted by the <code>let</code> declaration being re-assignable (as opposed to a <code>const</code>). JS's <code>const</code> is not a first-class feature of its type system. We don't really gain additional type-awareness simply because we know that reassignment of a <code>const</code> variable is disallowed by the JS engine. If the code is structured well -- ahem, structured with type-awareness as a priority -- we can just read the code and see clearly that <code>API_BASE_URL</code> is not reassigned and is thus still the value-type it was previously assigned. From a type-awareness perspective, that's effectively the same thing as if it couldn't be reassigned. <p>If I later want to do something like:</p> <pre><code>// are we using the secure API URL?\nisSecureAPI = /^https/.test(API_BASE_URL);\n</code></pre> <p>I know the regular-expression <code>test(..)</code> method expects a string, and since I know <code>API_BASE_URL</code> is holding a string, I know that operation is type-safe.</p> <p>Similarly, since I know the simple rules of <code>ToBoolean()</code> coercion as it relates to string values, I know this kind of statement is also type-safe:</p> <pre><code>// do we have an API URL determined yet?\nif (API_BASE_URL) {\n// ..\n}\n</code></pre> <p>But if later, I start to type something like this:</p> <pre><code>APIVersion = Number(API_BASE_URL);\n</code></pre> <p>A warning siren triggers in my head. Since I know there's some very specific rules about how string values coerce to numbers, I recognize that this operation is not type-safe. So I instead approach it differently:</p> <pre><code>// pull out the version number from API URL\nversionDigit = API_BASE_URL.match(/\\/api\\/(\\d+)$/)[1];\n// make sure the version is actually a number\nAPIVersion = Number(versionDigit);\n</code></pre> <p>I know that <code>API_BASE_URL</code> is a string, and I further know the format of its contents includes <code>\".../api/{digits}\"</code> at the end. That lets me know that the regular expression match will succeed, so the <code>[1]</code> array accesss is type-safe.</p> <p>I also know that <code>versionDigit</code> will hold a string, because that's what regular-expression matches return. Now, I know it's safe to coerce that numeric-digit string into a number with <code>Number(..)</code>.</p> <p>By my definition, that kind of thinking, and that style of coding, is type-aware. Type-awareness in coding means thinking carefully about whether or not such things will be clear and obvious to the reader of the code.</p>"},{"location":"types-grammar/ch4/#type-awareness-with-typescript","title":"Type-Awareness With TypeScript","text":"<p>TypeScript fans will point out that TypeScript can, via type inference, do static typing (enforcement) without ever needing a single type annotation in the program. So all the code examples I shared in the previous section, TypeScript can also handle, and provide its flavor of compile-time static type enforcement.</p> <p>In other words, TypeScript will give us the same kind of benefit in type checking, whichever of these two we write:</p> <pre><code>let API_BASE_URL: string = \"https://some.tld/api/2\";\n// vs:\nlet API_BASE_URL = \"https://some.tld/api/2\";\n</code></pre> <p>But there's no free-lunch. We have some issues we need to confront. First of all, TypeScript does not trigger an error here:</p> <pre><code>API_BASE_URL = \"https://some.tld/api/2\";\nAPIVersion = Number(API_BASE_URL);\n// NaN\n</code></pre> <p>Intuitively, I want a type-aware system to understand why that's unsafe. But maybe that's just too much to ask. Or perhaps if we actually define a more narrow/specific type for that <code>API_BASE_URL</code> variable, than simply <code>string</code>, it might help? We can use a TypeScript trick called \"Template Literal Types\": 28</p> <pre><code>type VersionedURL = `https://some.tld/api/${number}`;\nAPI_BASE_URL: VersionedURL = \"https://some.tld/api/2\";\nAPIVersion = Number(API_BASE_URL);\n// NaN\n</code></pre> <p>Nope, TypeScript still doesn't see any problem with that. Yes, I know there's an explanation for why (how <code>Number(..)</code> itself is typed).</p> NOTE: I imagine the really smart folks who know TypeScript well have creative ideas on how we can contort ourselves into raising an error there. Maybe there's even a dozen different ways to force TypeScript to trigger on that code. But that's not really the point. <p>My point is, we cannot fully rely on TypeScript types to solve all our problems, letting us check out and remain blissfully unaware of the nuances of types and, in this case, coercion behaviors.</p> <p>But! You're surely objecting to this line of argument, desperate to assert that even if TypeScript can't understand some specific situation, surely using TypeScript doesn't make it worse! Right!?</p> <p>Let's look at what TypeScript has to say26 about this line:</p> <pre><code>type VersionedURL = `https://some.tld/api/${number}`;\nlet API_BASE_URL: VersionedURL = \"https://some.tld/api/2\";\nlet versionDigit = API_BASE_URL.match(/\\/api\\/(\\d+)$/)[1];\n// Object is possibly 'null'.\n</code></pre> <p>The error indicates that the <code>[1]</code> access isn't type-safe, because if the regular expression fails to find any match on the string, <code>match(..)</code> returns <code>null</code>.</p> <p>You see, even though I can reason about the contents of the string compared to how the regular expression is written, and even if I went to the trouble to make it super clear to TypeScript exactly what those specific string contents are, it's not quite smart enough to line those two up to see that it's actually fully type-safe to assume the match happens.</p> TIP: Is it really the job of, and best use of, a type-aware tool to be contorted to express every single possible nuance of type-safety? We don't need perfect and universal tools to derive immense amounts of benefit from the stuff they can do. <p>Moreover, comparing the code style in the previous section to the code in this section (with or without the annotations), is TypeScript actually making our coding more type-aware?</p> <p>Like, does that <code>type VersionedURL = ..</code> and <code>API_BASE_URL: VersionedURL</code> stuff actually make our code more clearly type-aware? I don't necessarily think so.</p>"},{"location":"types-grammar/ch4/#typescript-intelligence","title":"TypeScript Intelligence","text":"<p>Yes, I hear you screaming at me through the computer screen. Yes, I know that TypeScript provides what type information it discovers (or infers) to your code editor, which comes through in the form of intelligent autocompletes, helpful inline warning markers, etc.</p> <p>But I'm arguing that even those don't, in and of themselves, make you more type-aware as a developer</p> <p>Why? Because type-awareness is not just about the authoring experience. It's also about the reading experience, maybe even moreso. And not all places/mechanisms where code is read, have access to benefit from all the extra intelligence.</p> <p>Look, the magic of a language-server pumping intelligence into your code editor is unquestionably amazing. It's cool and super helpful.</p> <p>And I don't begrudge TypeScript as a tool inferring things about my JS code and giving me hints and suggestions through delightful code editor integrations. I just don't necessarily want to have to annotate type information in some extremely specific way just to silence the tool's complaints.</p>"},{"location":"types-grammar/ch4/#the-bar-above-typescript","title":"The Bar Above TypeScript","text":"<p>But even if I did/had all that, it's still not sufficient for me to be fully type-aware, both as a code-author and as a code-reader.</p> <p>These tools don't catch every type error that can happen, no matter how much we want to tell ourselves they can, and no matter how many hoops and contortions we endure to wish it so. All the efforts to coax and coerce a tool into catching those nuanced errors, through endlessly increasing complexity of type syntax tricks, is... at best, misplaced effort.</p> <p>Moreover, no such tool is immune to false positives, complaining about things which aren't actually errors; these tools will never be as smart as we are as humans. You're really wasting your time in chasing down some quirky syntax trick to quite down the tool's complaints.</p> <p>There's just no subsitute, if you want to truly be a type-aware code-author and code-reader, from learning how the language's built-in type systems work. And yes, that means every single developer on your team needs to spend the efforts to learn it. You can't water this stuff down just to be more attainable for less experienced developers on the project/team.</p> <p>Even if we granted that you could avoid 100% of all implicit coercions -- you can't -- you are absolutely going to face the need to explicit coercions -- all programs do!</p> <p>And if your response to that fact is to suggest that you'll just offload the mental burden of understanding them to a tool like TypeScript... then I'm sorry to tell you, but you're plainly and painfully falling short of the type-aware bar that I'm challenging all developers to strive towards.</p> <p>I'm not advocating, here, for you to ditch TypeScript. If you like it, fine. But I am very explicitly and passionately challenging you: stop using TypeScript as a crutch. Stop prostrating yourself to appease the TypeScript engine overlords. Stop foolishly chasing every type rabbit down every syntactic hole.</p> <p>From my observation, there's a tragic, inverse relationship between usage of type-aware tooling (like TypeScript) and the desire/effort to pursue actual type-awareness as a code-author and code-reader. The more you rely on TypeScript, the more it seems you're tempted and encouraged to shift your attention away from JS's type system (and especially, from coercion) to the alternate TypeScript type system.</p> <p>Unfortunately, TypeScript can never fully escape JS's type system, because TypeScript's types are erased by the compiler, and what's left is just JS that the JS engine has to contend with.</p> TIP: Imagine if someone handed you a cup of filtered water to drink. And just before you took a sip, they said, \"We extracted that water from the ground near a waste dump. But don't worry, we used a perfectly great filter, and that water is totally safe!\" How much do you trust that filter? More to my overall point, wouldn't you feel more comfortable drinking that water if you understood everything about the source of the water, all the processes of filtration, and everything that was in the water of the glass in your hand!? Or is trusting that filter good enough?"},{"location":"types-grammar/ch4/#type-aware-equality","title":"Type Aware Equality","text":"<p>I'll close this long, winding chapter with one final illustration, modeling how I think developers should -- armed with more critical thinking than bandwagon conformism -- approach type-aware coding, whether you use a tool like TypeScript or not.</p> <p>We'll yet again revisit equality comparisons (<code>==</code> vs <code>===</code>), from the perspective of type-awareness. Earlier in this chapter, I promised that I would make the case for <code>==</code> over <code>===</code>, so here it goes.</p> <p>Let's restate/summarize what we know about <code>==</code> and <code>===</code> so far:</p> <ol> <li> <p>If the types of the operands for <code>==</code> match, it behaves exactly the same as <code>===</code>.</p> </li> <li> <p>If the types of the operands for <code>===</code> do not match, it will always return <code>false</code>.</p> </li> <li> <p>If the types of the operands for <code>==</code> do not match, it will allow coercion of either operand (generally preferring numeric type-values), until the types finally match; once they match, see (1).</p> </li> </ol> <p>OK, so let's take those facts and analyze how they might interact in our program.</p> <p>If you are making an equality comparison of <code>x</code> and <code>y</code> like this:</p> <pre><code>if ( /* are x and y equal */ ) {\n// ..\n}\n</code></pre> <p>What are the possible conditions we may be in, with respect to the types of <code>x</code> and <code>y</code>?</p> <ol> <li> <p>We might know exactly what type(s) <code>x</code> and <code>y</code> could be, because we know how those variables are getting assigned.</p> </li> <li> <p>Or we might not be able to tell what those types could be. It could be that <code>x</code> or <code>y</code> could be any type, or at least any of several different types, such that the possible combinations of types in the comparison are too complex to understand/predict.</p> </li> </ol> <p>Can we agree that (1) is far preferable to (2)? Can we further agree that (1) represents having written our code in a type-aware fashion, whereas (2) represents code that is decidedly type-unaware?</p> <p>If you're using TypeScript, you're very likely to be aware of the types of <code>x</code> and <code>y</code>, right? Even if you're not using TypeScript, we've already shown that you can take intentional steps to write your code in such a way that the types of <code>x</code> and <code>y</code> are known and obvious.</p>"},{"location":"types-grammar/ch4/#2-unknown-types","title":"(2) Unknown Types","text":"<p>If you're in scenario (2), I'm going to assert that your code is in a problem state. Your code is less-than-ideal. Your code needs to be refactored. The best thing to do, if you find code in this state, is... fix it!</p> <p>Change the code so it's type-aware. If that means using TypeScript, and even inserting some type annotations, do so. Or if you feel you can get to the type-aware state with just JS, do that. Either way, do whatever you can to get to scenario (1).</p> <p>If you cannot ensure the code doing this equality comparison between <code>x</code> and <code>y</code> is type-aware, and you have no other options, then you absolutely must use the <code>===</code> strict-equality operator. Not doing so would be supremely irresponsible.</p> <pre><code>if (x === y) {\n// ..\n}\n</code></pre> <p>If you don't know anything about the types, how could you (or any other future reader of your code) have any idea how the coercive steps in <code>==</code> are going to behave!? You can't.</p> <p>The only responsible thing to do is, avoid coercion and use <code>===</code>.</p> <p>But don't lose sight of this fact: you're only picking <code>===</code> as a last resort, when your code is so type-unaware -- ahem, type-broken! -- as to have no other choice.</p>"},{"location":"types-grammar/ch4/#1-known-types","title":"(1) Known Types","text":"<p>OK, let's instead assume you're in scenario (1). You know the types of <code>x</code> and <code>y</code>. It's very clear in the code what this narrow set of types participating in the equality check can be.</p> <p>Great!</p> <p>But there's still two possible sub-conditions you may be in:</p> <ul> <li> <p>(1a): <code>x</code> and <code>y</code> might already be of the same type, whether that be both are <code>string</code>s, <code>number</code>s, etc.</p> </li> <li> <p>(1b): <code>x</code> and <code>y</code> might be of different types.</p> </li> </ul> <p>Let's consider each of these cases individually.</p>"},{"location":"types-grammar/ch4/#1a-known-matching-types","title":"(1a) Known Matching Types","text":"<p>If the types in the equality comparison match (whatever they are), we already know for certain that <code>==</code> and <code>===</code> do exactly the same thing. There's absolutely no difference.</p> <p>Except, <code>==</code> is shorter by one character. Most developers feel instinctively that the most terse but equivalent version of something is often most preferable. That's not universal, of course, but it's a general preference at least.</p> <pre><code>// this is best\nif (x == y) {\n// ..\n}\n</code></pre> <p>In this particular case, an extra <code>=</code> would do nothing for us to make the code more clear. In fact, it actually would make the comparison worse!</p> <pre><code>// this is strictly worse here!\nif (x === y) {\n// ..\n}\n</code></pre> <p>Why is it worse?</p> <p>Because in scenario (2), we already established that <code>===</code> is used for the last-resort when we don't know enough/anything about the types to be able to predict the outcome. We use <code>===</code> when we want to make sure we're avoiding coercion when we know coercion could occur.</p> <p>But that doesn't apply here! We already know that no coercion would occur. There's no reason to confuse the reader with a <code>===</code> here. If you use <code>===</code> in a place where you already know the types -- and moreover, they're matched! -- that actually might send a mixed signal to the reader. They might have assumed they knew what would happen in the equality check, but then they see the <code>===</code> and they second guess themselves!</p> <p>Again, to state it plainly, if you know the types of an equality comparison, and you know they match, there's only one right choice: <code>==</code>.</p> <pre><code>// stick to this option\nif (x == y) {\n// ..\n}\n</code></pre>"},{"location":"types-grammar/ch4/#1b-known-mismatched-types","title":"(1b) Known Mismatched Types","text":"<p>OK, we're in our final scenario. We need to compare <code>x</code> and <code>y</code>, and we know their types, but we also know their types are NOT the same.</p> <p>Which operator should we use here?</p> <p>If you pick <code>===</code>, you've made a huge mistake. Why!? Because <code>===</code> used with known-mismatched types will never, ever, ever return <code>true</code>. It will always fail.</p> <pre><code>// `x` and `y` have different types?\nif (x === y) {\n// congratulations, this code in here will NEVER run\n}\n</code></pre> <p>OK. So, <code>===</code> is out when the types are known and mismatched. What's our only other choice?</p> <p>Well, actually, we again have two options. We could decide:</p> <ul> <li> <p>(1b-1): Let's change the code so we're not trying to do an equality check with known mismatched types; that could involve explicitly coercing one or both values so they types now match, in which case pop back up to scenario (1a).</p> </li> <li> <p>(1b-2): If we're going to compare known mismatched types for equality, and we want any hope of that check ever passing, we must used <code>==</code>, because it's the only one of the equality operators which can coerce one or both operands until the types match.</p> </li> </ul> <pre><code>// `x` and `y` have different types,\n// so let's allow JS to coerce them\n// for equality comparison\nif (x == y) {\n// .. (so, you're saying there's a chance?)\n}\n</code></pre> <p>That's it. We're done. We've looked at every possible type-sensitive equality comparison condition (between <code>x</code> and <code>y</code>).</p>"},{"location":"types-grammar/ch4/#summarizing-type-sensitive-equality-comparison","title":"Summarizing Type-Sensitive Equality Comparison","text":"<p>The case for always preferring <code>==</code> over <code>===</code> is as follows:</p> <ol> <li> <p>Whether you use TypeScript or not -- but especially if you do use TypeScript -- the goal should be to have every single part of the code, including all equality comparisons, be type-aware.</p> </li> <li> <p>If you know the types, you should always prefer <code>==</code>.</p> <ul> <li> <p>In the case where the types match, <code>==</code> is both shorter and more proper for the check.</p> </li> <li> <p>In the case where the types are not matched, <code>==</code> is the only operator that can coerce operand(s) until the types match, so it's the only way such a check could ever hope to pass</p> </li> </ul> </li> <li> <p>Finally, only if you can't know/predict the types, for some frustrating reason, and you have no other option, fall back to using <code>===</code> as a last resort. And probably add a code comment there admitting why <code>===</code> is being used, and maybe prompting some future developer to later change the code to fix that deficiency and remove the crutch of <code>===</code>.</p> </li> </ol>"},{"location":"types-grammar/ch4/#typescripts-inconsistency-problem","title":"TypeScript's Inconsistency Problem","text":"<p>Let me be super clear: if you're using TypeScript properly, and you know the types of an equality comparison, using <code>===</code> for that comparison is just plain wrong! Period.</p> <p>The problem is, TypeScript strangely and frustratingly still requires you to use <code>===</code>, unless it already knows that the types are matched.</p> <p>That's because TypeScript either doesn't fully understand type-awareness and coercion, or -- and this is even more infuriating! -- it fully understands but it still despises JS's type system so much as to eschew even the most basic of type-aware reasoning.</p> <p>Don't believe me? Think I'm being too harsh? Try this in TypeScript: 27</p> <pre><code>let result = (42 == \"42\");\n// This condition will always return 'false' since\n// the types 'number' and 'string' have no overlap.\n</code></pre> <p>I am at a loss for words to describe how aggravating that is to me. If you've paid attention to this long, heavy chapter, you know that TypeScript is basically telling a lie here. Of course <code>42 == \"42\"</code> will produce <code>true</code> in JS.</p> <p>Well, it's not a lie, but it's exposing a fundamental truth that so many still don't fully appreciate: TypeScript completely tosses out the normal rules of JS's type system, because TypeScript's position is that JS's type system -- and especially, implicit coercion -- are bad, and need to be replaced.</p> <p>In TypeScript's world, <code>42</code> and <code>\"42\"</code> can never be equal to each other. Hence the error message. But in JS land, <code>42</code> and <code>\"42\"</code> are absolutely coercively equal to each other. And I believe I've made a strong case here that they should be assumed to be safely coercively equivalent.</p> <p>What bothers me even more is, TypeScript has a variety of inconsistencies in this respect. TypeScript is perfectly fine with the implicit coercion in this code:</p> <pre><code>irony = `The value '42' and ${42} are coercively equal.`;\n</code></pre> <p>The <code>42</code> gets implicitly coerced to a string when interpolating it into the sentence. Why is TypeScript ok with this implicit coercion, but not the <code>42 == \"42\"</code> implicit coercion?</p> <p>TypeScript has no complaints about this code, either:</p> <pre><code>API_BASE_URL = \"https://some.tld/api/2\";\nif (API_BASE_URL) {\n// ..\n}\n</code></pre> <p>Why is <code>ToBoolean()</code> an OK implicit coercion, but <code>ToNumber()</code> in the <code>==</code> algorithm is not?</p> <p>I will leave you to ponder this: do you really think it's a good idea to write code that will ultimately run in a JS engine, but use a tool and style of code that has intentionally ejected most of an entire pillar of the JS language? Moreover, is it fine that it's also flip-flopped with a variety of inconsistent exceptions, simply to cater to the old habits of JS developers?</p>"},{"location":"types-grammar/ch4/#whats-left","title":"What's Left?","text":"<p>I hope by now you're feeling a lot more informed about how JS's type system works, from primitive value types to the object types, to how type coercions are performed by the engine.</p> <p>More importantly, you also now have a much more complete picture of the pros/cons of the choices we make using JS's type system, such as choosing implicit or explicit coercions at different points.</p> <p>But we haven't fully covered the context in which the type system operates. For the remainder of this book, we'll turn our attention to the syntax/grammar rules of JS that govern how operators and statements behave.</p> <ol> <li> <p>\"The State of JavaScript - Brendan Eich\", comment thread, Hacker News; Oct 9 2012; https://news.ycombinator.com/item?id=4632704 ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"JavaScript: The World's Most Misunderstood Programming Language\"; 2001; https://www.crockford.com/javascript/javascript.html ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"json2.js\", Github; Apr 21 2018; https://github.com/douglascrockford/JSON-js/blob/8e8b0407e475e35942f7e9461dab81929fcc7321/json2.js#L336 ; Accessed August 2022\u00a0\u21a9\u21a9</p> </li> <li> <p>ESDiscuss mailing list; Aug 26 2014; https://esdiscuss.org/topic/string-symbol#content-15 ; Accessed August 2022\u00a0\u21a9\u21a9</p> </li> <li> <p>\"7.1 Type Conversion\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-type-conversion ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.1.2 ToBoolean(argument)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-toboolean ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"B.3.6 The [[IsHTMLDDA]] Internal Slot\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-IsHTMLDDA-internal-slot ; Accessed August 2022\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>\"7.1.1.1 OrdinaryToPrimitive(O,hint)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-ordinarytoprimitive ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.1.17 ToString(argument)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-tostring ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"22.1.1 The String Constructor\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-string-constructor ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"22.1.1.1 String(value)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-string-constructor-string-value ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.1.4 ToNumber(argument)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-tonumber ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.1.3 ToNumeric(argument)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-tonumeric ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"21.1.1 The Number Constructor\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-number-constructor ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"21.1.1.1 Number(value)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-number-constructor-number-value ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.2.11 SameValue(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-samevalue ; Accessed August 2022\u00a0\u21a9\u21a9</p> </li> <li> <p>\"7.2.16 IsStrictlyEqual(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-isstrictlyequal ; Accessed August 2022\u00a0\u21a9\u21a9</p> </li> <li> <p>\"7.2.15 IsLooselyEqual(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-islooselyequal ; Accessed August 2022\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>\"6.1.6 Numeric Types\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-numeric-types ; Accessed August 2022\u00a0\u21a9\u21a9</p> </li> <li> <p>\"6.1.6.1.13 Number:equal(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-numeric-types-number-equal ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"6.1.6.2.13 BigInt:equal(x,y)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-equal ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.2.14 IsLessThan(x,y,LeftFirst)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-islessthan ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"7.2.9 IsStringPrefix(p,q)\", ECMAScript 2022 Language Specification; https://262.ecma-international.org/13.0/#sec-isstringprefix ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"String(symbol)\", ESDiscuss mailing list; Aug 12 2014; https://esdiscuss.org/topic/string-symbol ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"ASM.js - Working Draft\"; Aug 18 2014; http://asmjs.org/spec/latest/ ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"TypeScript Playground\"; https://tinyurl.com/ydkjs-ts-example-1 ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"TypeScript Playground\"; https://tinyurl.com/ydkjs-ts-example-2 ; Accessed August 2022\u00a0\u21a9</p> </li> <li> <p>\"TypeScript 4.1, Template Literal Types\"; https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types ; Accessed August 2022\u00a0\u21a9</p> </li> </ol>"},{"location":"types-grammar/toc/","title":"TOC: Types &amp; Grammar - 2nd Edition","text":"NOTE: Work in progress"},{"location":"types-grammar/toc/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: Primitive Values<ul> <li>Value Types</li> <li>Empty Values</li> <li>Boolean Values</li> <li>String Values</li> <li>Number Values</li> <li>BigInteger Values</li> <li>Symbol Values</li> <li>Primitives Are Built-In Types</li> </ul> </li> <li>Chapter 2: Primitive Behaviors<ul> <li>Primitive Immutability</li> <li>Primitive Assignments</li> <li>String Behaviors</li> <li>Number Behaviors</li> <li>Primitives Are Foundational</li> </ul> </li> <li>Chapter 3: Object Values<ul> <li>Types of Objects</li> <li>Plain Objects</li> <li>Fundamental Objects</li> <li>Other Built-in Objects</li> <li>Arrays</li> <li>Regular Expressions</li> <li>Functions</li> <li>Proposed: Records/Tuples</li> <li>TODO</li> </ul> </li> <li>Chapter 4: Coercing Values<ul> <li>Coercion: Explicit vs Implicit</li> <li>Abstracts</li> <li>Concrete Coercions</li> <li>Coercion Corner Cases</li> <li>Type Awareness</li> <li>What's Left?</li> </ul> </li> <li>Thank You!</li> </ul>"},{"location":"","title":"Home","text":"<p>https://github.com/getify/You-Dont-Know-JS</p>"},{"location":"#bard","title":"bard","text":"<ul> <li>Chapter 1: What's the Scope?</li> <li>closures bard</li> <li>scope: bard version</li> </ul>"},{"location":"#closures","title":"closures","text":"<ul> <li>Chapter 7: Using Closures</li> <li>closures bard</li> </ul>"},{"location":"#mkdocs","title":"mkdocs","text":"<ul> <li>todo cli integration</li> </ul>"},{"location":"#scope","title":"scope","text":"<ul> <li>Chapter 1: What's the Scope?</li> <li>scope: bard version</li> </ul>"}]}